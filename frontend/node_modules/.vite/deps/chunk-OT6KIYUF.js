import {
  divider_default
} from "./chunk-S3WRKYO2.js";
import {
  popconfirm_default,
  popover_default
} from "./chunk-SGGVCF5P.js";
import {
  dialogPropTypes,
  genModalMaskStyle,
  modal_default,
  useModal_default,
  vc_dialog_default
} from "./chunk-O7ULTKAW.js";
import {
  useDestroyed_default
} from "./chunk-VYZGBDEL.js";
import {
  ArrowLeftOutlined_default,
  ArrowRightOutlined_default,
  BarsOutlined_default,
  CalendarOutlined_default,
  ClockCircleOutlined_default,
  CopyOutlined_default,
  DeleteOutlined_default,
  DownloadOutlined_default,
  EditOutlined_default,
  EnterOutlined_default,
  FileTextOutlined_default,
  FileTwoTone_default,
  PaperClipOutlined_default,
  PictureTwoTone_default,
  PlusOutlined_default,
  ReloadOutlined_default,
  RotateLeftOutlined_default,
  RotateRightOutlined_default,
  StarFilled_default,
  SwapOutlined_default,
  SwapRightOutlined_default,
  UpOutlined_default,
  VerticalAlignTopOutlined_default,
  WarningFilled_default,
  ZoomInOutlined_default,
  ZoomOutOutlined_default
} from "./chunk-73XJEI5V.js";
import {
  CheckableTag_default,
  tag_default
} from "./chunk-3TXDURZY.js";
import {
  space_default
} from "./chunk-5M42PEY6.js";
import {
  Col_default,
  FormItem_default,
  Row_default,
  es_default,
  form_default
} from "./chunk-XLQDUJVZ.js";
import {
  ColumnGroup_default,
  Column_default,
  DirectoryTree_default,
  Divider_default,
  Group_default,
  Group_default2,
  ItemGroup_default,
  MenuItem_default,
  RadioButton_default,
  SiderCollapsedKey,
  SiderHookProviderKey,
  SubMenu_default,
  TableSummary,
  TableSummaryCell,
  TableSummaryRow,
  TreeNode,
  Tree_default,
  checkbox_default,
  conductCheck,
  convertDataToEntities,
  dropdown_button_default,
  dropdown_default,
  dropdown_default2,
  eagerComputed,
  genTreeStyle,
  getScroll,
  getStyle as getStyle2,
  menu_default,
  pagination_default,
  radio_default,
  renderSwitcherIcon,
  scrollTo,
  shallowequal_default,
  spin_default,
  table_default,
  tree_default,
  useBreakpoint_default,
  useMaxLevel,
  useProvideOverride,
  vc_dropdown_default
} from "./chunk-WDJFT2WJ.js";
import {
  EllipsisOutlined_default,
  LeftOutlined_default,
  RightOutlined_default
} from "./chunk-6SKTB3IU.js";
import {
  BaseSelect_default,
  SelectOptGroup,
  SelectOption,
  baseSelectPropsWithoutPrivate,
  getIcons,
  isMobile_default,
  selectProps,
  select_default,
  style_default,
  toReactive,
  useBaseProps,
  useId,
  useInjectLegacySelectContext,
  useMemo,
  useProvideLegacySelectContext
} from "./chunk-VHI3C4E4.js";
import {
  useMergedState
} from "./chunk-EVNRSAPC.js";
import {
  pickAttrs
} from "./chunk-244YQWPU.js";
import {
  KeyCode_default
} from "./chunk-ZE6KZP2H.js";
import {
  CheckOutlined_default,
  DownOutlined_default
} from "./chunk-NNREDFOF.js";
import {
  addClass,
  collapseMotion_default,
  removeClass,
  responsiveArray,
  useResponsiveObserver
} from "./chunk-TPSASZD2.js";
import {
  MAX_VERTICAL_CONTENT_RADIUS,
  firstNotUndefined_default,
  getArrowStyle,
  getPlacements,
  tooltipProps,
  tooltip_default
} from "./chunk-L725M3AB.js";
import {
  isPresetColor
} from "./chunk-XXNA4HS6.js";
import {
  isStyleSupport
} from "./chunk-J3WFKVMM.js";
import {
  BaseMixin_default,
  triggerProps,
  vc_trigger_default
} from "./chunk-N3URHHWY.js";
import {
  PortalWrapper_default,
  addEventListenerWrap,
  collapse_default,
  initFadeMotion,
  initMotion,
  initMoveMotion,
  initSlideMotion,
  initZoomMotion,
  slideDownIn,
  slideDownOut,
  slideUpIn,
  slideUpOut,
  supportsPassive_default
} from "./chunk-OUOMPTR7.js";
import {
  config_provider_default,
  locale_provider_default,
  message_default,
  notification_default,
  useMessage,
  useNotification
} from "./chunk-HMNUWNFQ.js";
import {
  CheckCircleOutlined_default,
  CloseCircleOutlined_default,
  ExclamationCircleOutlined_default,
  InfoCircleFilled_default,
  InfoCircleOutlined_default
} from "./chunk-PZBSLPEE.js";
import {
  CheckCircleFilled_default
} from "./chunk-5X46FVHK.js";
import {
  ExclamationCircleFilled_default
} from "./chunk-75I6BD7E.js";
import {
  CloseOutlined_default
} from "./chunk-6PET3X5V.js";
import {
  getTransitionDirection,
  getTransitionGroupProps,
  getTransitionName,
  getTransitionProps
} from "./chunk-JBCV4ID2.js";
import {
  Group_default as Group_default3,
  Password_default,
  Search_default,
  TextArea_default,
  genActiveStyle,
  genBasicInputStyle,
  genDisabledStyle,
  genHoverStyle,
  genInputGroupStyle,
  genPlaceholderStyle,
  genStatusStyle,
  initInputToken,
  input_default
} from "./chunk-DXXRP4JN.js";
import {
  EyeOutlined_default
} from "./chunk-3HGCOK7T.js";
import {
  button_default,
  button_group_default
} from "./chunk-KQNREJBH.js";
import {
  wave_default
} from "./chunk-SWC2EOVY.js";
import {
  BaseInput_default,
  getClientSize,
  getMergedStatus,
  getOffset,
  getStatusClassNames,
  styleToString,
  vc_resize_observer_default
} from "./chunk-7QLYWY4C.js";
import {
  omit_default
} from "./chunk-ZHGUUDJD.js";
import {
  SearchOutlined_default
} from "./chunk-FU3LKH4U.js";
import {
  genCompactItemStyle
} from "./chunk-UKXCNE53.js";
import {
  useState
} from "./chunk-M6KPOSPM.js";
import {
  Compact_default,
  NoCompactStyle,
  isNumber_default,
  partition_default,
  pick_default,
  useCompactItemContext
} from "./chunk-SQNC5LTS.js";
import {
  FormItemContext_default,
  FormItemInputContext,
  NoFormStatus,
  useInjectFormItemContext
} from "./chunk-WOFLAO6J.js";
import {
  ResizeObserver_es_default
} from "./chunk-EF62HX5R.js";
import {
  cloneElement,
  customRenderSlot,
  deepCloneElement
} from "./chunk-J25OO7CD.js";
import {
  devWarning_default
} from "./chunk-RWOAU33P.js";
import {
  isVisible_default,
  wrapperRaf
} from "./chunk-47E6JZIF.js";
import {
  debounce_default,
  isPlainObject_default
} from "./chunk-LOGVAD4W.js";
import {
  CloseCircleFilled_default
} from "./chunk-QACK6WU4.js";
import {
  LoadingOutlined_default
} from "./chunk-5FGKQH4O.js";
import {
  vue_types_default,
  withUndefined
} from "./chunk-CSNXEAJD.js";
import {
  Keyframes_default,
  LocaleReceiver_default,
  LocaleReceiver_default2,
  _extends,
  _objectSpread2,
  anyType,
  arrayType,
  booleanType,
  camelize,
  canUseDom_default,
  classNames_default,
  clearFix,
  cssinjs_default,
  defaultConfig,
  defaultPresetColors,
  derivative,
  empty_default,
  en_US_default2 as en_US_default,
  en_US_default3 as en_US_default2,
  en_US_default4 as en_US_default3,
  eventType,
  filterEmpty,
  filterEmptyWithUndefined,
  findDOMNode,
  flattenChildren,
  functionType,
  genColorMapToken,
  genComponentStyleHook,
  genControlHeight_default,
  genFocusStyle,
  genFontMapToken_default,
  genPresetColor,
  getClass,
  getDataAndAriaProps,
  getOptionProps,
  getPropsSlot,
  getSlot,
  getStyle,
  hasProp,
  initDefaultProps_default,
  isEmptyContent,
  isEmptyElement,
  isFunction,
  isStringElement,
  isValidElement,
  merge,
  noteOnce,
  objectType,
  operationUnit,
  resetComponent,
  resetIcon,
  roundedArrow,
  someType,
  splitAttrs,
  stringType,
  textEllipsis,
  toPx,
  tuple,
  tupleNum,
  useConfigContextInject,
  useConfigInject_default,
  useInjectDisabled,
  useLocaleReceiver,
  useToken,
  vNodeType,
  version_default,
  warning,
  warning_default,
  warning_default2,
  withInstall
} from "./chunk-4CTYA777.js";
import {
  TinyColor,
  generate,
  gold,
  presetPrimaryColors
} from "./chunk-GO2WV4MH.js";
import {
  Fragment,
  Transition,
  TransitionGroup,
  cloneVNode,
  computed,
  createApp,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  inject,
  isVNode,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onMounted,
  onScopeDispose,
  onUnmounted,
  onUpdated,
  provide,
  reactive,
  ref,
  shallowRef,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  useAttrs,
  vShow,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-VT7FWPCL.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-QY3AG7D4.js";

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2))
              return /* @__PURE__ */ new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r2);
          if ($2 === h)
            return this.set(h, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/dayjs/plugin/weekday.js
var require_weekday = __commonJS({
  "node_modules/dayjs/plugin/weekday.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekday = t();
    }(exports, function() {
      "use strict";
      return function(e, t) {
        t.prototype.weekday = function(e2) {
          var t2 = this.$locale().weekStart || 0, i = this.$W, n = (i < t2 ? i + 7 : i) - t2;
          return this.$utils().u(e2) ? n : this.subtract(n, "day").add(e2, "day");
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/localeData.js
var require_localeData = __commonJS({
  "node_modules/dayjs/plugin/localeData.js"(exports, module) {
    !function(n, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (n = "undefined" != typeof globalThis ? globalThis : n || self).dayjs_plugin_localeData = e();
    }(exports, function() {
      "use strict";
      return function(n, e, t) {
        var r = e.prototype, o = function(n2) {
          return n2 && (n2.indexOf ? n2 : n2.s);
        }, u = function(n2, e2, t2, r2, u2) {
          var i2 = n2.name ? n2 : n2.$locale(), a2 = o(i2[e2]), s2 = o(i2[t2]), f = a2 || s2.map(function(n3) {
            return n3.slice(0, r2);
          });
          if (!u2)
            return f;
          var d = i2.weekStart;
          return f.map(function(n3, e3) {
            return f[(e3 + (d || 0)) % 7];
          });
        }, i = function() {
          return t.Ls[t.locale()];
        }, a = function(n2, e2) {
          return n2.formats[e2] || function(n3) {
            return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
              return e3 || t2.slice(1);
            });
          }(n2.formats[e2.toUpperCase()]);
        }, s = function() {
          var n2 = this;
          return { months: function(e2) {
            return e2 ? e2.format("MMMM") : u(n2, "months");
          }, monthsShort: function(e2) {
            return e2 ? e2.format("MMM") : u(n2, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return n2.$locale().weekStart || 0;
          }, weekdays: function(e2) {
            return e2 ? e2.format("dddd") : u(n2, "weekdays");
          }, weekdaysMin: function(e2) {
            return e2 ? e2.format("dd") : u(n2, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(e2) {
            return e2 ? e2.format("ddd") : u(n2, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(e2) {
            return a(n2.$locale(), e2);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        r.localeData = function() {
          return s.bind(this)();
        }, t.localeData = function() {
          var n2 = i();
          return { firstDayOfWeek: function() {
            return n2.weekStart || 0;
          }, weekdays: function() {
            return t.weekdays();
          }, weekdaysShort: function() {
            return t.weekdaysShort();
          }, weekdaysMin: function() {
            return t.weekdaysMin();
          }, months: function() {
            return t.months();
          }, monthsShort: function() {
            return t.monthsShort();
          }, longDateFormat: function(e2) {
            return a(n2, e2);
          }, meridiem: n2.meridiem, ordinal: n2.ordinal };
        }, t.months = function() {
          return u(i(), "months");
        }, t.monthsShort = function() {
          return u(i(), "monthsShort", "months", 3);
        }, t.weekdays = function(n2) {
          return u(i(), "weekdays", null, null, n2);
        }, t.weekdaysShort = function(n2) {
          return u(i(), "weekdaysShort", "weekdays", 3, n2);
        }, t.weekdaysMin = function(n2) {
          return u(i(), "weekdaysMin", "weekdays", 2, n2);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = __commonJS({
  "node_modules/dayjs/plugin/weekOfYear.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekOfYear = t();
    }(exports, function() {
      "use strict";
      var e = "week", t = "year";
      return function(i, n, r) {
        var f = n.prototype;
        f.week = function(i2) {
          if (void 0 === i2 && (i2 = null), null !== i2)
            return this.add(7 * (i2 - this.week()), "day");
          var n2 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f2 = r(this).startOf(t).add(1, t).date(n2), s = r(this).endOf(e);
            if (f2.isBefore(s))
              return 1;
          }
          var a = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o = this.diff(a, e, true);
          return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
        }, f.weeks = function(e2) {
          return void 0 === e2 && (e2 = null), this.week(e2);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/weekYear.js
var require_weekYear = __commonJS({
  "node_modules/dayjs/plugin/weekYear.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekYear = t();
    }(exports, function() {
      "use strict";
      return function(e, t) {
        t.prototype.weekYear = function() {
          var e2 = this.month(), t2 = this.week(), n = this.year();
          return 1 === t2 && 11 === e2 ? n + 1 : 0 === e2 && t2 >= 52 ? n - 1 : n;
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "node_modules/dayjs/plugin/advancedFormat.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_advancedFormat = t();
    }(exports, function() {
      "use strict";
      return function(e, t) {
        var r = t.prototype, n = r.format;
        r.format = function(e2) {
          var t2 = this, r2 = this.$locale();
          if (!this.isValid())
            return n.bind(this)(e2);
          var s = this.$utils(), a = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
            switch (e3) {
              case "Q":
                return Math.ceil((t2.$M + 1) / 3);
              case "Do":
                return r2.ordinal(t2.$D);
              case "gggg":
                return t2.weekYear();
              case "GGGG":
                return t2.isoWeekYear();
              case "wo":
                return r2.ordinal(t2.week(), "W");
              case "w":
              case "ww":
                return s.s(t2.week(), "w" === e3 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t2.isoWeek(), "W" === e3 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t2.$H ? 24 : t2.$H), "k" === e3 ? 1 : 2, "0");
              case "X":
                return Math.floor(t2.$d.getTime() / 1e3);
              case "x":
                return t2.$d.getTime();
              case "z":
                return "[" + t2.offsetName() + "]";
              case "zzz":
                return "[" + t2.offsetName("long") + "]";
              default:
                return e3;
            }
          });
          return n.bind(this)(a);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var f = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3)
            return 0;
          if ("Z" === e3)
            return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], u = function(e2) {
        var t2 = s[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, d = function(e2, t2) {
        var n2, r2 = s.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e2.indexOf(r2(i2, 0, t2)) > -1) {
              n2 = i2 > 12;
              break;
            }
        } else
          n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, c = { A: [o, function(e2) {
        this.afternoon = d(e2, false);
      }], a: [o, function(e2) {
        this.afternoon = d(e2, true);
      }], Q: [n, function(e2) {
        this.month = 3 * (e2 - 1) + 1;
      }], S: [n, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [r, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
        var t2 = s.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2)
          for (var r2 = 1; r2 <= 31; r2 += 1)
            t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
        var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1)
          throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [o, function(e2) {
        var t2 = u("months").indexOf(e2) + 1;
        if (t2 < 1)
          throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
        this.year = a(e2);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l(n2) {
        var r2, i2;
        r2 = n2, i2 = s && s.formats;
        for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = o2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = o2[f2], u2 = c[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
          o2[f2] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = o2[n3];
            if ("string" == typeof i3)
              r3 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
          this.$u = r3;
          var a2 = o2[1];
          if ("string" == typeof a2) {
            var f2 = true === o2[2], h2 = true === o2[3], u2 = f2 || h2, d2 = o2[2];
            h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
              try {
                if (["x", "X"].indexOf(t4) > -1)
                  return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
                o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a2, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array)
            for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
              o2[1] = a2[m - 1];
              var M = n2.apply(this, o2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e3);
        };
      };
    });
  }
});

// node_modules/ant-design-vue/es/components.js
var components_exports = {};
__export(components_exports, {
  Affix: () => affix_default,
  Alert: () => alert_default,
  Anchor: () => anchor_default,
  AnchorLink: () => AnchorLink_default,
  App: () => app_default,
  AutoComplete: () => auto_complete_default,
  AutoCompleteOptGroup: () => AutoCompleteOptGroup,
  AutoCompleteOption: () => AutoCompleteOption,
  Avatar: () => avatar_default,
  AvatarGroup: () => Group_default4,
  BackTop: () => BackTop_default,
  Badge: () => badge_default,
  BadgeRibbon: () => Ribbon_default,
  Breadcrumb: () => breadcrumb_default,
  BreadcrumbItem: () => BreadcrumbItem_default,
  BreadcrumbSeparator: () => BreadcrumbSeparator_default,
  Button: () => button_default,
  ButtonGroup: () => button_group_default,
  Calendar: () => calendar_default,
  Card: () => card_default,
  CardGrid: () => Grid_default,
  CardMeta: () => Meta_default,
  Carousel: () => carousel_default,
  Cascader: () => cascader_default,
  CheckableTag: () => CheckableTag_default,
  Checkbox: () => checkbox_default,
  CheckboxGroup: () => Group_default2,
  Col: () => col_default,
  Collapse: () => collapse_default2,
  CollapsePanel: () => CollapsePanel_default,
  Comment: () => comment_default,
  Compact: () => Compact_default,
  ConfigProvider: () => config_provider_default,
  DatePicker: () => date_picker_default,
  Descriptions: () => descriptions_default,
  DescriptionsItem: () => DescriptionsItem,
  DirectoryTree: () => DirectoryTree_default,
  Divider: () => divider_default,
  Drawer: () => drawer_default,
  Dropdown: () => dropdown_default2,
  DropdownButton: () => dropdown_button_default,
  Empty: () => empty_default,
  Flex: () => flex_default,
  FloatButton: () => float_button_default,
  FloatButtonGroup: () => FloatButtonGroup_default,
  Form: () => form_default,
  FormItem: () => FormItem_default,
  FormItemRest: () => FormItemContext_default,
  Grid: () => grid_default,
  Image: () => image_default,
  ImagePreviewGroup: () => PreviewGroup_default2,
  Input: () => input_default,
  InputGroup: () => Group_default3,
  InputNumber: () => input_number_default,
  InputPassword: () => Password_default,
  InputSearch: () => Search_default,
  Layout: () => layout_default2,
  LayoutContent: () => LayoutContent,
  LayoutFooter: () => LayoutFooter,
  LayoutHeader: () => LayoutHeader,
  LayoutSider: () => LayoutSider,
  List: () => list_default,
  ListItem: () => Item_default,
  ListItemMeta: () => ItemMeta_default,
  LocaleProvider: () => locale_provider_default,
  Mentions: () => mentions_default,
  MentionsOption: () => MentionsOption,
  Menu: () => menu_default,
  MenuDivider: () => Divider_default,
  MenuItem: () => MenuItem_default,
  MenuItemGroup: () => ItemGroup_default,
  Modal: () => modal_default,
  MonthPicker: () => MonthPicker,
  PageHeader: () => page_header_default,
  Pagination: () => pagination_default,
  Popconfirm: () => popconfirm_default,
  Popover: () => popover_default,
  Progress: () => progress_default2,
  QRCode: () => qrcode_default,
  QuarterPicker: () => QuarterPicker,
  Radio: () => radio_default,
  RadioButton: () => RadioButton_default,
  RadioGroup: () => Group_default,
  RangePicker: () => RangePicker,
  Rate: () => rate_default,
  Result: () => result_default,
  Row: () => row_default,
  Segmented: () => segmented_default2,
  Select: () => select_default,
  SelectOptGroup: () => SelectOptGroup,
  SelectOption: () => SelectOption,
  Skeleton: () => skeleton_default,
  SkeletonAvatar: () => Avatar_default2,
  SkeletonButton: () => Button_default,
  SkeletonImage: () => Image_default,
  SkeletonInput: () => Input_default,
  SkeletonTitle: () => Title_default,
  Slider: () => slider_default2,
  Space: () => space_default,
  Spin: () => spin_default,
  Statistic: () => statistic_default,
  StatisticCountdown: () => StatisticCountdown,
  Step: () => Step,
  Steps: () => steps_default,
  SubMenu: () => SubMenu_default,
  Switch: () => switch_default,
  TabPane: () => TabPane_default,
  Table: () => table_default,
  TableColumn: () => Column_default,
  TableColumnGroup: () => ColumnGroup_default,
  TableSummary: () => TableSummary,
  TableSummaryCell: () => TableSummaryCell,
  TableSummaryRow: () => TableSummaryRow,
  Tabs: () => tabs_default,
  Tag: () => tag_default,
  Textarea: () => TextArea_default,
  TimePicker: () => time_picker_default2,
  TimeRangePicker: () => TimeRangePicker,
  Timeline: () => timeline_default,
  TimelineItem: () => TimelineItem_default,
  Tooltip: () => tooltip_default,
  Tour: () => tour_default,
  Transfer: () => transfer_default,
  Tree: () => tree_default,
  TreeNode: () => TreeNode,
  TreeSelect: () => tree_select_default,
  TreeSelectNode: () => TreeSelectNode,
  Typography: () => typography_default,
  TypographyLink: () => Link_default,
  TypographyParagraph: () => Paragraph_default2,
  TypographyText: () => Text_default,
  TypographyTitle: () => Title_default2,
  Upload: () => upload_default,
  UploadDragger: () => UploadDragger,
  Watermark: () => watermark_default,
  WeekPicker: () => WeekPicker,
  message: () => message_default,
  notification: () => notification_default
});

// node_modules/ant-design-vue/es/_util/throttleByAnimationFrame.js
function throttleByAnimationFrame(fn) {
  let requestId;
  const later = (args) => () => {
    requestId = null;
    fn(...args);
  };
  const throttled = function() {
    if (requestId == null) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      requestId = wrapperRaf(later(args));
    }
  };
  throttled.cancel = () => {
    wrapperRaf.cancel(requestId);
    requestId = null;
  };
  return throttled;
}
var throttleByAnimationFrame_default = throttleByAnimationFrame;

// node_modules/ant-design-vue/es/affix/utils.js
function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function getFixedTop(placeholderRect, targetRect, offsetTop) {
  if (offsetTop !== void 0 && targetRect.top > placeholderRect.top - offsetTop) {
    return `${offsetTop + targetRect.top}px`;
  }
  return void 0;
}
function getFixedBottom(placeholderRect, targetRect, offsetBottom) {
  if (offsetBottom !== void 0 && targetRect.bottom < placeholderRect.bottom + offsetBottom) {
    const targetBottomOffset = window.innerHeight - targetRect.bottom;
    return `${offsetBottom + targetBottomOffset}px`;
  }
  return void 0;
}
var TRIGGER_EVENTS = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
var observerEntities = [];
function addObserveTarget(target, affix) {
  if (!target)
    return;
  let entity = observerEntities.find((item) => item.target === target);
  if (entity) {
    entity.affixList.push(affix);
  } else {
    entity = {
      target,
      affixList: [affix],
      eventHandlers: {}
    };
    observerEntities.push(entity);
    TRIGGER_EVENTS.forEach((eventName) => {
      entity.eventHandlers[eventName] = addEventListenerWrap(target, eventName, () => {
        entity.affixList.forEach((targetAffix) => {
          const {
            lazyUpdatePosition
          } = targetAffix.exposed;
          lazyUpdatePosition();
        }, (eventName === "touchstart" || eventName === "touchmove") && supportsPassive_default ? {
          passive: true
        } : false);
      });
    });
  }
}
function removeObserveTarget(affix) {
  const observerEntity = observerEntities.find((oriObserverEntity) => {
    const hasAffix = oriObserverEntity.affixList.some((item) => item === affix);
    if (hasAffix) {
      oriObserverEntity.affixList = oriObserverEntity.affixList.filter((item) => item !== affix);
    }
    return hasAffix;
  });
  if (observerEntity && observerEntity.affixList.length === 0) {
    observerEntities = observerEntities.filter((item) => item !== observerEntity);
    TRIGGER_EVENTS.forEach((eventName) => {
      const handler2 = observerEntity.eventHandlers[eventName];
      if (handler2 && handler2.remove) {
        handler2.remove();
      }
    });
  }
}

// node_modules/ant-design-vue/es/affix/style/index.js
var genSharedAffixStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      position: "fixed",
      zIndex: token.zIndexPopup
    }
  };
};
var style_default2 = genComponentStyleHook("Affix", (token) => {
  const affixToken = merge(token, {
    zIndexPopup: token.zIndexBase + 10
  });
  return [genSharedAffixStyle(affixToken)];
});

// node_modules/ant-design-vue/es/affix/index.js
function getDefaultTarget() {
  return typeof window !== "undefined" ? window : null;
}
var AffixStatus;
(function(AffixStatus2) {
  AffixStatus2[AffixStatus2["None"] = 0] = "None";
  AffixStatus2[AffixStatus2["Prepare"] = 1] = "Prepare";
})(AffixStatus || (AffixStatus = {}));
var affixProps = () => ({
  /**
   * 距离窗口顶部达到指定偏移量后触发
   */
  offsetTop: Number,
  /** 距离窗口底部达到指定偏移量后触发 */
  offsetBottom: Number,
  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */
  target: {
    type: Function,
    default: getDefaultTarget
  },
  prefixCls: String,
  /** 固定状态改变时触发的回调函数 */
  onChange: Function,
  onTestUpdatePosition: Function
});
var Affix = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAffix",
  inheritAttrs: false,
  props: affixProps(),
  setup(props2, _ref) {
    let {
      slots,
      emit,
      expose,
      attrs
    } = _ref;
    const placeholderNode = shallowRef();
    const fixedNode = shallowRef();
    const state = reactive({
      affixStyle: void 0,
      placeholderStyle: void 0,
      status: AffixStatus.None,
      lastAffix: false,
      prevTarget: null,
      timeout: null
    });
    const currentInstance = getCurrentInstance();
    const offsetTop = computed(() => {
      return props2.offsetBottom === void 0 && props2.offsetTop === void 0 ? 0 : props2.offsetTop;
    });
    const offsetBottom = computed(() => props2.offsetBottom);
    const measure = () => {
      const {
        status,
        lastAffix
      } = state;
      const {
        target
      } = props2;
      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {
        return;
      }
      const targetNode = target();
      if (!targetNode) {
        return;
      }
      const newState = {
        status: AffixStatus.None
      };
      const placeholderRect = getTargetRect(placeholderNode.value);
      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {
        return;
      }
      const targetRect = getTargetRect(targetNode);
      const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);
      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);
      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {
        return;
      }
      if (fixedTop !== void 0) {
        const width = `${placeholderRect.width}px`;
        const height = `${placeholderRect.height}px`;
        newState.affixStyle = {
          position: "fixed",
          top: fixedTop,
          width,
          height
        };
        newState.placeholderStyle = {
          width,
          height
        };
      } else if (fixedBottom !== void 0) {
        const width = `${placeholderRect.width}px`;
        const height = `${placeholderRect.height}px`;
        newState.affixStyle = {
          position: "fixed",
          bottom: fixedBottom,
          width,
          height
        };
        newState.placeholderStyle = {
          width,
          height
        };
      }
      newState.lastAffix = !!newState.affixStyle;
      if (lastAffix !== newState.lastAffix) {
        emit("change", newState.lastAffix);
      }
      _extends(state, newState);
    };
    const prepareMeasure = () => {
      _extends(state, {
        status: AffixStatus.Prepare,
        affixStyle: void 0,
        placeholderStyle: void 0
      });
      if (false) {
        emit("testUpdatePosition");
      }
    };
    const updatePosition = throttleByAnimationFrame_default(() => {
      prepareMeasure();
    });
    const lazyUpdatePosition = throttleByAnimationFrame_default(() => {
      const {
        target
      } = props2;
      const {
        affixStyle
      } = state;
      if (target && affixStyle) {
        const targetNode = target();
        if (targetNode && placeholderNode.value) {
          const targetRect = getTargetRect(targetNode);
          const placeholderRect = getTargetRect(placeholderNode.value);
          const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);
          const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);
          if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) {
            return;
          }
        }
      }
      prepareMeasure();
    });
    expose({
      updatePosition,
      lazyUpdatePosition
    });
    watch(() => props2.target, (val) => {
      const newTarget = (val === null || val === void 0 ? void 0 : val()) || null;
      if (state.prevTarget !== newTarget) {
        removeObserveTarget(currentInstance);
        if (newTarget) {
          addObserveTarget(newTarget, currentInstance);
          updatePosition();
        }
        state.prevTarget = newTarget;
      }
    });
    watch(() => [props2.offsetTop, props2.offsetBottom], updatePosition);
    onMounted(() => {
      const {
        target
      } = props2;
      if (target) {
        state.timeout = setTimeout(() => {
          addObserveTarget(target(), currentInstance);
          updatePosition();
        });
      }
    });
    onUpdated(() => {
      measure();
    });
    onUnmounted(() => {
      clearTimeout(state.timeout);
      removeObserveTarget(currentInstance);
      updatePosition.cancel();
      lazyUpdatePosition.cancel();
    });
    const {
      prefixCls
    } = useConfigInject_default("affix", props2);
    const [wrapSSR, hashId] = style_default2(prefixCls);
    return () => {
      var _a2;
      const {
        affixStyle,
        placeholderStyle,
        status
      } = state;
      const className = classNames_default({
        [prefixCls.value]: affixStyle,
        [hashId.value]: true
      });
      const restProps = omit_default(props2, ["prefixCls", "offsetTop", "offsetBottom", "target", "onChange", "onTestUpdatePosition"]);
      return wrapSSR(createVNode(vc_resize_observer_default, {
        "onResize": updatePosition
      }, {
        default: () => [createVNode("div", _objectSpread2(_objectSpread2(_objectSpread2({}, restProps), attrs), {}, {
          "ref": placeholderNode,
          "data-measure-status": status
        }), [affixStyle && createVNode("div", {
          "style": placeholderStyle,
          "aria-hidden": "true"
        }, null), createVNode("div", {
          "class": className,
          "ref": fixedNode,
          "style": affixStyle
        }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])])]
      }));
    };
  }
});
var affix_default = withInstall(Affix);

// node_modules/ant-design-vue/es/anchor/context.js
function noop() {
}
var AnchorContextKey = Symbol("anchorContextKey");
var useProvideAnchor = (state) => {
  provide(AnchorContextKey, state);
};
var useInjectAnchor = () => {
  return inject(AnchorContextKey, {
    registerLink: noop,
    unregisterLink: noop,
    scrollTo: noop,
    activeLink: computed(() => ""),
    handleClick: noop,
    direction: computed(() => "vertical")
  });
};
var context_default = useProvideAnchor;

// node_modules/ant-design-vue/es/anchor/style/index.js
var genSharedAnchorStyle = (token) => {
  const {
    componentCls,
    holderOffsetBlock,
    motionDurationSlow,
    lineWidthBold,
    colorPrimary,
    lineType,
    colorSplit
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      marginBlockStart: -holderOffsetBlock,
      paddingBlockStart: holderOffsetBlock,
      // delete overflow: auto
      // overflow: 'auto',
      backgroundColor: "transparent",
      [componentCls]: _extends(_extends({}, resetComponent(token)), {
        position: "relative",
        paddingInlineStart: lineWidthBold,
        [`${componentCls}-link`]: {
          paddingBlock: token.anchorPaddingBlock,
          paddingInline: `${token.anchorPaddingInline}px 0`,
          "&-title": _extends(_extends({}, textEllipsis), {
            position: "relative",
            display: "block",
            marginBlockEnd: token.anchorTitleBlock,
            color: token.colorText,
            transition: `all ${token.motionDurationSlow}`,
            "&:only-child": {
              marginBlockEnd: 0
            }
          }),
          [`&-active > ${componentCls}-link-title`]: {
            color: token.colorPrimary
          },
          // link link
          [`${componentCls}-link`]: {
            paddingBlock: token.anchorPaddingBlockSecondary
          }
        }
      }),
      [`&:not(${componentCls}-wrapper-horizontal)`]: {
        [componentCls]: {
          "&::before": {
            position: "absolute",
            left: {
              _skip_check_: true,
              value: 0
            },
            top: 0,
            height: "100%",
            borderInlineStart: `${lineWidthBold}px ${lineType} ${colorSplit}`,
            content: '" "'
          },
          [`${componentCls}-ink`]: {
            position: "absolute",
            left: {
              _skip_check_: true,
              value: 0
            },
            display: "none",
            transform: "translateY(-50%)",
            transition: `top ${motionDurationSlow} ease-in-out`,
            width: lineWidthBold,
            backgroundColor: colorPrimary,
            [`&${componentCls}-ink-visible`]: {
              display: "inline-block"
            }
          }
        }
      },
      [`${componentCls}-fixed ${componentCls}-ink ${componentCls}-ink`]: {
        display: "none"
      }
    }
  };
};
var genSharedAnchorHorizontalStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow,
    lineWidthBold,
    colorPrimary
  } = token;
  return {
    [`${componentCls}-wrapper-horizontal`]: {
      position: "relative",
      "&::before": {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: 0
        },
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        borderBottom: `1px ${token.lineType} ${token.colorSplit}`,
        content: '" "'
      },
      [componentCls]: {
        overflowX: "scroll",
        position: "relative",
        display: "flex",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
          /* Safari and Chrome */
        },
        [`${componentCls}-link:first-of-type`]: {
          paddingInline: 0
        },
        [`${componentCls}-ink`]: {
          position: "absolute",
          bottom: 0,
          transition: `left ${motionDurationSlow} ease-in-out, width ${motionDurationSlow} ease-in-out`,
          height: lineWidthBold,
          backgroundColor: colorPrimary
        }
      }
    }
  };
};
var style_default3 = genComponentStyleHook("Anchor", (token) => {
  const {
    fontSize,
    fontSizeLG,
    padding,
    paddingXXS
  } = token;
  const anchorToken = merge(token, {
    holderOffsetBlock: paddingXXS,
    anchorPaddingBlock: paddingXXS,
    anchorPaddingBlockSecondary: paddingXXS / 2,
    anchorPaddingInline: padding,
    anchorTitleBlock: fontSize / 14 * 3,
    anchorBallSize: fontSizeLG / 2
  });
  return [genSharedAnchorStyle(anchorToken), genSharedAnchorHorizontalStyle(anchorToken)];
});

// node_modules/ant-design-vue/es/anchor/AnchorLink.js
var anchorLinkProps = () => ({
  prefixCls: String,
  href: String,
  title: anyType(),
  target: String,
  /* private use  */
  customTitleProps: objectType()
});
var AnchorLink_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchorLink",
  inheritAttrs: false,
  props: initDefaultProps_default(anchorLinkProps(), {
    href: "#"
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    let mergedTitle = null;
    const {
      handleClick: contextHandleClick,
      scrollTo: scrollTo3,
      unregisterLink,
      registerLink,
      activeLink
    } = useInjectAnchor();
    const {
      prefixCls
    } = useConfigInject_default("anchor", props2);
    const handleClick = (e) => {
      const {
        href
      } = props2;
      contextHandleClick(e, {
        title: mergedTitle,
        href
      });
      scrollTo3(href);
    };
    watch(() => props2.href, (val, oldVal) => {
      nextTick(() => {
        unregisterLink(oldVal);
        registerLink(val);
      });
    });
    onMounted(() => {
      registerLink(props2.href);
    });
    onBeforeUnmount(() => {
      unregisterLink(props2.href);
    });
    return () => {
      var _a2;
      const {
        href,
        target,
        title = slots.title,
        customTitleProps = {}
      } = props2;
      const pre = prefixCls.value;
      mergedTitle = typeof title === "function" ? title(customTitleProps) : title;
      const active = activeLink.value === href;
      const wrapperClassName = classNames_default(`${pre}-link`, {
        [`${pre}-link-active`]: active
      }, attrs.class);
      const titleClassName = classNames_default(`${pre}-link-title`, {
        [`${pre}-link-title-active`]: active
      });
      return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": wrapperClassName
      }), [createVNode("a", {
        "class": titleClassName,
        "href": href,
        "title": typeof mergedTitle === "string" ? mergedTitle : "",
        "target": target,
        "onClick": handleClick
      }, [slots.customTitle ? slots.customTitle(customTitleProps) : mergedTitle]), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});

// node_modules/ant-design-vue/es/anchor/Anchor.js
function getDefaultContainer() {
  return window;
}
function getOffsetTop(element, container) {
  if (!element.getClientRects().length) {
    return 0;
  }
  const rect = element.getBoundingClientRect();
  if (rect.width || rect.height) {
    if (container === window) {
      container = element.ownerDocument.documentElement;
      return rect.top - container.clientTop;
    }
    return rect.top - container.getBoundingClientRect().top;
  }
  return rect.top;
}
var sharpMatcherRegx = /#([\S ]+)$/;
var anchorProps = () => ({
  prefixCls: String,
  offsetTop: Number,
  bounds: Number,
  affix: {
    type: Boolean,
    default: true
  },
  showInkInFixed: {
    type: Boolean,
    default: false
  },
  getContainer: Function,
  wrapperClass: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  getCurrentAnchor: Function,
  targetOffset: Number,
  items: arrayType(),
  direction: vue_types_default.oneOf(["vertical", "horizontal"]).def("vertical"),
  onChange: Function,
  onClick: Function
});
var Anchor_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchor",
  inheritAttrs: false,
  props: anchorProps(),
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      slots,
      expose
    } = _ref;
    var _a2;
    const {
      prefixCls,
      getTargetContainer,
      direction
    } = useConfigInject_default("anchor", props2);
    const anchorDirection = computed(() => {
      var _a3;
      return (_a3 = props2.direction) !== null && _a3 !== void 0 ? _a3 : "vertical";
    });
    if (true) {
      devWarning_default(props2.items && typeof slots.default !== "function", "Anchor", "`Anchor children` is deprecated. Please use `items` instead.");
    }
    if (true) {
      devWarning_default(!(anchorDirection.value === "horizontal" && ((_a2 = props2.items) === null || _a2 === void 0 ? void 0 : _a2.some((n) => "children" in n))), "Anchor", "`Anchor items#children` is not supported when `Anchor` direction is horizontal.");
    }
    const spanLinkNode = ref(null);
    const anchorRef = ref();
    const state = reactive({
      links: [],
      scrollContainer: null,
      scrollEvent: null,
      animating: false
    });
    const activeLink = ref(null);
    const getContainer = computed(() => {
      const {
        getContainer: getContainer2
      } = props2;
      return getContainer2 || (getTargetContainer === null || getTargetContainer === void 0 ? void 0 : getTargetContainer.value) || getDefaultContainer;
    });
    const getCurrentAnchor = function() {
      let offsetTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let bounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
      const linkSections = [];
      const container = getContainer.value();
      state.links.forEach((link) => {
        const sharpLinkMatch = sharpMatcherRegx.exec(link.toString());
        if (!sharpLinkMatch) {
          return;
        }
        const target = document.getElementById(sharpLinkMatch[1]);
        if (target) {
          const top = getOffsetTop(target, container);
          if (top < offsetTop + bounds) {
            linkSections.push({
              link,
              top
            });
          }
        }
      });
      if (linkSections.length) {
        const maxSection = linkSections.reduce((prev, curr) => curr.top > prev.top ? curr : prev);
        return maxSection.link;
      }
      return "";
    };
    const setCurrentActiveLink = (link) => {
      const {
        getCurrentAnchor: getCurrentAnchor2
      } = props2;
      if (activeLink.value === link) {
        return;
      }
      activeLink.value = typeof getCurrentAnchor2 === "function" ? getCurrentAnchor2(link) : link;
      emit("change", link);
    };
    const handleScrollTo = (link) => {
      const {
        offsetTop,
        targetOffset: targetOffset2
      } = props2;
      setCurrentActiveLink(link);
      const sharpLinkMatch = sharpMatcherRegx.exec(link);
      if (!sharpLinkMatch) {
        return;
      }
      const targetElement = document.getElementById(sharpLinkMatch[1]);
      if (!targetElement) {
        return;
      }
      const container = getContainer.value();
      const scrollTop = getScroll(container, true);
      const eleOffsetTop = getOffsetTop(targetElement, container);
      let y = scrollTop + eleOffsetTop;
      y -= targetOffset2 !== void 0 ? targetOffset2 : offsetTop || 0;
      state.animating = true;
      scrollTo(y, {
        callback: () => {
          state.animating = false;
        },
        getContainer: getContainer.value
      });
    };
    expose({
      scrollTo: handleScrollTo
    });
    const handleScroll = () => {
      if (state.animating) {
        return;
      }
      const {
        offsetTop,
        bounds,
        targetOffset: targetOffset2
      } = props2;
      const currentActiveLink = getCurrentAnchor(targetOffset2 !== void 0 ? targetOffset2 : offsetTop || 0, bounds);
      setCurrentActiveLink(currentActiveLink);
    };
    const updateInk = () => {
      const linkNode = anchorRef.value.querySelector(`.${prefixCls.value}-link-title-active`);
      if (linkNode && spanLinkNode.value) {
        const horizontalAnchor = anchorDirection.value === "horizontal";
        spanLinkNode.value.style.top = horizontalAnchor ? "" : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;
        spanLinkNode.value.style.height = horizontalAnchor ? "" : `${linkNode.clientHeight}px`;
        spanLinkNode.value.style.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : "";
        spanLinkNode.value.style.width = horizontalAnchor ? `${linkNode.clientWidth}px` : "";
        if (horizontalAnchor) {
          es_default(linkNode, {
            scrollMode: "if-needed",
            block: "nearest"
          });
        }
      }
    };
    context_default({
      registerLink: (link) => {
        if (!state.links.includes(link)) {
          state.links.push(link);
        }
      },
      unregisterLink: (link) => {
        const index2 = state.links.indexOf(link);
        if (index2 !== -1) {
          state.links.splice(index2, 1);
        }
      },
      activeLink,
      scrollTo: handleScrollTo,
      handleClick: (e, info) => {
        emit("click", e, info);
      },
      direction: anchorDirection
    });
    onMounted(() => {
      nextTick(() => {
        const container = getContainer.value();
        state.scrollContainer = container;
        state.scrollEvent = addEventListenerWrap(state.scrollContainer, "scroll", handleScroll);
        handleScroll();
      });
    });
    onBeforeUnmount(() => {
      if (state.scrollEvent) {
        state.scrollEvent.remove();
      }
    });
    onUpdated(() => {
      if (state.scrollEvent) {
        const currentContainer = getContainer.value();
        if (state.scrollContainer !== currentContainer) {
          state.scrollContainer = currentContainer;
          state.scrollEvent.remove();
          state.scrollEvent = addEventListenerWrap(state.scrollContainer, "scroll", handleScroll);
          handleScroll();
        }
      }
      updateInk();
    });
    const createNestedLink = (options) => Array.isArray(options) ? options.map((option) => {
      const {
        children,
        key,
        href,
        target,
        class: cls,
        style,
        title
      } = option;
      return createVNode(AnchorLink_default, {
        "key": key,
        "href": href,
        "target": target,
        "class": cls,
        "style": style,
        "title": title,
        "customTitleProps": option
      }, {
        default: () => [anchorDirection.value === "vertical" ? createNestedLink(children) : null],
        customTitle: slots.customTitle
      });
    }) : null;
    const [wrapSSR, hashId] = style_default3(prefixCls);
    return () => {
      var _a3;
      const {
        offsetTop,
        affix,
        showInkInFixed
      } = props2;
      const pre = prefixCls.value;
      const inkClass = classNames_default(`${pre}-ink`, {
        [`${pre}-ink-visible`]: activeLink.value
      });
      const wrapperClass = classNames_default(hashId.value, props2.wrapperClass, `${pre}-wrapper`, {
        [`${pre}-wrapper-horizontal`]: anchorDirection.value === "horizontal",
        [`${pre}-rtl`]: direction.value === "rtl"
      });
      const anchorClass = classNames_default(pre, {
        [`${pre}-fixed`]: !affix && !showInkInFixed
      });
      const wrapperStyle2 = _extends({
        maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : "100vh"
      }, props2.wrapperStyle);
      const anchorContent = createVNode("div", {
        "class": wrapperClass,
        "style": wrapperStyle2,
        "ref": anchorRef
      }, [createVNode("div", {
        "class": anchorClass
      }, [createVNode("span", {
        "class": inkClass,
        "ref": spanLinkNode
      }, null), Array.isArray(props2.items) ? createNestedLink(props2.items) : (_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots)])]);
      return wrapSSR(!affix ? anchorContent : createVNode(affix_default, _objectSpread2(_objectSpread2({}, attrs), {}, {
        "offsetTop": offsetTop,
        "target": getContainer.value
      }), {
        default: () => [anchorContent]
      }));
    };
  }
});

// node_modules/ant-design-vue/es/anchor/index.js
Anchor_default.Link = AnchorLink_default;
Anchor_default.install = function(app) {
  app.component(Anchor_default.name, Anchor_default);
  app.component(Anchor_default.Link.name, Anchor_default.Link);
  return app;
};
var anchor_default = Anchor_default;

// node_modules/ant-design-vue/es/auto-complete/Option.js
var Option = () => null;
Option.isSelectOption = true;
Option.displayName = "AAutoCompleteOption";
var Option_default = Option;

// node_modules/ant-design-vue/es/auto-complete/OptGroup.js
var OptGroup = () => null;
OptGroup.isSelectOptGroup = true;
OptGroup.displayName = "AAutoCompleteOptGroup";
var OptGroup_default = OptGroup;

// node_modules/ant-design-vue/es/auto-complete/index.js
function isSelectOptionOrSelectOptGroup(child) {
  var _a2, _b;
  return ((_a2 = child === null || child === void 0 ? void 0 : child.type) === null || _a2 === void 0 ? void 0 : _a2.isSelectOption) || ((_b = child === null || child === void 0 ? void 0 : child.type) === null || _b === void 0 ? void 0 : _b.isSelectOptGroup);
}
var autoCompleteProps = () => _extends(_extends({}, omit_default(selectProps(), ["loading", "mode", "optionLabelProp", "labelInValue"])), {
  dataSource: Array,
  dropdownMenuStyle: {
    type: Object,
    default: void 0
  },
  // optionLabelProp: String,
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: true
  },
  prefixCls: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  transitionName: String,
  choiceTransitionName: {
    type: String,
    default: "zoom"
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  backfill: {
    type: Boolean,
    default: void 0
  },
  // optionLabelProp: PropTypes.string.def('children'),
  filterOption: {
    type: [Boolean, Function],
    default: false
  },
  defaultActiveFirstOption: {
    type: Boolean,
    default: true
  },
  status: String
});
var AutoCompleteOption = Option_default;
var AutoCompleteOptGroup = OptGroup_default;
var AutoComplete = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAutoComplete",
  inheritAttrs: false,
  props: autoCompleteProps(),
  // emits: ['change', 'select', 'focus', 'blur'],
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    warning_default2(!("dataSource" in slots), "AutoComplete", "`dataSource` slot is deprecated, please use props `options` instead.");
    warning_default2(!("options" in slots), "AutoComplete", "`options` slot is deprecated, please use props `options` instead.");
    warning_default2(!props2.dropdownClassName, "AutoComplete", "`dropdownClassName` is deprecated, please use `popupClassName` instead.");
    const selectRef = ref();
    const getInputElement = () => {
      var _a2;
      const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      const element = children.length ? children[0] : void 0;
      return element;
    };
    const focus = () => {
      var _a2;
      (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur
    });
    const {
      prefixCls
    } = useConfigInject_default("select", props2);
    return () => {
      var _a2, _b, _c;
      const {
        size,
        dataSource,
        notFoundContent = (_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
      } = props2;
      let optionChildren;
      const {
        class: className
      } = attrs;
      const cls = {
        [className]: !!className,
        [`${prefixCls.value}-lg`]: size === "large",
        [`${prefixCls.value}-sm`]: size === "small",
        [`${prefixCls.value}-show-search`]: true,
        [`${prefixCls.value}-auto-complete`]: true
      };
      if (props2.options === void 0) {
        const childArray = ((_b = slots.dataSource) === null || _b === void 0 ? void 0 : _b.call(slots)) || ((_c = slots.options) === null || _c === void 0 ? void 0 : _c.call(slots)) || [];
        if (childArray.length && isSelectOptionOrSelectOptGroup(childArray[0])) {
          optionChildren = childArray;
        } else {
          optionChildren = dataSource ? dataSource.map((item) => {
            if (isValidElement(item)) {
              return item;
            }
            switch (typeof item) {
              case "string":
                return createVNode(Option_default, {
                  "key": item,
                  "value": item
                }, {
                  default: () => [item]
                });
              case "object":
                return createVNode(Option_default, {
                  "key": item.value,
                  "value": item.value
                }, {
                  default: () => [item.text]
                });
              default:
                throw new Error("AutoComplete[dataSource] only supports type `string[] | Object[]`.");
            }
          }) : [];
        }
      }
      const selectProps2 = omit_default(_extends(_extends(_extends({}, props2), attrs), {
        mode: select_default.SECRET_COMBOBOX_MODE_DO_NOT_USE,
        // optionLabelProp,
        getInputElement,
        notFoundContent,
        // placeholder: '',
        class: cls,
        popupClassName: props2.popupClassName || props2.dropdownClassName,
        ref: selectRef
      }), ["dataSource", "loading"]);
      return createVNode(select_default, selectProps2, _objectSpread2({
        default: () => [optionChildren]
      }, omit_default(slots, ["default", "dataSource", "options"])));
    };
  }
});
var auto_complete_default = _extends(AutoComplete, {
  Option: Option_default,
  OptGroup: OptGroup_default,
  install(app) {
    app.component(AutoComplete.name, AutoComplete);
    app.component(Option_default.displayName, Option_default);
    app.component(OptGroup_default.displayName, OptGroup_default);
    return app;
  }
});

// node_modules/ant-design-vue/es/alert/style/index.js
var genAlertTypeStyle = (bgColor, borderColor, iconColor, token, alertCls) => ({
  backgroundColor: bgColor,
  border: `${token.lineWidth}px ${token.lineType} ${borderColor}`,
  [`${alertCls}-icon`]: {
    color: iconColor
  }
});
var genBaseStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow: duration,
    marginXS,
    marginSM,
    fontSize,
    fontSizeLG,
    lineHeight,
    borderRadiusLG: borderRadius,
    motionEaseInOutCirc,
    alertIconSizeLG,
    colorText,
    paddingContentVerticalSM,
    alertPaddingHorizontal,
    paddingMD,
    paddingContentHorizontalLG
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      position: "relative",
      display: "flex",
      alignItems: "center",
      padding: `${paddingContentVerticalSM}px ${alertPaddingHorizontal}px`,
      wordWrap: "break-word",
      borderRadius,
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-content`]: {
        flex: 1,
        minWidth: 0
      },
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginXS,
        lineHeight: 0
      },
      [`&-description`]: {
        display: "none",
        fontSize,
        lineHeight
      },
      "&-message": {
        color: colorText
      },
      [`&${componentCls}-motion-leave`]: {
        overflow: "hidden",
        opacity: 1,
        transition: `max-height ${duration} ${motionEaseInOutCirc}, opacity ${duration} ${motionEaseInOutCirc},
        padding-top ${duration} ${motionEaseInOutCirc}, padding-bottom ${duration} ${motionEaseInOutCirc},
        margin-bottom ${duration} ${motionEaseInOutCirc}`
      },
      [`&${componentCls}-motion-leave-active`]: {
        maxHeight: 0,
        marginBottom: "0 !important",
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    }),
    [`${componentCls}-with-description`]: {
      alignItems: "flex-start",
      paddingInline: paddingContentHorizontalLG,
      paddingBlock: paddingMD,
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginSM,
        fontSize: alertIconSizeLG,
        lineHeight: 0
      },
      [`${componentCls}-message`]: {
        display: "block",
        marginBottom: marginXS,
        color: colorText,
        fontSize: fontSizeLG
      },
      [`${componentCls}-description`]: {
        display: "block"
      }
    },
    [`${componentCls}-banner`]: {
      marginBottom: 0,
      border: "0 !important",
      borderRadius: 0
    }
  };
};
var genTypeStyle = (token) => {
  const {
    componentCls,
    colorSuccess,
    colorSuccessBorder,
    colorSuccessBg,
    colorWarning,
    colorWarningBorder,
    colorWarningBg,
    colorError,
    colorErrorBorder,
    colorErrorBg,
    colorInfo,
    colorInfoBorder,
    colorInfoBg
  } = token;
  return {
    [componentCls]: {
      "&-success": genAlertTypeStyle(colorSuccessBg, colorSuccessBorder, colorSuccess, token, componentCls),
      "&-info": genAlertTypeStyle(colorInfoBg, colorInfoBorder, colorInfo, token, componentCls),
      "&-warning": genAlertTypeStyle(colorWarningBg, colorWarningBorder, colorWarning, token, componentCls),
      "&-error": _extends(_extends({}, genAlertTypeStyle(colorErrorBg, colorErrorBorder, colorError, token, componentCls)), {
        [`${componentCls}-description > pre`]: {
          margin: 0,
          padding: 0
        }
      })
    }
  };
};
var genActionStyle = (token) => {
  const {
    componentCls,
    iconCls,
    motionDurationMid,
    marginXS,
    fontSizeIcon,
    colorIcon,
    colorIconHover
  } = token;
  return {
    [componentCls]: {
      [`&-action`]: {
        marginInlineStart: marginXS
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: marginXS,
        padding: 0,
        overflow: "hidden",
        fontSize: fontSizeIcon,
        lineHeight: `${fontSizeIcon}px`,
        backgroundColor: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        [`${iconCls}-close`]: {
          color: colorIcon,
          transition: `color ${motionDurationMid}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      },
      "&-close-text": {
        color: colorIcon,
        transition: `color ${motionDurationMid}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }
  };
};
var genAlertStyle = (token) => [genBaseStyle(token), genTypeStyle(token), genActionStyle(token)];
var style_default4 = genComponentStyleHook("Alert", (token) => {
  const {
    fontSizeHeading3
  } = token;
  const alertToken = merge(token, {
    alertIconSizeLG: fontSizeHeading3,
    alertPaddingHorizontal: 12
    // Fixed value here.
  });
  return [genAlertStyle(alertToken)];
});

// node_modules/ant-design-vue/es/alert/index.js
var iconMapFilled = {
  success: CheckCircleFilled_default,
  info: InfoCircleFilled_default,
  error: CloseCircleFilled_default,
  warning: ExclamationCircleFilled_default
};
var iconMapOutlined = {
  success: CheckCircleOutlined_default,
  info: InfoCircleOutlined_default,
  error: CloseCircleOutlined_default,
  warning: ExclamationCircleOutlined_default
};
var AlertTypes = tuple("success", "info", "warning", "error");
var alertProps = () => ({
  /**
   * Type of Alert styles, options: `success`, `info`, `warning`, `error`
   */
  type: vue_types_default.oneOf(AlertTypes),
  /** Whether Alert can be closed */
  closable: {
    type: Boolean,
    default: void 0
  },
  /** Close text to show */
  closeText: vue_types_default.any,
  /** Content of Alert */
  message: vue_types_default.any,
  /** Additional content of Alert */
  description: vue_types_default.any,
  /** Trigger when animation ending of Alert */
  afterClose: Function,
  /** Whether to show icon */
  showIcon: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  banner: {
    type: Boolean,
    default: void 0
  },
  icon: vue_types_default.any,
  closeIcon: vue_types_default.any,
  onClose: Function
});
var Alert = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAlert",
  inheritAttrs: false,
  props: alertProps(),
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs,
      expose
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("alert", props2);
    const [wrapSSR, hashId] = style_default4(prefixCls);
    const closing = shallowRef(false);
    const closed = shallowRef(false);
    const alertNode = shallowRef();
    const handleClose = (e) => {
      e.preventDefault();
      const dom = alertNode.value;
      dom.style.height = `${dom.offsetHeight}px`;
      dom.style.height = `${dom.offsetHeight}px`;
      closing.value = true;
      emit("close", e);
    };
    const animationEnd = () => {
      var _a2;
      closing.value = false;
      closed.value = true;
      (_a2 = props2.afterClose) === null || _a2 === void 0 ? void 0 : _a2.call(props2);
    };
    const mergedType = computed(() => {
      const {
        type
      } = props2;
      if (type !== void 0) {
        return type;
      }
      return props2.banner ? "warning" : "info";
    });
    expose({
      animationEnd
    });
    const motionStyle = shallowRef({});
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const {
        banner,
        closeIcon: customCloseIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
      } = props2;
      let {
        closable,
        showIcon
      } = props2;
      const closeText = (_b = props2.closeText) !== null && _b !== void 0 ? _b : (_c = slots.closeText) === null || _c === void 0 ? void 0 : _c.call(slots);
      const description = (_d = props2.description) !== null && _d !== void 0 ? _d : (_e = slots.description) === null || _e === void 0 ? void 0 : _e.call(slots);
      const message = (_f = props2.message) !== null && _f !== void 0 ? _f : (_g = slots.message) === null || _g === void 0 ? void 0 : _g.call(slots);
      const icon = (_h = props2.icon) !== null && _h !== void 0 ? _h : (_j = slots.icon) === null || _j === void 0 ? void 0 : _j.call(slots);
      const action = (_k = slots.action) === null || _k === void 0 ? void 0 : _k.call(slots);
      showIcon = banner && showIcon === void 0 ? true : showIcon;
      const IconType = (description ? iconMapOutlined : iconMapFilled)[mergedType.value] || null;
      if (closeText) {
        closable = true;
      }
      const prefixClsValue = prefixCls.value;
      const alertCls = classNames_default(prefixClsValue, {
        [`${prefixClsValue}-${mergedType.value}`]: true,
        [`${prefixClsValue}-closing`]: closing.value,
        [`${prefixClsValue}-with-description`]: !!description,
        [`${prefixClsValue}-no-icon`]: !showIcon,
        [`${prefixClsValue}-banner`]: !!banner,
        [`${prefixClsValue}-closable`]: closable,
        [`${prefixClsValue}-rtl`]: direction.value === "rtl",
        [hashId.value]: true
      });
      const closeIcon = closable ? createVNode("button", {
        "type": "button",
        "onClick": handleClose,
        "class": `${prefixClsValue}-close-icon`,
        "tabindex": 0
      }, [closeText ? createVNode("span", {
        "class": `${prefixClsValue}-close-text`
      }, [closeText]) : customCloseIcon === void 0 ? createVNode(CloseOutlined_default, null, null) : customCloseIcon]) : null;
      const iconNode = icon && (isValidElement(icon) ? cloneElement(icon, {
        class: `${prefixClsValue}-icon`
      }) : createVNode("span", {
        "class": `${prefixClsValue}-icon`
      }, [icon])) || createVNode(IconType, {
        "class": `${prefixClsValue}-icon`
      }, null);
      const transitionProps = getTransitionProps(`${prefixClsValue}-motion`, {
        appear: false,
        css: true,
        onAfterLeave: animationEnd,
        onBeforeLeave: (node) => {
          node.style.maxHeight = `${node.offsetHeight}px`;
        },
        onLeave: (node) => {
          node.style.maxHeight = "0px";
        }
      });
      return wrapSSR(closed.value ? null : createVNode(Transition, transitionProps, {
        default: () => [withDirectives(createVNode("div", _objectSpread2(_objectSpread2({
          "role": "alert"
        }, attrs), {}, {
          "style": [attrs.style, motionStyle.value],
          "class": [attrs.class, alertCls],
          "data-show": !closing.value,
          "ref": alertNode
        }), [showIcon ? iconNode : null, createVNode("div", {
          "class": `${prefixClsValue}-content`
        }, [message ? createVNode("div", {
          "class": `${prefixClsValue}-message`
        }, [message]) : null, description ? createVNode("div", {
          "class": `${prefixClsValue}-description`
        }, [description]) : null]), action ? createVNode("div", {
          "class": `${prefixClsValue}-action`
        }, [action]) : null, closeIcon]), [[vShow, !closing.value]])]
      }));
    };
  }
});
var alert_default = withInstall(Alert);

// node_modules/ant-design-vue/es/avatar/style/index.js
var genBaseStyle2 = (token) => {
  const {
    antCls,
    componentCls,
    iconCls,
    avatarBg,
    avatarColor,
    containerSize,
    containerSizeLG,
    containerSizeSM,
    textFontSize,
    textFontSizeLG,
    textFontSizeSM,
    borderRadius,
    borderRadiusLG,
    borderRadiusSM,
    lineWidth,
    lineType
  } = token;
  const avatarSizeStyle = (size, fontSize, radius) => ({
    width: size,
    height: size,
    lineHeight: `${size - lineWidth * 2}px`,
    borderRadius: "50%",
    [`&${componentCls}-square`]: {
      borderRadius: radius
    },
    [`${componentCls}-string`]: {
      position: "absolute",
      left: {
        _skip_check_: true,
        value: "50%"
      },
      transformOrigin: "0 center"
    },
    [`&${componentCls}-icon`]: {
      fontSize,
      [`> ${iconCls}`]: {
        margin: 0
      }
    }
  });
  return {
    [componentCls]: _extends(_extends(_extends(_extends({}, resetComponent(token)), {
      position: "relative",
      display: "inline-block",
      overflow: "hidden",
      color: avatarColor,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: avatarBg,
      border: `${lineWidth}px ${lineType} transparent`,
      [`&-image`]: {
        background: "transparent"
      },
      [`${antCls}-image-img`]: {
        display: "block"
      }
    }), avatarSizeStyle(containerSize, textFontSize, borderRadius)), {
      [`&-lg`]: _extends({}, avatarSizeStyle(containerSizeLG, textFontSizeLG, borderRadiusLG)),
      [`&-sm`]: _extends({}, avatarSizeStyle(containerSizeSM, textFontSizeSM, borderRadiusSM)),
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    })
  };
};
var genGroupStyle = (token) => {
  const {
    componentCls,
    groupBorderColor,
    groupOverlapping,
    groupSpace
  } = token;
  return {
    [`${componentCls}-group`]: {
      display: "inline-flex",
      [`${componentCls}`]: {
        borderColor: groupBorderColor
      },
      [`> *:not(:first-child)`]: {
        marginInlineStart: groupOverlapping
      }
    },
    [`${componentCls}-group-popover`]: {
      [`${componentCls} + ${componentCls}`]: {
        marginInlineStart: groupSpace
      }
    }
  };
};
var style_default5 = genComponentStyleHook("Avatar", (token) => {
  const {
    colorTextLightSolid,
    colorTextPlaceholder
  } = token;
  const avatarToken = merge(token, {
    avatarBg: colorTextPlaceholder,
    avatarColor: colorTextLightSolid
  });
  return [genBaseStyle2(avatarToken), genGroupStyle(avatarToken)];
}, (token) => {
  const {
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    fontSize,
    fontSizeLG,
    fontSizeXL,
    fontSizeHeading3,
    marginXS,
    marginXXS,
    colorBorderBg
  } = token;
  return {
    containerSize: controlHeight,
    containerSizeLG: controlHeightLG,
    containerSizeSM: controlHeightSM,
    textFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
    textFontSizeLG: fontSizeHeading3,
    textFontSizeSM: fontSize,
    groupSpace: marginXXS,
    groupOverlapping: -marginXS,
    groupBorderColor: colorBorderBg
  };
});

// node_modules/ant-design-vue/es/avatar/AvatarContext.js
var AvatarContextKey = Symbol("AvatarContextKey");
var useAvatarInjectContext = () => {
  return inject(AvatarContextKey, {});
};
var useAvatarProviderContext = (context2) => {
  return provide(AvatarContextKey, context2);
};

// node_modules/ant-design-vue/es/avatar/Avatar.js
var avatarProps = () => ({
  prefixCls: String,
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: [Number, String, Object],
    default: () => "default"
  },
  src: String,
  /** Srcset of image avatar */
  srcset: String,
  icon: vue_types_default.any,
  alt: String,
  gap: Number,
  draggable: {
    type: Boolean,
    default: void 0
  },
  crossOrigin: String,
  loadError: {
    type: Function
  }
});
var Avatar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatar",
  inheritAttrs: false,
  props: avatarProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const isImgExist = shallowRef(true);
    const isMounted = shallowRef(false);
    const scale = shallowRef(1);
    const avatarChildrenRef = shallowRef(null);
    const avatarNodeRef = shallowRef(null);
    const {
      prefixCls
    } = useConfigInject_default("avatar", props2);
    const [wrapSSR, hashId] = style_default5(prefixCls);
    const avatarCtx = useAvatarInjectContext();
    const size = computed(() => {
      return props2.size === "default" ? avatarCtx.size : props2.size;
    });
    const screens = useBreakpoint_default();
    const responsiveSize = eagerComputed(() => {
      if (typeof props2.size !== "object") {
        return void 0;
      }
      const currentBreakpoint = responsiveArray.find((screen) => screens.value[screen]);
      const currentSize = props2.size[currentBreakpoint];
      return currentSize;
    });
    const responsiveSizeStyle = (hasIcon) => {
      if (responsiveSize.value) {
        return {
          width: `${responsiveSize.value}px`,
          height: `${responsiveSize.value}px`,
          lineHeight: `${responsiveSize.value}px`,
          fontSize: `${hasIcon ? responsiveSize.value / 2 : 18}px`
        };
      }
      return {};
    };
    const setScaleParam = () => {
      if (!avatarChildrenRef.value || !avatarNodeRef.value) {
        return;
      }
      const childrenWidth = avatarChildrenRef.value.offsetWidth;
      const nodeWidth = avatarNodeRef.value.offsetWidth;
      if (childrenWidth !== 0 && nodeWidth !== 0) {
        const {
          gap = 4
        } = props2;
        if (gap * 2 < nodeWidth) {
          scale.value = nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1;
        }
      }
    };
    const handleImgLoadError = () => {
      const {
        loadError
      } = props2;
      const errorFlag = loadError === null || loadError === void 0 ? void 0 : loadError();
      if (errorFlag !== false) {
        isImgExist.value = false;
      }
    };
    watch(() => props2.src, () => {
      nextTick(() => {
        isImgExist.value = true;
        scale.value = 1;
      });
    });
    watch(() => props2.gap, () => {
      nextTick(() => {
        setScaleParam();
      });
    });
    onMounted(() => {
      nextTick(() => {
        setScaleParam();
        isMounted.value = true;
      });
    });
    return () => {
      var _a2, _b;
      const {
        shape,
        src,
        alt,
        srcset,
        draggable,
        crossOrigin
      } = props2;
      const mergeShape = (_a2 = avatarCtx.shape) !== null && _a2 !== void 0 ? _a2 : shape;
      const icon = getPropsSlot(slots, props2, "icon");
      const pre = prefixCls.value;
      const classString = {
        [`${attrs.class}`]: !!attrs.class,
        [pre]: true,
        [`${pre}-lg`]: size.value === "large",
        [`${pre}-sm`]: size.value === "small",
        [`${pre}-${mergeShape}`]: true,
        [`${pre}-image`]: src && isImgExist.value,
        [`${pre}-icon`]: icon,
        [hashId.value]: true
      };
      const sizeStyle = typeof size.value === "number" ? {
        width: `${size.value}px`,
        height: `${size.value}px`,
        lineHeight: `${size.value}px`,
        fontSize: icon ? `${size.value / 2}px` : "18px"
      } : {};
      const children = (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots);
      let childrenToRender;
      if (src && isImgExist.value) {
        childrenToRender = createVNode("img", {
          "draggable": draggable,
          "src": src,
          "srcset": srcset,
          "onError": handleImgLoadError,
          "alt": alt,
          "crossorigin": crossOrigin
        }, null);
      } else if (icon) {
        childrenToRender = icon;
      } else if (isMounted.value || scale.value !== 1) {
        const transformString = `scale(${scale.value}) translateX(-50%)`;
        const childrenStyle = {
          msTransform: transformString,
          WebkitTransform: transformString,
          transform: transformString
        };
        const sizeChildrenStyle = typeof size.value === "number" ? {
          lineHeight: `${size.value}px`
        } : {};
        childrenToRender = createVNode(vc_resize_observer_default, {
          "onResize": setScaleParam
        }, {
          default: () => [createVNode("span", {
            "class": `${pre}-string`,
            "ref": avatarChildrenRef,
            "style": _extends(_extends({}, sizeChildrenStyle), childrenStyle)
          }, [children])]
        });
      } else {
        childrenToRender = createVNode("span", {
          "class": `${pre}-string`,
          "ref": avatarChildrenRef,
          "style": {
            opacity: 0
          }
        }, [children]);
      }
      return wrapSSR(createVNode("span", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "ref": avatarNodeRef,
        "class": classString,
        "style": [sizeStyle, responsiveSizeStyle(!!icon), attrs.style]
      }), [childrenToRender]));
    };
  }
});
var Avatar_default = Avatar;

// node_modules/ant-design-vue/es/avatar/Group.js
var groupProps = () => ({
  prefixCls: String,
  maxCount: Number,
  maxStyle: {
    type: Object,
    default: void 0
  },
  maxPopoverPlacement: {
    type: String,
    default: "top"
  },
  maxPopoverTrigger: String,
  /*
   * Size of avatar, options: `large`, `small`, `default`
   * or a custom number size
   * */
  size: {
    type: [Number, String, Object],
    default: "default"
  },
  shape: {
    type: String,
    default: "circle"
  }
});
var Group = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatarGroup",
  inheritAttrs: false,
  props: groupProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("avatar", props2);
    const groupPrefixCls = computed(() => `${prefixCls.value}-group`);
    const [wrapSSR, hashId] = style_default5(prefixCls);
    watchEffect(() => {
      const context2 = {
        size: props2.size,
        shape: props2.shape
      };
      useAvatarProviderContext(context2);
    });
    return () => {
      const {
        maxPopoverPlacement = "top",
        maxCount,
        maxStyle,
        maxPopoverTrigger = "hover",
        shape
      } = props2;
      const cls = {
        [groupPrefixCls.value]: true,
        [`${groupPrefixCls.value}-rtl`]: direction.value === "rtl",
        [`${attrs.class}`]: !!attrs.class,
        [hashId.value]: true
      };
      const children = getPropsSlot(slots, props2);
      const childrenWithProps = flattenChildren(children).map((child, index2) => cloneElement(child, {
        key: `avatar-key-${index2}`
      }));
      const numOfChildren = childrenWithProps.length;
      if (maxCount && maxCount < numOfChildren) {
        const childrenShow = childrenWithProps.slice(0, maxCount);
        const childrenHidden = childrenWithProps.slice(maxCount, numOfChildren);
        childrenShow.push(createVNode(popover_default, {
          "key": "avatar-popover-key",
          "content": childrenHidden,
          "trigger": maxPopoverTrigger,
          "placement": maxPopoverPlacement,
          "overlayClassName": `${groupPrefixCls.value}-popover`
        }, {
          default: () => [createVNode(Avatar_default, {
            "style": maxStyle,
            "shape": shape
          }, {
            default: () => [`+${numOfChildren - maxCount}`]
          })]
        }));
        return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
          "class": cls,
          "style": attrs.style
        }), [childrenShow]));
      }
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": cls,
        "style": attrs.style
      }), [childrenWithProps]));
    };
  }
});
var Group_default4 = Group;

// node_modules/ant-design-vue/es/avatar/index.js
Avatar_default.Group = Group_default4;
Avatar_default.install = function(app) {
  app.component(Avatar_default.name, Avatar_default);
  app.component(Group_default4.name, Group_default4);
  return app;
};
var avatar_default = Avatar_default;

// node_modules/ant-design-vue/es/badge/SingleNumber.js
function UnitNumber(_ref) {
  let {
    prefixCls,
    value,
    current,
    offset = 0
  } = _ref;
  let style;
  if (offset) {
    style = {
      position: "absolute",
      top: `${offset}00%`,
      left: 0
    };
  }
  return createVNode("p", {
    "style": style,
    "class": classNames_default(`${prefixCls}-only-unit`, {
      current
    })
  }, [value]);
}
function getOffset2(start, end, unit) {
  let index2 = start;
  let offset = 0;
  while ((index2 + 10) % 10 !== end) {
    index2 += unit;
    offset += unit;
  }
  return offset;
}
var SingleNumber_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SingleNumber",
  props: {
    prefixCls: String,
    value: String,
    count: Number
  },
  setup(props2) {
    const originValue = computed(() => Number(props2.value));
    const originCount = computed(() => Math.abs(props2.count));
    const state = reactive({
      prevValue: originValue.value,
      prevCount: originCount.value
    });
    const onTransitionEnd = () => {
      state.prevValue = originValue.value;
      state.prevCount = originCount.value;
    };
    const timeout = ref();
    watch(originValue, () => {
      clearTimeout(timeout.value);
      timeout.value = setTimeout(() => {
        onTransitionEnd();
      }, 1e3);
    }, {
      flush: "post"
    });
    onUnmounted(() => {
      clearTimeout(timeout.value);
    });
    return () => {
      let unitNodes;
      let offsetStyle = {};
      const value = originValue.value;
      if (state.prevValue === value || Number.isNaN(value) || Number.isNaN(state.prevValue)) {
        unitNodes = [UnitNumber(_extends(_extends({}, props2), {
          current: true
        }))];
        offsetStyle = {
          transition: "none"
        };
      } else {
        unitNodes = [];
        const end = value + 10;
        const unitNumberList = [];
        for (let index2 = value; index2 <= end; index2 += 1) {
          unitNumberList.push(index2);
        }
        const prevIndex = unitNumberList.findIndex((n) => n % 10 === state.prevValue);
        unitNodes = unitNumberList.map((n, index2) => {
          const singleUnit = n % 10;
          return UnitNumber(_extends(_extends({}, props2), {
            value: singleUnit,
            offset: index2 - prevIndex,
            current: index2 === prevIndex
          }));
        });
        const unit = state.prevCount < originCount.value ? 1 : -1;
        offsetStyle = {
          transform: `translateY(${-getOffset2(state.prevValue, value, unit)}00%)`
        };
      }
      return createVNode("span", {
        "class": `${props2.prefixCls}-only`,
        "style": offsetStyle,
        "onTransitionend": () => onTransitionEnd()
      }, [unitNodes]);
    };
  }
});

// node_modules/ant-design-vue/es/badge/ScrollNumber.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var scrollNumberProps = {
  prefixCls: String,
  count: vue_types_default.any,
  component: String,
  title: vue_types_default.any,
  show: Boolean
};
var ScrollNumber_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollNumber",
  inheritAttrs: false,
  props: scrollNumberProps,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("scroll-number", props2);
    return () => {
      var _a2;
      const _b = _extends(_extends({}, props2), attrs), {
        prefixCls: customizePrefixCls,
        count,
        title,
        show,
        component: Tag = "sup",
        class: className,
        style
      } = _b, restProps = __rest(_b, ["prefixCls", "count", "title", "show", "component", "class", "style"]);
      const newProps = _extends(_extends({}, restProps), {
        style,
        "data-show": props2.show,
        class: classNames_default(prefixCls.value, className),
        title
      });
      let numberNodes = count;
      if (count && Number(count) % 1 === 0) {
        const numberList = String(count).split("");
        numberNodes = numberList.map((num, i) => createVNode(SingleNumber_default, {
          "prefixCls": prefixCls.value,
          "count": Number(count),
          "value": num,
          "key": numberList.length - i
        }, null));
      }
      if (style && style.borderColor) {
        newProps.style = _extends(_extends({}, style), {
          boxShadow: `0 0 0 1px ${style.borderColor} inset`
        });
      }
      const children = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      if (children && children.length) {
        return cloneElement(children, {
          class: classNames_default(`${prefixCls.value}-custom-component`)
        }, false);
      }
      return createVNode(Tag, newProps, {
        default: () => [numberNodes]
      });
    };
  }
});

// node_modules/ant-design-vue/es/badge/style/index.js
var antStatusProcessing = new Keyframes_default("antStatusProcessing", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(2.4)",
    opacity: 0
  }
});
var antZoomBadgeIn = new Keyframes_default("antZoomBadgeIn", {
  "0%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1) translate(50%, -50%)"
  }
});
var antZoomBadgeOut = new Keyframes_default("antZoomBadgeOut", {
  "0%": {
    transform: "scale(1) translate(50%, -50%)"
  },
  "100%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  }
});
var antNoWrapperZoomBadgeIn = new Keyframes_default("antNoWrapperZoomBadgeIn", {
  "0%": {
    transform: "scale(0)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)"
  }
});
var antNoWrapperZoomBadgeOut = new Keyframes_default("antNoWrapperZoomBadgeOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0)",
    opacity: 0
  }
});
var antBadgeLoadingCircle = new Keyframes_default("antBadgeLoadingCircle", {
  "0%": {
    transformOrigin: "50%"
  },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
});
var genSharedBadgeStyle = (token) => {
  const {
    componentCls,
    iconCls,
    antCls,
    badgeFontHeight,
    badgeShadowSize,
    badgeHeightSm,
    motionDurationSlow,
    badgeStatusSize,
    marginXS,
    badgeRibbonOffset
  } = token;
  const numberPrefixCls = `${antCls}-scroll-number`;
  const ribbonPrefixCls = `${antCls}-ribbon`;
  const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
  const colorPreset = genPresetColor(token, (colorKey, _ref) => {
    let {
      darkColor
    } = _ref;
    return {
      [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
        background: darkColor,
        [`&:not(${componentCls}-count)`]: {
          color: darkColor
        }
      }
    };
  });
  const statusRibbonPreset = genPresetColor(token, (colorKey, _ref2) => {
    let {
      darkColor
    } = _ref2;
    return {
      [`&${ribbonPrefixCls}-color-${colorKey}`]: {
        background: darkColor,
        color: darkColor
      }
    };
  });
  return {
    [componentCls]: _extends(_extends(_extends(_extends({}, resetComponent(token)), {
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${componentCls}-count`]: {
        zIndex: token.badgeZIndex,
        minWidth: token.badgeHeight,
        height: token.badgeHeight,
        color: token.badgeTextColor,
        fontWeight: token.badgeFontWeight,
        fontSize: token.badgeFontSize,
        lineHeight: `${token.badgeHeight}px`,
        whiteSpace: "nowrap",
        textAlign: "center",
        background: token.badgeColor,
        borderRadius: token.badgeHeight / 2,
        boxShadow: `0 0 0 ${badgeShadowSize}px ${token.badgeShadowColor}`,
        transition: `background ${token.motionDurationMid}`,
        a: {
          color: token.badgeTextColor
        },
        "a:hover": {
          color: token.badgeTextColor
        },
        "a:hover &": {
          background: token.badgeColorHover
        }
      },
      [`${componentCls}-count-sm`]: {
        minWidth: badgeHeightSm,
        height: badgeHeightSm,
        fontSize: token.badgeFontSizeSm,
        lineHeight: `${badgeHeightSm}px`,
        borderRadius: badgeHeightSm / 2
      },
      [`${componentCls}-multiple-words`]: {
        padding: `0 ${token.paddingXS}px`
      },
      [`${componentCls}-dot`]: {
        zIndex: token.badgeZIndex,
        width: token.badgeDotSize,
        minWidth: token.badgeDotSize,
        height: token.badgeDotSize,
        background: token.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${badgeShadowSize}px ${token.badgeShadowColor}`
      },
      [`${componentCls}-dot${numberPrefixCls}`]: {
        transition: `background ${motionDurationSlow}`
      },
      [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${iconCls}-spin`]: {
          animationName: antBadgeLoadingCircle,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${componentCls}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${componentCls}-status-dot`]: {
          position: "relative",
          top: -1,
          display: "inline-block",
          width: badgeStatusSize,
          height: badgeStatusSize,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${componentCls}-status-success`]: {
          backgroundColor: token.colorSuccess
        },
        [`${componentCls}-status-processing`]: {
          overflow: "visible",
          color: token.colorPrimary,
          backgroundColor: token.colorPrimary,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: badgeShadowSize,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: antStatusProcessing,
            animationDuration: token.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${componentCls}-status-default`]: {
          backgroundColor: token.colorTextPlaceholder
        },
        [`${componentCls}-status-error`]: {
          backgroundColor: token.colorError
        },
        [`${componentCls}-status-warning`]: {
          backgroundColor: token.colorWarning
        },
        [`${componentCls}-status-text`]: {
          marginInlineStart: marginXS,
          color: token.colorText,
          fontSize: token.fontSize
        }
      }
    }), colorPreset), {
      [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
        animationName: antZoomBadgeIn,
        animationDuration: token.motionDurationSlow,
        animationTimingFunction: token.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${componentCls}-zoom-leave`]: {
        animationName: antZoomBadgeOut,
        animationDuration: token.motionDurationSlow,
        animationTimingFunction: token.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${componentCls}-not-a-wrapper`]: {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antNoWrapperZoomBadgeIn,
          animationDuration: token.motionDurationSlow,
          animationTimingFunction: token.motionEaseOutBack
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antNoWrapperZoomBadgeOut,
          animationDuration: token.motionDurationSlow,
          animationTimingFunction: token.motionEaseOutBack
        },
        [`&:not(${componentCls}-status)`]: {
          verticalAlign: "middle"
        },
        [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
          transform: "none"
        },
        [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [`${numberPrefixCls}`]: {
        overflow: "hidden",
        [`${numberPrefixCls}-only`]: {
          position: "relative",
          display: "inline-block",
          height: token.badgeHeight,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${numberPrefixCls}-only-unit`]: {
            height: token.badgeHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${numberPrefixCls}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    }),
    [`${ribbonWrapperPrefixCls}`]: {
      position: "relative"
    },
    [`${ribbonPrefixCls}`]: _extends(_extends(_extends(_extends({}, resetComponent(token)), {
      position: "absolute",
      top: marginXS,
      padding: `0 ${token.paddingXS}px`,
      color: token.colorPrimary,
      lineHeight: `${badgeFontHeight}px`,
      whiteSpace: "nowrap",
      backgroundColor: token.colorPrimary,
      borderRadius: token.borderRadiusSM,
      [`${ribbonPrefixCls}-text`]: {
        color: token.colorTextLightSolid
      },
      [`${ribbonPrefixCls}-corner`]: {
        position: "absolute",
        top: "100%",
        width: badgeRibbonOffset,
        height: badgeRibbonOffset,
        color: "currentcolor",
        border: `${badgeRibbonOffset / 2}px solid`,
        transform: token.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: token.badgeRibbonCornerFilter
      }
    }), statusRibbonPreset), {
      [`&${ribbonPrefixCls}-placement-end`]: {
        insetInlineEnd: -badgeRibbonOffset,
        borderEndEndRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${ribbonPrefixCls}-placement-start`]: {
        insetInlineStart: -badgeRibbonOffset,
        borderEndStartRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
};
var style_default6 = genComponentStyleHook("Badge", (token) => {
  const {
    fontSize,
    lineHeight,
    fontSizeSM,
    lineWidth,
    marginXS,
    colorBorderBg
  } = token;
  const badgeFontHeight = Math.round(fontSize * lineHeight);
  const badgeShadowSize = lineWidth;
  const badgeZIndex = "auto";
  const badgeHeight = badgeFontHeight - 2 * badgeShadowSize;
  const badgeTextColor = token.colorBgContainer;
  const badgeFontWeight = "normal";
  const badgeFontSize = fontSizeSM;
  const badgeColor = token.colorError;
  const badgeColorHover = token.colorErrorHover;
  const badgeHeightSm = fontSize;
  const badgeDotSize = fontSizeSM / 2;
  const badgeFontSizeSm = fontSizeSM;
  const badgeStatusSize = fontSizeSM / 2;
  const badgeToken = merge(token, {
    badgeFontHeight,
    badgeShadowSize,
    badgeZIndex,
    badgeHeight,
    badgeTextColor,
    badgeFontWeight,
    badgeFontSize,
    badgeColor,
    badgeColorHover,
    badgeShadowColor: colorBorderBg,
    badgeHeightSm,
    badgeDotSize,
    badgeFontSizeSm,
    badgeStatusSize,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: marginXS,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: `brightness(75%)`
  });
  return [genSharedBadgeStyle(badgeToken)];
});

// node_modules/ant-design-vue/es/badge/Ribbon.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ribbonProps = () => ({
  prefix: String,
  color: {
    type: String
  },
  text: vue_types_default.any,
  placement: {
    type: String,
    default: "end"
  }
});
var Ribbon_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABadgeRibbon",
  inheritAttrs: false,
  props: ribbonProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("ribbon", props2);
    const [wrapSSR, hashId] = style_default6(prefixCls);
    const colorInPreset = computed(() => isPresetColor(props2.color, false));
    const ribbonCls = computed(() => [prefixCls.value, `${prefixCls.value}-placement-${props2.placement}`, {
      [`${prefixCls.value}-rtl`]: direction.value === "rtl",
      [`${prefixCls.value}-color-${props2.color}`]: colorInPreset.value
    }]);
    return () => {
      var _a2, _b;
      const {
        class: className,
        style
      } = attrs, restAttrs = __rest2(attrs, ["class", "style"]);
      const colorStyle = {};
      const cornerColorStyle = {};
      if (props2.color && !colorInPreset.value) {
        colorStyle.background = props2.color;
        cornerColorStyle.color = props2.color;
      }
      return wrapSSR(createVNode("div", _objectSpread2({
        "class": `${prefixCls.value}-wrapper ${hashId.value}`
      }, restAttrs), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots), createVNode("div", {
        "class": [ribbonCls.value, className, hashId.value],
        "style": _extends(_extends({}, colorStyle), style)
      }, [createVNode("span", {
        "class": `${prefixCls.value}-text`
      }, [props2.text || ((_b = slots.text) === null || _b === void 0 ? void 0 : _b.call(slots))]), createVNode("div", {
        "class": `${prefixCls.value}-corner`,
        "style": cornerColorStyle
      }, null)])]));
    };
  }
});

// node_modules/ant-design-vue/es/_util/isNumeric.js
var isNumeric = (value) => {
  return !isNaN(parseFloat(value)) && isFinite(value);
};
var isNumeric_default = isNumeric;

// node_modules/ant-design-vue/es/badge/Badge.js
var badgeProps = () => ({
  /** Number to show in badge */
  count: vue_types_default.any.def(null),
  showZero: {
    type: Boolean,
    default: void 0
  },
  /** Max count to show */
  overflowCount: {
    type: Number,
    default: 99
  },
  /** whether to show red dot without number */
  dot: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  scrollNumberPrefixCls: String,
  status: {
    type: String
  },
  size: {
    type: String,
    default: "default"
  },
  color: String,
  text: vue_types_default.any,
  offset: Array,
  numberStyle: {
    type: Object,
    default: void 0
  },
  title: String
});
var Badge_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABadge",
  Ribbon: Ribbon_default,
  inheritAttrs: false,
  props: badgeProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("badge", props2);
    const [wrapSSR, hashId] = style_default6(prefixCls);
    const numberedDisplayCount = computed(() => {
      return props2.count > props2.overflowCount ? `${props2.overflowCount}+` : props2.count;
    });
    const isZero = computed(() => numberedDisplayCount.value === "0" || numberedDisplayCount.value === 0);
    const ignoreCount = computed(() => props2.count === null || isZero.value && !props2.showZero);
    const hasStatus = computed(() => (props2.status !== null && props2.status !== void 0 || props2.color !== null && props2.color !== void 0) && ignoreCount.value);
    const showAsDot = computed(() => props2.dot && !isZero.value);
    const mergedCount = computed(() => showAsDot.value ? "" : numberedDisplayCount.value);
    const isHidden = computed(() => {
      const isEmpty2 = mergedCount.value === null || mergedCount.value === void 0 || mergedCount.value === "";
      return (isEmpty2 || isZero.value && !props2.showZero) && !showAsDot.value;
    });
    const livingCount = ref(props2.count);
    const displayCount = ref(mergedCount.value);
    const isDotRef = ref(showAsDot.value);
    watch([() => props2.count, mergedCount, showAsDot], () => {
      if (!isHidden.value) {
        livingCount.value = props2.count;
        displayCount.value = mergedCount.value;
        isDotRef.value = showAsDot.value;
      }
    }, {
      immediate: true
    });
    const isInternalColor = computed(() => isPresetColor(props2.color, false));
    const statusCls = computed(() => ({
      [`${prefixCls.value}-status-dot`]: hasStatus.value,
      [`${prefixCls.value}-status-${props2.status}`]: !!props2.status,
      [`${prefixCls.value}-color-${props2.color}`]: isInternalColor.value
    }));
    const statusStyle = computed(() => {
      if (props2.color && !isInternalColor.value) {
        return {
          background: props2.color,
          color: props2.color
        };
      } else {
        return {};
      }
    });
    const scrollNumberCls = computed(() => ({
      [`${prefixCls.value}-dot`]: isDotRef.value,
      [`${prefixCls.value}-count`]: !isDotRef.value,
      [`${prefixCls.value}-count-sm`]: props2.size === "small",
      [`${prefixCls.value}-multiple-words`]: !isDotRef.value && displayCount.value && displayCount.value.toString().length > 1,
      [`${prefixCls.value}-status-${props2.status}`]: !!props2.status,
      [`${prefixCls.value}-color-${props2.color}`]: isInternalColor.value
    }));
    return () => {
      var _a2, _b;
      const {
        offset,
        title,
        color
      } = props2;
      const style = attrs.style;
      const text = getPropsSlot(slots, props2, "text");
      const pre = prefixCls.value;
      const count = livingCount.value;
      let children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      children = children.length ? children : null;
      const visible = !!(!isHidden.value || slots.count);
      const mergedStyle = (() => {
        if (!offset) {
          return _extends({}, style);
        }
        const offsetStyle = {
          marginTop: isNumeric_default(offset[1]) ? `${offset[1]}px` : offset[1]
        };
        if (direction.value === "rtl") {
          offsetStyle.left = `${parseInt(offset[0], 10)}px`;
        } else {
          offsetStyle.right = `${-parseInt(offset[0], 10)}px`;
        }
        return _extends(_extends({}, offsetStyle), style);
      })();
      const titleNode = title !== null && title !== void 0 ? title : typeof count === "string" || typeof count === "number" ? count : void 0;
      const statusTextNode = visible || !text ? null : createVNode("span", {
        "class": `${pre}-status-text`
      }, [text]);
      const displayNode = typeof count === "object" || count === void 0 && slots.count ? cloneElement(count !== null && count !== void 0 ? count : (_b = slots.count) === null || _b === void 0 ? void 0 : _b.call(slots), {
        style: mergedStyle
      }, false) : null;
      const badgeClassName = classNames_default(pre, {
        [`${pre}-status`]: hasStatus.value,
        [`${pre}-not-a-wrapper`]: !children,
        [`${pre}-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value);
      if (!children && hasStatus.value) {
        const statusTextColor = mergedStyle.color;
        return wrapSSR(createVNode("span", _objectSpread2(_objectSpread2({}, attrs), {}, {
          "class": badgeClassName,
          "style": mergedStyle
        }), [createVNode("span", {
          "class": statusCls.value,
          "style": statusStyle.value
        }, null), createVNode("span", {
          "style": {
            color: statusTextColor
          },
          "class": `${pre}-status-text`
        }, [text])]));
      }
      const transitionProps = getTransitionProps(children ? `${pre}-zoom` : "", {
        appear: false
      });
      let scrollNumberStyle = _extends(_extends({}, mergedStyle), props2.numberStyle);
      if (color && !isInternalColor.value) {
        scrollNumberStyle = scrollNumberStyle || {};
        scrollNumberStyle.background = color;
      }
      return wrapSSR(createVNode("span", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": badgeClassName
      }), [children, createVNode(Transition, transitionProps, {
        default: () => [withDirectives(createVNode(ScrollNumber_default, {
          "prefixCls": props2.scrollNumberPrefixCls,
          "show": visible,
          "class": scrollNumberCls.value,
          "count": displayCount.value,
          "title": titleNode,
          "style": scrollNumberStyle,
          "key": "scrollNumber"
        }, {
          default: () => [displayNode]
        }), [[vShow, visible]])]
      }), statusTextNode]));
    };
  }
});

// node_modules/ant-design-vue/es/badge/index.js
Badge_default.install = function(app) {
  app.component(Badge_default.name, Badge_default);
  app.component(Ribbon_default.name, Ribbon_default);
  return app;
};
var badge_default = Badge_default;

// node_modules/ant-design-vue/es/breadcrumb/BreadcrumbItem.js
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var breadcrumbItemProps = () => ({
  prefixCls: String,
  href: String,
  separator: vue_types_default.any,
  dropdownProps: objectType(),
  overlay: vue_types_default.any,
  onClick: eventType()
});
var BreadcrumbItem_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbItem",
  inheritAttrs: false,
  __ANT_BREADCRUMB_ITEM: true,
  props: breadcrumbItemProps(),
  // emits: ['click'],
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("breadcrumb", props2);
    const renderBreadcrumbNode = (breadcrumbItem, prefixCls2) => {
      const overlay = getPropsSlot(slots, props2, "overlay");
      if (overlay) {
        return createVNode(dropdown_default, _objectSpread2(_objectSpread2({}, props2.dropdownProps), {}, {
          "overlay": overlay,
          "placement": "bottom"
        }), {
          default: () => [createVNode("span", {
            "class": `${prefixCls2}-overlay-link`
          }, [breadcrumbItem, createVNode(DownOutlined_default, null, null)])]
        });
      }
      return breadcrumbItem;
    };
    const handleClick = (e) => {
      emit("click", e);
    };
    return () => {
      var _a2;
      const separator = (_a2 = getPropsSlot(slots, props2, "separator")) !== null && _a2 !== void 0 ? _a2 : "/";
      const children = getPropsSlot(slots, props2);
      const {
        class: cls,
        style
      } = attrs, restAttrs = __rest3(attrs, ["class", "style"]);
      let link;
      if (props2.href !== void 0) {
        link = createVNode("a", _objectSpread2({
          "class": `${prefixCls.value}-link`,
          "onClick": handleClick
        }, restAttrs), [children]);
      } else {
        link = createVNode("span", _objectSpread2({
          "class": `${prefixCls.value}-link`,
          "onClick": handleClick
        }, restAttrs), [children]);
      }
      link = renderBreadcrumbNode(link, prefixCls.value);
      if (children !== void 0 && children !== null) {
        return createVNode("li", {
          "class": cls,
          "style": style
        }, [link, separator && createVNode("span", {
          "class": `${prefixCls.value}-separator`
        }, [separator])]);
      }
      return null;
    };
  }
});

// node_modules/ant-design-vue/es/breadcrumb/style/index.js
var genBreadcrumbStyle = (token) => {
  const {
    componentCls,
    iconCls
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      color: token.breadcrumbBaseColor,
      fontSize: token.breadcrumbFontSize,
      [iconCls]: {
        fontSize: token.breadcrumbIconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      a: _extends({
        color: token.breadcrumbLinkColor,
        transition: `color ${token.motionDurationMid}`,
        padding: `0 ${token.paddingXXS}px`,
        borderRadius: token.borderRadiusSM,
        height: token.lineHeight * token.fontSize,
        display: "inline-block",
        marginInline: -token.marginXXS,
        "&:hover": {
          color: token.breadcrumbLinkColorHover,
          backgroundColor: token.colorBgTextHover
        }
      }, genFocusStyle(token)),
      [`li:last-child`]: {
        color: token.breadcrumbLastItemColor,
        [`& > ${componentCls}-separator`]: {
          display: "none"
        }
      },
      [`${componentCls}-separator`]: {
        marginInline: token.breadcrumbSeparatorMargin,
        color: token.breadcrumbSeparatorColor
      },
      [`${componentCls}-link`]: {
        [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
          marginInlineStart: token.marginXXS
        }
      },
      [`${componentCls}-overlay-link`]: {
        borderRadius: token.borderRadiusSM,
        height: token.lineHeight * token.fontSize,
        display: "inline-block",
        padding: `0 ${token.paddingXXS}px`,
        marginInline: -token.marginXXS,
        [`> ${iconCls}`]: {
          marginInlineStart: token.marginXXS,
          fontSize: token.fontSizeIcon
        },
        "&:hover": {
          color: token.breadcrumbLinkColorHover,
          backgroundColor: token.colorBgTextHover,
          a: {
            color: token.breadcrumbLinkColorHover
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      // rtl style
      [`&${token.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
};
var style_default7 = genComponentStyleHook("Breadcrumb", (token) => {
  const BreadcrumbToken = merge(token, {
    breadcrumbBaseColor: token.colorTextDescription,
    breadcrumbFontSize: token.fontSize,
    breadcrumbIconFontSize: token.fontSize,
    breadcrumbLinkColor: token.colorTextDescription,
    breadcrumbLinkColorHover: token.colorText,
    breadcrumbLastItemColor: token.colorText,
    breadcrumbSeparatorMargin: token.marginXS,
    breadcrumbSeparatorColor: token.colorTextDescription
  });
  return [genBreadcrumbStyle(BreadcrumbToken)];
});

// node_modules/ant-design-vue/es/breadcrumb/Breadcrumb.js
var breadcrumbProps = () => ({
  prefixCls: String,
  routes: {
    type: Array
  },
  params: vue_types_default.any,
  separator: vue_types_default.any,
  itemRender: {
    type: Function
  }
});
function getBreadcrumbName(route, params) {
  if (!route.breadcrumbName) {
    return null;
  }
  const paramsKeys = Object.keys(params).join("|");
  const name = route.breadcrumbName.replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
  return name;
}
function defaultItemRender(opt) {
  const {
    route,
    params,
    routes,
    paths
  } = opt;
  const isLastItem = routes.indexOf(route) === routes.length - 1;
  const name = getBreadcrumbName(route, params);
  return isLastItem ? createVNode("span", null, [name]) : createVNode("a", {
    "href": `#/${paths.join("/")}`
  }, [name]);
}
var Breadcrumb_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumb",
  inheritAttrs: false,
  props: breadcrumbProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("breadcrumb", props2);
    const [wrapSSR, hashId] = style_default7(prefixCls);
    const getPath = (path2, params) => {
      path2 = (path2 || "").replace(/^\//, "");
      Object.keys(params).forEach((key) => {
        path2 = path2.replace(`:${key}`, params[key]);
      });
      return path2;
    };
    const addChildPath = (paths, childPath, params) => {
      const originalPaths = [...paths];
      const path2 = getPath(childPath || "", params);
      if (path2) {
        originalPaths.push(path2);
      }
      return originalPaths;
    };
    const genForRoutes = (_ref2) => {
      let {
        routes = [],
        params = {},
        separator,
        itemRender = defaultItemRender
      } = _ref2;
      const paths = [];
      return routes.map((route) => {
        const path2 = getPath(route.path, params);
        if (path2) {
          paths.push(path2);
        }
        const tempPaths = [...paths];
        let overlay = null;
        if (route.children && route.children.length) {
          overlay = createVNode(menu_default, {
            "items": route.children.map((child) => ({
              key: child.path || child.breadcrumbName,
              label: itemRender({
                route: child,
                params,
                routes,
                paths: addChildPath(tempPaths, child.path, params)
              })
            }))
          }, null);
        }
        const itemProps = {
          separator
        };
        if (overlay) {
          itemProps.overlay = overlay;
        }
        return createVNode(BreadcrumbItem_default, _objectSpread2(_objectSpread2({}, itemProps), {}, {
          "key": path2 || route.breadcrumbName
        }), {
          default: () => [itemRender({
            route,
            params,
            routes,
            paths: tempPaths
          })]
        });
      });
    };
    return () => {
      var _a2;
      let crumbs;
      const {
        routes,
        params = {}
      } = props2;
      const children = flattenChildren(getPropsSlot(slots, props2));
      const separator = (_a2 = getPropsSlot(slots, props2, "separator")) !== null && _a2 !== void 0 ? _a2 : "/";
      const itemRender = props2.itemRender || slots.itemRender || defaultItemRender;
      if (routes && routes.length > 0) {
        crumbs = genForRoutes({
          routes,
          params,
          separator,
          itemRender
        });
      } else if (children.length) {
        crumbs = children.map((element, index2) => {
          warning_default2(typeof element.type === "object" && (element.type.__ANT_BREADCRUMB_ITEM || element.type.__ANT_BREADCRUMB_SEPARATOR), "Breadcrumb", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children");
          return cloneVNode(element, {
            separator,
            key: index2
          });
        });
      }
      const breadcrumbClassName = {
        [prefixCls.value]: true,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${attrs.class}`]: !!attrs.class,
        [hashId.value]: true
      };
      return wrapSSR(createVNode("nav", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": breadcrumbClassName
      }), [createVNode("ol", null, [crumbs])]));
    };
  }
});

// node_modules/ant-design-vue/es/breadcrumb/BreadcrumbSeparator.js
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var breadcrumbSeparatorProps = () => ({
  prefixCls: String
});
var BreadcrumbSeparator_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbSeparator",
  __ANT_BREADCRUMB_SEPARATOR: true,
  inheritAttrs: false,
  props: breadcrumbSeparatorProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("breadcrumb", props2);
    return () => {
      var _a2;
      const {
        separator,
        class: className
      } = attrs, restAttrs = __rest4(attrs, ["separator", "class"]);
      const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      return createVNode("span", _objectSpread2({
        "class": [`${prefixCls.value}-separator`, className]
      }, restAttrs), [children.length > 0 ? children : "/"]);
    };
  }
});

// node_modules/ant-design-vue/es/breadcrumb/index.js
Breadcrumb_default.Item = BreadcrumbItem_default;
Breadcrumb_default.Separator = BreadcrumbSeparator_default;
Breadcrumb_default.install = function(app) {
  app.component(Breadcrumb_default.name, Breadcrumb_default);
  app.component(BreadcrumbItem_default.name, BreadcrumbItem_default);
  app.component(BreadcrumbSeparator_default.name, BreadcrumbSeparator_default);
  return app;
};
var breadcrumb_default = Breadcrumb_default;

// node_modules/ant-design-vue/es/vc-picker/generate/dayjs.js
var import_dayjs = __toESM(require_dayjs_min());
var import_weekday = __toESM(require_weekday());
var import_localeData = __toESM(require_localeData());
var import_weekOfYear = __toESM(require_weekOfYear());
var import_weekYear = __toESM(require_weekYear());
var import_quarterOfYear = __toESM(require_quarterOfYear());
var import_advancedFormat = __toESM(require_advancedFormat());
var import_customParseFormat = __toESM(require_customParseFormat());
import_dayjs.default.extend(import_customParseFormat.default);
import_dayjs.default.extend(import_advancedFormat.default);
import_dayjs.default.extend(import_weekday.default);
import_dayjs.default.extend(import_localeData.default);
import_dayjs.default.extend(import_weekOfYear.default);
import_dayjs.default.extend(import_weekYear.default);
import_dayjs.default.extend(import_quarterOfYear.default);
import_dayjs.default.extend((_o, c) => {
  const proto = c.prototype;
  const oldFormat = proto.format;
  proto.format = function f(formatStr) {
    const str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  };
});
var localeMap = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
};
var parseLocale = (locale) => {
  const mapLocale = localeMap[locale];
  return mapLocale || locale.split("_")[0];
};
var parseNoMatchNotice = () => {
  noteOnce(false, "Not match any format. Please help to fire a issue about this.");
};
var advancedFormatRegex = /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|k{1,2}|S/g;
function findTargetStr(val, index2, segmentation) {
  const items = [...new Set(val.split(segmentation))];
  let idx = 0;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    idx += item.length;
    if (idx > index2) {
      return item;
    }
    idx += segmentation.length;
  }
}
var toDateWithValueFormat = (val, valueFormat) => {
  if (!val)
    return null;
  if (import_dayjs.default.isDayjs(val)) {
    return val;
  }
  const matchs = valueFormat.matchAll(advancedFormatRegex);
  let baseDate = (0, import_dayjs.default)(val, valueFormat);
  if (matchs === null) {
    return baseDate;
  }
  for (const match of matchs) {
    const origin = match[0];
    const index2 = match["index"];
    if (origin === "Q") {
      const segmentation = val.slice(index2 - 1, index2);
      const quarterStr = findTargetStr(val, index2, segmentation).match(/\d+/)[0];
      baseDate = baseDate.quarter(parseInt(quarterStr));
    }
    if (origin.toLowerCase() === "wo") {
      const segmentation = val.slice(index2 - 1, index2);
      const weekStr = findTargetStr(val, index2, segmentation).match(/\d+/)[0];
      baseDate = baseDate.week(parseInt(weekStr));
    }
    if (origin.toLowerCase() === "ww") {
      baseDate = baseDate.week(parseInt(val.slice(index2, index2 + origin.length)));
    }
    if (origin.toLowerCase() === "w") {
      baseDate = baseDate.week(parseInt(val.slice(index2, index2 + origin.length + 1)));
    }
  }
  return baseDate;
};
var generateConfig = {
  // get
  getNow: () => (0, import_dayjs.default)(),
  getFixedDate: (string) => (0, import_dayjs.default)(string, ["YYYY-M-DD", "YYYY-MM-DD"]),
  getEndDate: (date) => date.endOf("month"),
  getWeekDay: (date) => {
    const clone = date.locale("en");
    return clone.weekday() + clone.localeData().firstDayOfWeek();
  },
  getYear: (date) => date.year(),
  getMonth: (date) => date.month(),
  getDate: (date) => date.date(),
  getHour: (date) => date.hour(),
  getMinute: (date) => date.minute(),
  getSecond: (date) => date.second(),
  // set
  addYear: (date, diff) => date.add(diff, "year"),
  addMonth: (date, diff) => date.add(diff, "month"),
  addDate: (date, diff) => date.add(diff, "day"),
  setYear: (date, year) => date.year(year),
  setMonth: (date, month) => date.month(month),
  setDate: (date, num) => date.date(num),
  setHour: (date, hour) => date.hour(hour),
  setMinute: (date, minute) => date.minute(minute),
  setSecond: (date, second) => date.second(second),
  // Compare
  isAfter: (date1, date2) => date1.isAfter(date2),
  isValidate: (date) => date.isValid(),
  locale: {
    getWeekFirstDay: (locale) => (0, import_dayjs.default)().locale(parseLocale(locale)).localeData().firstDayOfWeek(),
    getWeekFirstDate: (locale, date) => date.locale(parseLocale(locale)).weekday(0),
    getWeek: (locale, date) => date.locale(parseLocale(locale)).week(),
    getShortWeekDays: (locale) => (0, import_dayjs.default)().locale(parseLocale(locale)).localeData().weekdaysMin(),
    getShortMonths: (locale) => (0, import_dayjs.default)().locale(parseLocale(locale)).localeData().monthsShort(),
    format: (locale, date, format2) => date.locale(parseLocale(locale)).format(format2),
    parse: (locale, text, formats) => {
      const localeStr = parseLocale(locale);
      for (let i = 0; i < formats.length; i += 1) {
        const format2 = formats[i];
        const formatText = text;
        if (format2.includes("wo") || format2.includes("Wo")) {
          const year = formatText.split("-")[0];
          const weekStr = formatText.split("-")[1];
          const firstWeek = (0, import_dayjs.default)(year, "YYYY").startOf("year").locale(localeStr);
          for (let j = 0; j <= 52; j += 1) {
            const nextWeek = firstWeek.add(j, "week");
            if (nextWeek.format("Wo") === weekStr) {
              return nextWeek;
            }
          }
          parseNoMatchNotice();
          return null;
        }
        const date = (0, import_dayjs.default)(formatText, format2, true).locale(localeStr);
        if (date.isValid()) {
          return date;
        }
      }
      if (!text) {
        parseNoMatchNotice();
      }
      return null;
    }
  },
  toDate: (value, valueFormat) => {
    if (Array.isArray(value)) {
      return value.map((val) => toDateWithValueFormat(val, valueFormat));
    } else {
      return toDateWithValueFormat(value, valueFormat);
    }
  },
  toString: (value, valueFormat) => {
    if (Array.isArray(value)) {
      return value.map((val) => import_dayjs.default.isDayjs(val) ? val.format(valueFormat) : val);
    } else {
      return import_dayjs.default.isDayjs(value) ? value.format(valueFormat) : value;
    }
  }
};
var dayjs_default = generateConfig;

// node_modules/ant-design-vue/es/vc-picker/hooks/useMergeProps.js
function useMergeProps(props2) {
  const attrs = useAttrs();
  return _extends(_extends({}, props2), attrs);
}

// node_modules/ant-design-vue/es/vc-picker/PanelContext.js
var PanelContextKey = Symbol("PanelContextProps");
var useProvidePanel = (props2) => {
  provide(PanelContextKey, props2);
};
var useInjectPanel = () => {
  return inject(PanelContextKey, {});
};

// node_modules/ant-design-vue/es/vc-picker/panels/Header.js
var HIDDEN_STYLE = {
  visibility: "hidden"
};
function Header(_props, _ref) {
  let {
    slots
  } = _ref;
  var _a2;
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    prevIcon = "‹",
    nextIcon = "›",
    superPrevIcon = "«",
    superNextIcon = "»",
    onSuperPrev,
    onSuperNext,
    onPrev,
    onNext
  } = props2;
  const {
    hideNextBtn,
    hidePrevBtn
  } = useInjectPanel();
  return createVNode("div", {
    "class": prefixCls
  }, [onSuperPrev && createVNode("button", {
    "type": "button",
    "onClick": onSuperPrev,
    "tabindex": -1,
    "class": `${prefixCls}-super-prev-btn`,
    "style": hidePrevBtn.value ? HIDDEN_STYLE : {}
  }, [superPrevIcon]), onPrev && createVNode("button", {
    "type": "button",
    "onClick": onPrev,
    "tabindex": -1,
    "class": `${prefixCls}-prev-btn`,
    "style": hidePrevBtn.value ? HIDDEN_STYLE : {}
  }, [prevIcon]), createVNode("div", {
    "class": `${prefixCls}-view`
  }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), onNext && createVNode("button", {
    "type": "button",
    "onClick": onNext,
    "tabindex": -1,
    "class": `${prefixCls}-next-btn`,
    "style": hideNextBtn.value ? HIDDEN_STYLE : {}
  }, [nextIcon]), onSuperNext && createVNode("button", {
    "type": "button",
    "onClick": onSuperNext,
    "tabindex": -1,
    "class": `${prefixCls}-super-next-btn`,
    "style": hideNextBtn.value ? HIDDEN_STYLE : {}
  }, [superNextIcon])]);
}
Header.displayName = "Header";
Header.inheritAttrs = false;
var Header_default = Header;

// node_modules/ant-design-vue/es/vc-picker/panels/DecadePanel/DecadeHeader.js
function DecadeHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    viewDate,
    onPrevDecades,
    onNextDecades
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const startYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  const endYear = startYear + DECADE_DISTANCE_COUNT - 1;
  return createVNode(Header_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecades,
    "onSuperNext": onNextDecades
  }), {
    default: () => [startYear, createTextVNode("-"), endYear]
  });
}
DecadeHeader.displayName = "DecadeHeader";
DecadeHeader.inheritAttrs = false;
var DecadeHeader_default = DecadeHeader;

// node_modules/ant-design-vue/es/vc-picker/utils/timeUtil.js
function setTime(generateConfig2, date, hour, minute, second) {
  let nextTime = generateConfig2.setHour(date, hour);
  nextTime = generateConfig2.setMinute(nextTime, minute);
  nextTime = generateConfig2.setSecond(nextTime, second);
  return nextTime;
}
function setDateTime(generateConfig2, date, defaultDate) {
  if (!defaultDate) {
    return date;
  }
  let newDate = date;
  newDate = generateConfig2.setHour(newDate, generateConfig2.getHour(defaultDate));
  newDate = generateConfig2.setMinute(newDate, generateConfig2.getMinute(defaultDate));
  newDate = generateConfig2.setSecond(newDate, generateConfig2.getSecond(defaultDate));
  return newDate;
}
function getLowerBoundTime(hour, minute, second, hourStep, minuteStep, secondStep) {
  const lowerBoundHour = Math.floor(hour / hourStep) * hourStep;
  if (lowerBoundHour < hour) {
    return [lowerBoundHour, 60 - minuteStep, 60 - secondStep];
  }
  const lowerBoundMinute = Math.floor(minute / minuteStep) * minuteStep;
  if (lowerBoundMinute < minute) {
    return [lowerBoundHour, lowerBoundMinute, 60 - secondStep];
  }
  const lowerBoundSecond = Math.floor(second / secondStep) * secondStep;
  return [lowerBoundHour, lowerBoundMinute, lowerBoundSecond];
}
function getLastDay(generateConfig2, date) {
  const year = generateConfig2.getYear(date);
  const month = generateConfig2.getMonth(date) + 1;
  const endDate = generateConfig2.getEndDate(generateConfig2.getFixedDate(`${year}-${month}-01`));
  const lastDay = generateConfig2.getDate(endDate);
  const monthShow = month < 10 ? `0${month}` : `${month}`;
  return `${year}-${monthShow}-${lastDay}`;
}

// node_modules/ant-design-vue/es/vc-picker/panels/PanelBody.js
function PanelBody(_props) {
  const {
    prefixCls,
    disabledDate,
    onSelect,
    picker,
    rowNum,
    colNum,
    prefixColumn,
    rowClassName,
    baseDate,
    getCellClassName,
    getCellText,
    getCellNode,
    getCellDate,
    generateConfig: generateConfig2,
    titleCell,
    headerCells
  } = useMergeProps(_props);
  const {
    onDateMouseenter,
    onDateMouseleave,
    mode
  } = useInjectPanel();
  const cellPrefixCls = `${prefixCls}-cell`;
  const rows = [];
  for (let i = 0; i < rowNum; i += 1) {
    const row = [];
    let rowStartDate;
    for (let j = 0; j < colNum; j += 1) {
      const offset = i * colNum + j;
      const currentDate = getCellDate(baseDate, offset);
      const disabled = getCellDateDisabled({
        cellDate: currentDate,
        mode: mode.value,
        disabledDate,
        generateConfig: generateConfig2
      });
      if (j === 0) {
        rowStartDate = currentDate;
        if (prefixColumn) {
          row.push(prefixColumn(rowStartDate));
        }
      }
      const title = titleCell && titleCell(currentDate);
      row.push(createVNode("td", {
        "key": j,
        "title": title,
        "class": classNames_default(cellPrefixCls, _extends({
          [`${cellPrefixCls}-disabled`]: disabled,
          [`${cellPrefixCls}-start`]: getCellText(currentDate) === 1 || picker === "year" && Number(title) % 10 === 0,
          [`${cellPrefixCls}-end`]: title === getLastDay(generateConfig2, currentDate) || picker === "year" && Number(title) % 10 === 9
        }, getCellClassName(currentDate))),
        "onClick": (e) => {
          e.stopPropagation();
          if (!disabled) {
            onSelect(currentDate);
          }
        },
        "onMouseenter": () => {
          if (!disabled && onDateMouseenter) {
            onDateMouseenter(currentDate);
          }
        },
        "onMouseleave": () => {
          if (!disabled && onDateMouseleave) {
            onDateMouseleave(currentDate);
          }
        }
      }, [getCellNode ? getCellNode(currentDate) : createVNode("div", {
        "class": `${cellPrefixCls}-inner`
      }, [getCellText(currentDate)])]));
    }
    rows.push(createVNode("tr", {
      "key": i,
      "class": rowClassName && rowClassName(rowStartDate)
    }, [row]));
  }
  return createVNode("div", {
    "class": `${prefixCls}-body`
  }, [createVNode("table", {
    "class": `${prefixCls}-content`
  }, [headerCells && createVNode("thead", null, [createVNode("tr", null, [headerCells])]), createVNode("tbody", null, [rows])])]);
}
PanelBody.displayName = "PanelBody";
PanelBody.inheritAttrs = false;
var PanelBody_default = PanelBody;

// node_modules/ant-design-vue/es/vc-picker/panels/DecadePanel/DecadeBody.js
var DECADE_COL_COUNT = 3;
var DECADE_ROW_COUNT = 4;
function DecadeBody(_props) {
  const props2 = useMergeProps(_props);
  const DECADE_UNIT_DIFF_DES = DECADE_UNIT_DIFF - 1;
  const {
    prefixCls,
    viewDate,
    generateConfig: generateConfig2
  } = props2;
  const cellPrefixCls = `${prefixCls}-cell`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const decadeYearNumber = Math.floor(yearNumber / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
  const startDecadeYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  const endDecadeYear = startDecadeYear + DECADE_DISTANCE_COUNT - 1;
  const baseDecadeYear = generateConfig2.setYear(viewDate, startDecadeYear - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF - DECADE_DISTANCE_COUNT) / 2));
  const getCellClassName = (date) => {
    const startDecadeNumber = generateConfig2.getYear(date);
    const endDecadeNumber = startDecadeNumber + DECADE_UNIT_DIFF_DES;
    return {
      [`${cellPrefixCls}-in-view`]: startDecadeYear <= startDecadeNumber && endDecadeNumber <= endDecadeYear,
      [`${cellPrefixCls}-selected`]: startDecadeNumber === decadeYearNumber
    };
  };
  return createVNode(PanelBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "rowNum": DECADE_ROW_COUNT,
    "colNum": DECADE_COL_COUNT,
    "baseDate": baseDecadeYear,
    "getCellText": (date) => {
      const startDecadeNumber = generateConfig2.getYear(date);
      return `${startDecadeNumber}-${startDecadeNumber + DECADE_UNIT_DIFF_DES}`;
    },
    "getCellClassName": getCellClassName,
    "getCellDate": (date, offset) => generateConfig2.addYear(date, offset * DECADE_UNIT_DIFF)
  }), null);
}
DecadeBody.displayName = "DecadeBody";
DecadeBody.inheritAttrs = false;
var DecadeBody_default = DecadeBody;

// node_modules/ant-design-vue/es/vc-picker/utils/uiUtil.js
var scrollIds = /* @__PURE__ */ new Map();
function waitElementReady(element, callback) {
  let id;
  function tryOrNextFrame() {
    if (isVisible_default(element)) {
      callback();
    } else {
      id = wrapperRaf(() => {
        tryOrNextFrame();
      });
    }
  }
  tryOrNextFrame();
  return () => {
    wrapperRaf.cancel(id);
  };
}
function scrollTo2(element, to, duration) {
  if (scrollIds.get(element)) {
    wrapperRaf.cancel(scrollIds.get(element));
  }
  if (duration <= 0) {
    scrollIds.set(element, wrapperRaf(() => {
      element.scrollTop = to;
    }));
    return;
  }
  const difference = to - element.scrollTop;
  const perTick = difference / duration * 10;
  scrollIds.set(element, wrapperRaf(() => {
    element.scrollTop += perTick;
    if (element.scrollTop !== to) {
      scrollTo2(element, to, duration - 10);
    }
  }));
}
function createKeydownHandler(event, _ref) {
  let {
    onLeftRight,
    onCtrlLeftRight,
    onUpDown,
    onPageUpDown,
    onEnter
  } = _ref;
  const {
    which,
    ctrlKey,
    metaKey
  } = event;
  switch (which) {
    case KeyCode_default.LEFT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(-1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(-1);
        return true;
      }
      break;
    case KeyCode_default.RIGHT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(1);
        return true;
      }
      break;
    case KeyCode_default.UP:
      if (onUpDown) {
        onUpDown(-1);
        return true;
      }
      break;
    case KeyCode_default.DOWN:
      if (onUpDown) {
        onUpDown(1);
        return true;
      }
      break;
    case KeyCode_default.PAGE_UP:
      if (onPageUpDown) {
        onPageUpDown(-1);
        return true;
      }
      break;
    case KeyCode_default.PAGE_DOWN:
      if (onPageUpDown) {
        onPageUpDown(1);
        return true;
      }
      break;
    case KeyCode_default.ENTER:
      if (onEnter) {
        onEnter();
        return true;
      }
      break;
  }
  return false;
}
function getDefaultFormat(format2, picker, showTime, use12Hours) {
  let mergedFormat = format2;
  if (!mergedFormat) {
    switch (picker) {
      case "time":
        mergedFormat = use12Hours ? "hh:mm:ss a" : "HH:mm:ss";
        break;
      case "week":
        mergedFormat = "gggg-wo";
        break;
      case "month":
        mergedFormat = "YYYY-MM";
        break;
      case "quarter":
        mergedFormat = "YYYY-[Q]Q";
        break;
      case "year":
        mergedFormat = "YYYY";
        break;
      default:
        mergedFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    }
  }
  return mergedFormat;
}
function getInputSize(picker, format2, generateConfig2) {
  const defaultSize = picker === "time" ? 8 : 10;
  const length = typeof format2 === "function" ? format2(generateConfig2.getNow()).length : format2.length;
  return Math.max(defaultSize, length) + 2;
}
var globalClickFunc = null;
var clickCallbacks = /* @__PURE__ */ new Set();
function addGlobalMousedownEvent(callback) {
  if (!globalClickFunc && typeof window !== "undefined" && window.addEventListener) {
    globalClickFunc = (e) => {
      [...clickCallbacks].forEach((queueFunc) => {
        queueFunc(e);
      });
    };
    window.addEventListener("mousedown", globalClickFunc);
  }
  clickCallbacks.add(callback);
  return () => {
    clickCallbacks.delete(callback);
    if (clickCallbacks.size === 0) {
      window.removeEventListener("mousedown", globalClickFunc);
      globalClickFunc = null;
    }
  };
}
function getTargetFromEvent(e) {
  var _a2;
  const target = e.target;
  if (e.composed && target.shadowRoot) {
    return ((_a2 = e.composedPath) === null || _a2 === void 0 ? void 0 : _a2.call(e)[0]) || target;
  }
  return target;
}
var getYearNextMode = (next) => {
  if (next === "month" || next === "date") {
    return "year";
  }
  return next;
};
var getMonthNextMode = (next) => {
  if (next === "date") {
    return "month";
  }
  return next;
};
var getQuarterNextMode = (next) => {
  if (next === "month" || next === "date") {
    return "quarter";
  }
  return next;
};
var getWeekNextMode = (next) => {
  if (next === "date") {
    return "week";
  }
  return next;
};
var PickerModeMap = {
  year: getYearNextMode,
  month: getMonthNextMode,
  quarter: getQuarterNextMode,
  week: getWeekNextMode,
  time: null,
  date: null
};
function elementsContains(elements, target) {
  if (false) {
    return false;
  }
  return elements.some((ele) => ele && ele.contains(target));
}

// node_modules/ant-design-vue/es/vc-picker/panels/DecadePanel/index.js
var DECADE_UNIT_DIFF = 10;
var DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;
function DecadePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    onViewDateChange,
    generateConfig: generateConfig2,
    viewDate,
    operationRef,
    onSelect,
    onPanelChange
  } = props2;
  const panelPrefixCls = `${prefixCls}-decade-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key");
      },
      onEnter: () => {
        onPanelChange("year", viewDate);
      }
    })
  };
  const onDecadesChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  const onInternalSelect = (date) => {
    onSelect(date, "mouse");
    onPanelChange("year", date);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(DecadeHeader_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevDecades": () => {
      onDecadesChange(-1);
    },
    "onNextDecades": () => {
      onDecadesChange(1);
    }
  }), null), createVNode(DecadeBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": onInternalSelect
  }), null)]);
}
DecadePanel.displayName = "DecadePanel";
DecadePanel.inheritAttrs = false;
var DecadePanel_default = DecadePanel;

// node_modules/ant-design-vue/es/vc-picker/utils/dateUtil.js
var WEEK_DAY_COUNT = 7;
function isNullEqual(value1, value2) {
  if (!value1 && !value2) {
    return true;
  }
  if (!value1 || !value2) {
    return false;
  }
  return void 0;
}
function isSameDecade(generateConfig2, decade1, decade2) {
  const equal = isNullEqual(decade1, decade2);
  if (typeof equal === "boolean") {
    return equal;
  }
  const num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
  const num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
  return num1 === num2;
}
function isSameYear(generateConfig2, year1, year2) {
  const equal = isNullEqual(year1, year2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
}
function getQuarter(generateConfig2, date) {
  const quota = Math.floor(generateConfig2.getMonth(date) / 3);
  return quota + 1;
}
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  const equal = isNullEqual(quarter1, quarter2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
}
function isSameMonth(generateConfig2, month1, month2) {
  const equal = isNullEqual(month1, month2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
}
function isSameDate(generateConfig2, date1, date2) {
  const equal = isNullEqual(date1, date2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(date1) === generateConfig2.getYear(date2) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date2) && generateConfig2.getDate(date1) === generateConfig2.getDate(date2);
}
function isSameTime(generateConfig2, time1, time2) {
  const equal = isNullEqual(time1, time2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
}
function isSameWeek(generateConfig2, locale, date1, date2) {
  const equal = isNullEqual(date1, date2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.locale.getWeek(locale, date1) === generateConfig2.locale.getWeek(locale, date2);
}
function isEqual(generateConfig2, value1, value2) {
  return isSameDate(generateConfig2, value1, value2) && isSameTime(generateConfig2, value1, value2);
}
function isInRange(generateConfig2, startDate, endDate, current) {
  if (!startDate || !endDate || !current) {
    return false;
  }
  return !isSameDate(generateConfig2, startDate, current) && !isSameDate(generateConfig2, endDate, current) && generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
}
function getWeekStartDate(locale, generateConfig2, value) {
  const weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale);
  const monthStartDate = generateConfig2.setDate(value, 1);
  const startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
  let alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
    alignStartDate = generateConfig2.addDate(alignStartDate, -7);
  }
  return alignStartDate;
}
function getClosingViewDate(viewDate, picker, generateConfig2) {
  let offset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  switch (picker) {
    case "year":
      return generateConfig2.addYear(viewDate, offset * 10);
    case "quarter":
    case "month":
      return generateConfig2.addYear(viewDate, offset);
    default:
      return generateConfig2.addMonth(viewDate, offset);
  }
}
function formatValue(value, _ref) {
  let {
    generateConfig: generateConfig2,
    locale,
    format: format2
  } = _ref;
  return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale.locale, value, format2);
}
function parseValue(value, _ref2) {
  let {
    generateConfig: generateConfig2,
    locale,
    formatList
  } = _ref2;
  if (!value || typeof formatList[0] === "function") {
    return null;
  }
  return generateConfig2.locale.parse(locale.locale, value, formatList);
}
function getCellDateDisabled(_ref3) {
  let {
    cellDate,
    mode,
    disabledDate,
    generateConfig: generateConfig2
  } = _ref3;
  if (!disabledDate)
    return false;
  const getDisabledFromRange = (currentMode, start, end) => {
    let current = start;
    while (current <= end) {
      let date;
      switch (currentMode) {
        case "date": {
          date = generateConfig2.setDate(cellDate, current);
          if (!disabledDate(date)) {
            return false;
          }
          break;
        }
        case "month": {
          date = generateConfig2.setMonth(cellDate, current);
          if (!getCellDateDisabled({
            cellDate: date,
            mode: "month",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
        case "year": {
          date = generateConfig2.setYear(cellDate, current);
          if (!getCellDateDisabled({
            cellDate: date,
            mode: "year",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
      }
      current += 1;
    }
    return true;
  };
  switch (mode) {
    case "date":
    case "week": {
      return disabledDate(cellDate);
    }
    case "month": {
      const startDate = 1;
      const endDate = generateConfig2.getDate(generateConfig2.getEndDate(cellDate));
      return getDisabledFromRange("date", startDate, endDate);
    }
    case "quarter": {
      const startMonth = Math.floor(generateConfig2.getMonth(cellDate) / 3) * 3;
      const endMonth = startMonth + 2;
      return getDisabledFromRange("month", startMonth, endMonth);
    }
    case "year": {
      return getDisabledFromRange("month", 0, 11);
    }
    case "decade": {
      const year = generateConfig2.getYear(cellDate);
      const startYear = Math.floor(year / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
      const endYear = startYear + DECADE_UNIT_DIFF - 1;
      return getDisabledFromRange("year", startYear, endYear);
    }
  }
}

// node_modules/ant-design-vue/es/vc-picker/panels/TimePanel/TimeHeader.js
function TimeHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale,
    value,
    format: format2
  } = props2;
  const headerPrefixCls = `${prefixCls}-header`;
  return createVNode(Header_default, {
    "prefixCls": headerPrefixCls
  }, {
    default: () => [value ? formatValue(value, {
      locale,
      format: format2,
      generateConfig: generateConfig2
    }) : " "]
  });
}
TimeHeader.displayName = "TimeHeader";
TimeHeader.inheritAttrs = false;
var TimeHeader_default = TimeHeader;

// node_modules/ant-design-vue/es/vc-picker/panels/TimePanel/TimeUnitColumn.js
var TimeUnitColumn_default = defineComponent({
  name: "TimeUnitColumn",
  props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
  setup(props2) {
    const {
      open: open2
    } = useInjectPanel();
    const ulRef = shallowRef(null);
    const liRefs = ref(/* @__PURE__ */ new Map());
    const scrollRef = ref();
    watch(() => props2.value, () => {
      const li = liRefs.value.get(props2.value);
      if (li && open2.value !== false) {
        scrollTo2(ulRef.value, li.offsetTop, 120);
      }
    });
    onBeforeUnmount(() => {
      var _a2;
      (_a2 = scrollRef.value) === null || _a2 === void 0 ? void 0 : _a2.call(scrollRef);
    });
    watch(open2, () => {
      var _a2;
      (_a2 = scrollRef.value) === null || _a2 === void 0 ? void 0 : _a2.call(scrollRef);
      nextTick(() => {
        if (open2.value) {
          const li = liRefs.value.get(props2.value);
          if (li) {
            scrollRef.value = waitElementReady(li, () => {
              scrollTo2(ulRef.value, li.offsetTop, 0);
            });
          }
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    return () => {
      const {
        prefixCls,
        units,
        onSelect,
        value,
        active,
        hideDisabledOptions
      } = props2;
      const cellPrefixCls = `${prefixCls}-cell`;
      return createVNode("ul", {
        "class": classNames_default(`${prefixCls}-column`, {
          [`${prefixCls}-column-active`]: active
        }),
        "ref": ulRef,
        "style": {
          position: "relative"
        }
      }, [units.map((unit) => {
        if (hideDisabledOptions && unit.disabled) {
          return null;
        }
        return createVNode("li", {
          "key": unit.value,
          "ref": (element) => {
            liRefs.value.set(unit.value, element);
          },
          "class": classNames_default(cellPrefixCls, {
            [`${cellPrefixCls}-disabled`]: unit.disabled,
            [`${cellPrefixCls}-selected`]: value === unit.value
          }),
          "onClick": () => {
            if (unit.disabled) {
              return;
            }
            onSelect(unit.value);
          }
        }, [createVNode("div", {
          "class": `${cellPrefixCls}-inner`
        }, [unit.label])]);
      })]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-picker/utils/miscUtil.js
function leftPad(str, length) {
  let fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  let current = String(str);
  while (current.length < length) {
    current = `${fill}${str}`;
  }
  return current;
}
var tuple2 = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};
function toArray(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
}
function getDataOrAriaProps(props2) {
  const retProps = {};
  Object.keys(props2).forEach((key) => {
    if ((key.startsWith("data-") || key.startsWith("aria-") || key === "role" || key === "name") && !key.startsWith("data-__")) {
      retProps[key] = props2[key];
    }
  });
  return retProps;
}
function getValue(values, index2) {
  return values ? values[index2] : null;
}
function updateValues(values, value, index2) {
  const newValues = [getValue(values, 0), getValue(values, 1)];
  newValues[index2] = typeof value === "function" ? value(newValues[index2]) : value;
  if (!newValues[0] && !newValues[1]) {
    return null;
  }
  return newValues;
}

// node_modules/ant-design-vue/es/vc-picker/panels/TimePanel/TimeBody.js
function generateUnits(start, end, step, disabledUnits) {
  const units = [];
  for (let i = start; i <= end; i += step) {
    units.push({
      label: leftPad(i, 2),
      value: i,
      disabled: (disabledUnits || []).includes(i)
    });
  }
  return units;
}
var TimeBody = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TimeBody",
  inheritAttrs: false,
  props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour", "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours", "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
  setup(props2) {
    const originHour = computed(() => props2.value ? props2.generateConfig.getHour(props2.value) : -1);
    const isPM = computed(() => {
      if (props2.use12Hours) {
        return originHour.value >= 12;
      } else {
        return false;
      }
    });
    const hour = computed(() => {
      if (props2.use12Hours) {
        return originHour.value % 12;
      } else {
        return originHour.value;
      }
    });
    const minute = computed(() => props2.value ? props2.generateConfig.getMinute(props2.value) : -1);
    const second = computed(() => props2.value ? props2.generateConfig.getSecond(props2.value) : -1);
    const now2 = ref(props2.generateConfig.getNow());
    const mergedDisabledHours = ref();
    const mergedDisabledMinutes = ref();
    const mergedDisabledSeconds = ref();
    onBeforeUpdate(() => {
      now2.value = props2.generateConfig.getNow();
    });
    watchEffect(() => {
      if (props2.disabledTime) {
        const disabledConfig = props2.disabledTime(now2);
        [mergedDisabledHours.value, mergedDisabledMinutes.value, mergedDisabledSeconds.value] = [disabledConfig.disabledHours, disabledConfig.disabledMinutes, disabledConfig.disabledSeconds];
      } else {
        [mergedDisabledHours.value, mergedDisabledMinutes.value, mergedDisabledSeconds.value] = [props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds];
      }
    });
    const setTime2 = (isNewPM, newHour, newMinute, newSecond) => {
      let newDate = props2.value || props2.generateConfig.getNow();
      const mergedHour = Math.max(0, newHour);
      const mergedMinute = Math.max(0, newMinute);
      const mergedSecond = Math.max(0, newSecond);
      newDate = setTime(props2.generateConfig, newDate, !props2.use12Hours || !isNewPM ? mergedHour : mergedHour + 12, mergedMinute, mergedSecond);
      return newDate;
    };
    const rawHours = computed(() => {
      var _a2;
      return generateUnits(0, 23, (_a2 = props2.hourStep) !== null && _a2 !== void 0 ? _a2 : 1, mergedDisabledHours.value && mergedDisabledHours.value());
    });
    const AMPMDisabled = computed(() => {
      if (!props2.use12Hours) {
        return [false, false];
      }
      const AMPMDisabled2 = [true, true];
      rawHours.value.forEach((_ref) => {
        let {
          disabled,
          value: hourValue
        } = _ref;
        if (disabled)
          return;
        if (hourValue >= 12) {
          AMPMDisabled2[1] = false;
        } else {
          AMPMDisabled2[0] = false;
        }
      });
      return AMPMDisabled2;
    });
    const hours = computed(() => {
      if (!props2.use12Hours)
        return rawHours.value;
      return rawHours.value.filter(isPM.value ? (hourMeta) => hourMeta.value >= 12 : (hourMeta) => hourMeta.value < 12).map((hourMeta) => {
        const hourValue = hourMeta.value % 12;
        const hourLabel = hourValue === 0 ? "12" : leftPad(hourValue, 2);
        return _extends(_extends({}, hourMeta), {
          label: hourLabel,
          value: hourValue
        });
      });
    });
    const minutes = computed(() => {
      var _a2;
      return generateUnits(0, 59, (_a2 = props2.minuteStep) !== null && _a2 !== void 0 ? _a2 : 1, mergedDisabledMinutes.value && mergedDisabledMinutes.value(originHour.value));
    });
    const seconds = computed(() => {
      var _a2;
      return generateUnits(0, 59, (_a2 = props2.secondStep) !== null && _a2 !== void 0 ? _a2 : 1, mergedDisabledSeconds.value && mergedDisabledSeconds.value(originHour.value, minute.value));
    });
    return () => {
      const {
        prefixCls,
        operationRef,
        activeColumnIndex,
        showHour,
        showMinute,
        showSecond,
        use12Hours,
        hideDisabledOptions,
        onSelect
      } = props2;
      const columns = [];
      const contentPrefixCls = `${prefixCls}-content`;
      const columnPrefixCls = `${prefixCls}-time-panel`;
      operationRef.value = {
        onUpDown: (diff) => {
          const column = columns[activeColumnIndex];
          if (column) {
            const valueIndex = column.units.findIndex((unit) => unit.value === column.value);
            const unitLen = column.units.length;
            for (let i = 1; i < unitLen; i += 1) {
              const nextUnit = column.units[(valueIndex + diff * i + unitLen) % unitLen];
              if (nextUnit.disabled !== true) {
                column.onSelect(nextUnit.value);
                break;
              }
            }
          }
        }
      };
      function addColumnNode(condition, node, columnValue, units, onColumnSelect) {
        if (condition !== false) {
          columns.push({
            node: cloneElement(node, {
              prefixCls: columnPrefixCls,
              value: columnValue,
              active: activeColumnIndex === columns.length,
              onSelect: onColumnSelect,
              units,
              hideDisabledOptions
            }),
            onSelect: onColumnSelect,
            value: columnValue,
            units
          });
        }
      }
      addColumnNode(showHour, createVNode(TimeUnitColumn_default, {
        "key": "hour"
      }, null), hour.value, hours.value, (num) => {
        onSelect(setTime2(isPM.value, num, minute.value, second.value), "mouse");
      });
      addColumnNode(showMinute, createVNode(TimeUnitColumn_default, {
        "key": "minute"
      }, null), minute.value, minutes.value, (num) => {
        onSelect(setTime2(isPM.value, hour.value, num, second.value), "mouse");
      });
      addColumnNode(showSecond, createVNode(TimeUnitColumn_default, {
        "key": "second"
      }, null), second.value, seconds.value, (num) => {
        onSelect(setTime2(isPM.value, hour.value, minute.value, num), "mouse");
      });
      let PMIndex = -1;
      if (typeof isPM.value === "boolean") {
        PMIndex = isPM.value ? 1 : 0;
      }
      addColumnNode(use12Hours === true, createVNode(TimeUnitColumn_default, {
        "key": "12hours"
      }, null), PMIndex, [{
        label: "AM",
        value: 0,
        disabled: AMPMDisabled.value[0]
      }, {
        label: "PM",
        value: 1,
        disabled: AMPMDisabled.value[1]
      }], (num) => {
        onSelect(setTime2(!!num, hour.value, minute.value, second.value), "mouse");
      });
      return createVNode("div", {
        "class": contentPrefixCls
      }, [columns.map((_ref2) => {
        let {
          node
        } = _ref2;
        return node;
      })]);
    };
  }
});
var TimeBody_default = TimeBody;

// node_modules/ant-design-vue/es/vc-picker/panels/TimePanel/index.js
var countBoolean = (boolList) => boolList.filter((bool) => bool !== false).length;
function TimePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    generateConfig: generateConfig2,
    format: format2 = "HH:mm:ss",
    prefixCls,
    active,
    operationRef,
    showHour,
    showMinute,
    showSecond,
    use12Hours = false,
    onSelect,
    value
  } = props2;
  const panelPrefixCls = `${prefixCls}-time-panel`;
  const bodyOperationRef = ref();
  const activeColumnIndex = ref(-1);
  const columnsCount = countBoolean([showHour, showMinute, showSecond, use12Hours]);
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        activeColumnIndex.value = (activeColumnIndex.value + diff + columnsCount) % columnsCount;
      },
      onUpDown: (diff) => {
        if (activeColumnIndex.value === -1) {
          activeColumnIndex.value = 0;
        } else if (bodyOperationRef.value) {
          bodyOperationRef.value.onUpDown(diff);
        }
      },
      onEnter: () => {
        onSelect(value || generateConfig2.getNow(), "key");
        activeColumnIndex.value = -1;
      }
    }),
    onBlur: () => {
      activeColumnIndex.value = -1;
    }
  };
  return createVNode("div", {
    "class": classNames_default(panelPrefixCls, {
      [`${panelPrefixCls}-active`]: active
    })
  }, [createVNode(TimeHeader_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "format": format2,
    "prefixCls": prefixCls
  }), null), createVNode(TimeBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "activeColumnIndex": activeColumnIndex.value,
    "operationRef": bodyOperationRef
  }), null)]);
}
TimePanel.displayName = "TimePanel";
TimePanel.inheritAttrs = false;
var TimePanel_default = TimePanel;

// node_modules/ant-design-vue/es/vc-picker/hooks/useCellClassName.js
function useCellClassName(_ref) {
  let {
    cellPrefixCls,
    generateConfig: generateConfig2,
    rangedValue,
    hoverRangedValue,
    isInView,
    isSameCell,
    offsetCell,
    today,
    value
  } = _ref;
  function getClassName(currentDate) {
    const prevDate = offsetCell(currentDate, -1);
    const nextDate = offsetCell(currentDate, 1);
    const rangeStart = getValue(rangedValue, 0);
    const rangeEnd = getValue(rangedValue, 1);
    const hoverStart = getValue(hoverRangedValue, 0);
    const hoverEnd = getValue(hoverRangedValue, 1);
    const isRangeHovered = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
    function isRangeStart(date) {
      return isSameCell(rangeStart, date);
    }
    function isRangeEnd(date) {
      return isSameCell(rangeEnd, date);
    }
    const isHoverStart = isSameCell(hoverStart, currentDate);
    const isHoverEnd = isSameCell(hoverEnd, currentDate);
    const isHoverEdgeStart = (isRangeHovered || isHoverEnd) && (!isInView(prevDate) || isRangeEnd(prevDate));
    const isHoverEdgeEnd = (isRangeHovered || isHoverStart) && (!isInView(nextDate) || isRangeStart(nextDate));
    return {
      // In view
      [`${cellPrefixCls}-in-view`]: isInView(currentDate),
      // Range
      [`${cellPrefixCls}-in-range`]: isInRange(generateConfig2, rangeStart, rangeEnd, currentDate),
      [`${cellPrefixCls}-range-start`]: isRangeStart(currentDate),
      [`${cellPrefixCls}-range-end`]: isRangeEnd(currentDate),
      [`${cellPrefixCls}-range-start-single`]: isRangeStart(currentDate) && !rangeEnd,
      [`${cellPrefixCls}-range-end-single`]: isRangeEnd(currentDate) && !rangeStart,
      [`${cellPrefixCls}-range-start-near-hover`]: isRangeStart(currentDate) && (isSameCell(prevDate, hoverStart) || isInRange(generateConfig2, hoverStart, hoverEnd, prevDate)),
      [`${cellPrefixCls}-range-end-near-hover`]: isRangeEnd(currentDate) && (isSameCell(nextDate, hoverEnd) || isInRange(generateConfig2, hoverStart, hoverEnd, nextDate)),
      // Range Hover
      [`${cellPrefixCls}-range-hover`]: isRangeHovered,
      [`${cellPrefixCls}-range-hover-start`]: isHoverStart,
      [`${cellPrefixCls}-range-hover-end`]: isHoverEnd,
      // Range Edge
      [`${cellPrefixCls}-range-hover-edge-start`]: isHoverEdgeStart,
      [`${cellPrefixCls}-range-hover-edge-end`]: isHoverEdgeEnd,
      [`${cellPrefixCls}-range-hover-edge-start-near-range`]: isHoverEdgeStart && isSameCell(prevDate, rangeEnd),
      [`${cellPrefixCls}-range-hover-edge-end-near-range`]: isHoverEdgeEnd && isSameCell(nextDate, rangeStart),
      // Others
      [`${cellPrefixCls}-today`]: isSameCell(today, currentDate),
      [`${cellPrefixCls}-selected`]: isSameCell(value, currentDate)
    };
  }
  return getClassName;
}

// node_modules/ant-design-vue/es/vc-picker/RangeContext.js
var RangeContextKey = Symbol("RangeContextProps");
var useProvideRange = (props2) => {
  provide(RangeContextKey, props2);
};
var useInjectRange = () => {
  return inject(RangeContextKey, {
    rangedValue: ref(),
    hoverRangedValue: ref(),
    inRange: ref(),
    panelPosition: ref()
  });
};
var RangeContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContextProvider",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const value = {
      rangedValue: ref(props2.value.rangedValue),
      hoverRangedValue: ref(props2.value.hoverRangedValue),
      inRange: ref(props2.value.inRange),
      panelPosition: ref(props2.value.panelPosition)
    };
    useProvideRange(value);
    toRef;
    watch(() => props2.value, () => {
      Object.keys(props2.value).forEach((key) => {
        if (value[key]) {
          value[key].value = props2.value[key];
        }
      });
    });
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});

// node_modules/ant-design-vue/es/vc-picker/panels/DatePanel/DateBody.js
function DateBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    prefixColumn,
    locale,
    rowCount,
    viewDate,
    value,
    dateRender
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const baseDate = getWeekStartDate(locale.locale, generateConfig2, viewDate);
  const cellPrefixCls = `${prefixCls}-cell`;
  const weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale.locale);
  const today = generateConfig2.getNow();
  const headerCells = [];
  const weekDaysLocale = locale.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale.locale) : []);
  if (prefixColumn) {
    headerCells.push(createVNode("th", {
      "key": "empty",
      "aria-label": "empty cell"
    }, null));
  }
  for (let i = 0; i < WEEK_DAY_COUNT; i += 1) {
    headerCells.push(createVNode("th", {
      "key": i
    }, [weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]]));
  }
  const getCellClassName = useCellClassName({
    cellPrefixCls,
    today,
    value,
    generateConfig: generateConfig2,
    rangedValue: prefixColumn ? null : rangedValue.value,
    hoverRangedValue: prefixColumn ? null : hoverRangedValue.value,
    isSameCell: (current, target) => isSameDate(generateConfig2, current, target),
    isInView: (date) => isSameMonth(generateConfig2, date, viewDate),
    offsetCell: (date, offset) => generateConfig2.addDate(date, offset)
  });
  const getCellNode = dateRender ? (date) => dateRender({
    current: date,
    today
  }) : void 0;
  return createVNode(PanelBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "rowNum": rowCount,
    "colNum": WEEK_DAY_COUNT,
    "baseDate": baseDate,
    "getCellNode": getCellNode,
    "getCellText": generateConfig2.getDate,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addDate,
    "titleCell": (date) => formatValue(date, {
      locale,
      format: "YYYY-MM-DD",
      generateConfig: generateConfig2
    }),
    "headerCells": headerCells
  }), null);
}
DateBody.displayName = "DateBody";
DateBody.inheritAttrs = false;
DateBody.props = [
  "prefixCls",
  "generateConfig",
  "value?",
  "viewDate",
  "locale",
  "rowCount",
  "onSelect",
  "dateRender?",
  "disabledDate?",
  // Used for week panel
  "prefixColumn?",
  "rowClassName?"
];
var DateBody_default = DateBody;

// node_modules/ant-design-vue/es/vc-picker/panels/DatePanel/DateHeader.js
function DateHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale,
    viewDate,
    onNextMonth,
    onPrevMonth,
    onNextYear,
    onPrevYear,
    onYearClick,
    onMonthClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  const monthsLocale = locale.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale.locale) : []);
  const month = generateConfig2.getMonth(viewDate);
  const yearNode = createVNode("button", {
    "type": "button",
    "key": "year",
    "onClick": onYearClick,
    "tabindex": -1,
    "class": `${prefixCls}-year-btn`
  }, [formatValue(viewDate, {
    locale,
    format: locale.yearFormat,
    generateConfig: generateConfig2
  })]);
  const monthNode = createVNode("button", {
    "type": "button",
    "key": "month",
    "onClick": onMonthClick,
    "tabindex": -1,
    "class": `${prefixCls}-month-btn`
  }, [locale.monthFormat ? formatValue(viewDate, {
    locale,
    format: locale.monthFormat,
    generateConfig: generateConfig2
  }) : monthsLocale[month]]);
  const monthYearNodes = locale.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return createVNode(Header_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onPrev": onPrevMonth,
    "onNext": onNextMonth,
    "onSuperNext": onNextYear
  }), {
    default: () => [monthYearNodes]
  });
}
DateHeader.displayName = "DateHeader";
DateHeader.inheritAttrs = false;
var DateHeader_default = DateHeader;

// node_modules/ant-design-vue/es/vc-picker/panels/DatePanel/index.js
var DATE_ROW_COUNT = 6;
function DatePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    panelName = "date",
    keyboardConfig,
    active,
    operationRef,
    generateConfig: generateConfig2,
    value,
    viewDate,
    onViewDateChange,
    onPanelChange,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-${panelName}-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, _extends({
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addDate(value || viewDate, diff), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addDate(value || viewDate, diff * WEEK_DAY_COUNT), "key");
      },
      onPageUpDown: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
      }
    }, keyboardConfig))
  };
  const onYearChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  const onMonthChange = (diff) => {
    const newDate = generateConfig2.addMonth(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": classNames_default(panelPrefixCls, {
      [`${panelPrefixCls}-active`]: active
    })
  }, [createVNode(DateHeader_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "onPrevYear": () => {
      onYearChange(-1);
    },
    "onNextYear": () => {
      onYearChange(1);
    },
    "onPrevMonth": () => {
      onMonthChange(-1);
    },
    "onNextMonth": () => {
      onMonthChange(1);
    },
    "onMonthClick": () => {
      onPanelChange("month", viewDate);
    },
    "onYearClick": () => {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(DateBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "onSelect": (date) => onSelect(date, "mouse"),
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "rowCount": DATE_ROW_COUNT
  }), null)]);
}
DatePanel.displayName = "DatePanel";
DatePanel.inheritAttrs = false;
var DatePanel_default = DatePanel;

// node_modules/ant-design-vue/es/vc-picker/panels/DatetimePanel/index.js
var ACTIVE_PANEL = tuple2("date", "time");
function DatetimePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    generateConfig: generateConfig2,
    value,
    defaultValue,
    disabledTime,
    showTime,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-datetime-panel`;
  const activePanel = ref(null);
  const dateOperationRef = ref({});
  const timeOperationRef = ref({});
  const timeProps = typeof showTime === "object" ? _extends({}, showTime) : {};
  function getNextActive(offset) {
    const activeIndex = ACTIVE_PANEL.indexOf(activePanel.value) + offset;
    const nextActivePanel = ACTIVE_PANEL[activeIndex] || null;
    return nextActivePanel;
  }
  const onBlur = (e) => {
    if (timeOperationRef.value.onBlur) {
      timeOperationRef.value.onBlur(e);
    }
    activePanel.value = null;
  };
  operationRef.value = {
    onKeydown: (event) => {
      if (event.which === KeyCode_default.TAB) {
        const nextActivePanel = getNextActive(event.shiftKey ? -1 : 1);
        activePanel.value = nextActivePanel;
        if (nextActivePanel) {
          event.preventDefault();
        }
        return true;
      }
      if (activePanel.value) {
        const ref2 = activePanel.value === "date" ? dateOperationRef : timeOperationRef;
        if (ref2.value && ref2.value.onKeydown) {
          ref2.value.onKeydown(event);
        }
        return true;
      }
      if ([KeyCode_default.LEFT, KeyCode_default.RIGHT, KeyCode_default.UP, KeyCode_default.DOWN].includes(event.which)) {
        activePanel.value = "date";
        return true;
      }
      return false;
    },
    onBlur,
    onClose: onBlur
  };
  const onInternalSelect = (date, source) => {
    let selectedDate = date;
    if (source === "date" && !value && timeProps.defaultValue) {
      selectedDate = generateConfig2.setHour(selectedDate, generateConfig2.getHour(timeProps.defaultValue));
      selectedDate = generateConfig2.setMinute(selectedDate, generateConfig2.getMinute(timeProps.defaultValue));
      selectedDate = generateConfig2.setSecond(selectedDate, generateConfig2.getSecond(timeProps.defaultValue));
    } else if (source === "time" && !value && defaultValue) {
      selectedDate = generateConfig2.setYear(selectedDate, generateConfig2.getYear(defaultValue));
      selectedDate = generateConfig2.setMonth(selectedDate, generateConfig2.getMonth(defaultValue));
      selectedDate = generateConfig2.setDate(selectedDate, generateConfig2.getDate(defaultValue));
    }
    if (onSelect) {
      onSelect(selectedDate, "mouse");
    }
  };
  const disabledTimes = disabledTime ? disabledTime(value || null) : {};
  return createVNode("div", {
    "class": classNames_default(panelPrefixCls, {
      [`${panelPrefixCls}-active`]: activePanel.value
    })
  }, [createVNode(DatePanel_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "operationRef": dateOperationRef,
    "active": activePanel.value === "date",
    "onSelect": (date) => {
      onInternalSelect(setDateTime(generateConfig2, date, !value && typeof showTime === "object" ? showTime.defaultValue : null), "date");
    }
  }), null), createVNode(TimePanel_default, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, props2), {}, {
    "format": void 0
  }, timeProps), disabledTimes), {}, {
    "disabledTime": null,
    "defaultValue": void 0,
    "operationRef": timeOperationRef,
    "active": activePanel.value === "time",
    "onSelect": (date) => {
      onInternalSelect(date, "time");
    }
  }), null)]);
}
DatetimePanel.displayName = "DatetimePanel";
DatetimePanel.inheritAttrs = false;
var DatetimePanel_default = DatetimePanel;

// node_modules/ant-design-vue/es/vc-picker/panels/WeekPanel/index.js
function WeekPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale,
    value
  } = props2;
  const cellPrefixCls = `${prefixCls}-cell`;
  const prefixColumn = (date) => createVNode("td", {
    "key": "week",
    "class": classNames_default(cellPrefixCls, `${cellPrefixCls}-week`)
  }, [generateConfig2.locale.getWeek(locale.locale, date)]);
  const rowPrefixCls = `${prefixCls}-week-panel-row`;
  const rowClassName = (date) => classNames_default(rowPrefixCls, {
    [`${rowPrefixCls}-selected`]: isSameWeek(generateConfig2, locale.locale, value, date)
  });
  return createVNode(DatePanel_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "panelName": "week",
    "prefixColumn": prefixColumn,
    "rowClassName": rowClassName,
    "keyboardConfig": {
      onLeftRight: null
    }
  }), null);
}
WeekPanel.displayName = "WeekPanel";
WeekPanel.inheritAttrs = false;
var WeekPanel_default = WeekPanel;

// node_modules/ant-design-vue/es/vc-picker/panels/MonthPanel/MonthHeader.js
function MonthHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale,
    viewDate,
    onNextYear,
    onPrevYear,
    onYearClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  return createVNode(Header_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: () => [createVNode("button", {
      "type": "button",
      "onClick": onYearClick,
      "class": `${prefixCls}-year-btn`
    }, [formatValue(viewDate, {
      locale,
      format: locale.yearFormat,
      generateConfig: generateConfig2
    })])]
  });
}
MonthHeader.displayName = "MonthHeader";
MonthHeader.inheritAttrs = false;
var MonthHeader_default = MonthHeader;

// node_modules/ant-design-vue/es/vc-picker/panels/MonthPanel/MonthBody.js
var MONTH_COL_COUNT = 3;
var MONTH_ROW_COUNT = 4;
function MonthBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    locale,
    value,
    viewDate,
    generateConfig: generateConfig2,
    monthCellRender
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const cellPrefixCls = `${prefixCls}-cell`;
  const getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: (current, target) => isSameMonth(generateConfig2, current, target),
    isInView: () => true,
    offsetCell: (date, offset) => generateConfig2.addMonth(date, offset)
  });
  const monthsLocale = locale.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale.locale) : []);
  const baseMonth = generateConfig2.setMonth(viewDate, 0);
  const getCellNode = monthCellRender ? (date) => monthCellRender({
    current: date,
    locale
  }) : void 0;
  return createVNode(PanelBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "rowNum": MONTH_ROW_COUNT,
    "colNum": MONTH_COL_COUNT,
    "baseDate": baseMonth,
    "getCellNode": getCellNode,
    "getCellText": (date) => locale.monthFormat ? formatValue(date, {
      locale,
      format: locale.monthFormat,
      generateConfig: generateConfig2
    }) : monthsLocale[generateConfig2.getMonth(date)],
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addMonth,
    "titleCell": (date) => formatValue(date, {
      locale,
      format: "YYYY-MM",
      generateConfig: generateConfig2
    })
  }), null);
}
MonthBody.displayName = "MonthBody";
MonthBody.inheritAttrs = false;
var MonthBody_default = MonthBody;

// node_modules/ant-design-vue/es/vc-picker/panels/MonthPanel/index.js
function MonthPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    onViewDateChange,
    generateConfig: generateConfig2,
    value,
    viewDate,
    onPanelChange,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-month-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff * MONTH_COL_COUNT), "key");
      },
      onEnter: () => {
        onPanelChange("date", value || viewDate);
      }
    })
  };
  const onYearChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(MonthHeader_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": () => {
      onYearChange(-1);
    },
    "onNextYear": () => {
      onYearChange(1);
    },
    "onYearClick": () => {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(MonthBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": (date) => {
      onSelect(date, "mouse");
      onPanelChange("date", date);
    }
  }), null)]);
}
MonthPanel.displayName = "MonthPanel";
MonthPanel.inheritAttrs = false;
var MonthPanel_default = MonthPanel;

// node_modules/ant-design-vue/es/vc-picker/panels/QuarterPanel/QuarterHeader.js
function QuarterHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale,
    viewDate,
    onNextYear,
    onPrevYear,
    onYearClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  return createVNode(Header_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: () => [createVNode("button", {
      "type": "button",
      "onClick": onYearClick,
      "class": `${prefixCls}-year-btn`
    }, [formatValue(viewDate, {
      locale,
      format: locale.yearFormat,
      generateConfig: generateConfig2
    })])]
  });
}
QuarterHeader.displayName = "QuarterHeader";
QuarterHeader.inheritAttrs = false;
var QuarterHeader_default = QuarterHeader;

// node_modules/ant-design-vue/es/vc-picker/panels/QuarterPanel/QuarterBody.js
var QUARTER_COL_COUNT = 4;
var QUARTER_ROW_COUNT = 1;
function QuarterBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    locale,
    value,
    viewDate,
    generateConfig: generateConfig2
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const cellPrefixCls = `${prefixCls}-cell`;
  const getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: (current, target) => isSameQuarter(generateConfig2, current, target),
    isInView: () => true,
    offsetCell: (date, offset) => generateConfig2.addMonth(date, offset * 3)
  });
  const baseQuarter = generateConfig2.setDate(generateConfig2.setMonth(viewDate, 0), 1);
  return createVNode(PanelBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "rowNum": QUARTER_ROW_COUNT,
    "colNum": QUARTER_COL_COUNT,
    "baseDate": baseQuarter,
    "getCellText": (date) => formatValue(date, {
      locale,
      format: locale.quarterFormat || "[Q]Q",
      generateConfig: generateConfig2
    }),
    "getCellClassName": getCellClassName,
    "getCellDate": (date, offset) => generateConfig2.addMonth(date, offset * 3),
    "titleCell": (date) => formatValue(date, {
      locale,
      format: "YYYY-[Q]Q",
      generateConfig: generateConfig2
    })
  }), null);
}
QuarterBody.displayName = "QuarterBody";
QuarterBody.inheritAttrs = false;
var QuarterBody_default = QuarterBody;

// node_modules/ant-design-vue/es/vc-picker/panels/QuarterPanel/index.js
function QuarterPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    onViewDateChange,
    generateConfig: generateConfig2,
    value,
    viewDate,
    onPanelChange,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-quarter-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff * 3), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      }
    })
  };
  const onYearChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(QuarterHeader_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": () => {
      onYearChange(-1);
    },
    "onNextYear": () => {
      onYearChange(1);
    },
    "onYearClick": () => {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(QuarterBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": (date) => {
      onSelect(date, "mouse");
    }
  }), null)]);
}
QuarterPanel.displayName = "QuarterPanel";
QuarterPanel.inheritAttrs = false;
var QuarterPanel_default = QuarterPanel;

// node_modules/ant-design-vue/es/vc-picker/panels/YearPanel/YearHeader.js
function YearHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    viewDate,
    onPrevDecade,
    onNextDecade,
    onDecadeClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  const endYear = startYear + YEAR_DECADE_COUNT - 1;
  return createVNode(Header_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecade,
    "onSuperNext": onNextDecade
  }), {
    default: () => [createVNode("button", {
      "type": "button",
      "onClick": onDecadeClick,
      "class": `${prefixCls}-decade-btn`
    }, [startYear, createTextVNode("-"), endYear])]
  });
}
YearHeader.displayName = "YearHeader";
YearHeader.inheritAttrs = false;
var YearHeader_default = YearHeader;

// node_modules/ant-design-vue/es/vc-picker/panels/YearPanel/YearBody.js
var YEAR_COL_COUNT = 3;
var YEAR_ROW_COUNT = 4;
function YearBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    value,
    viewDate,
    locale,
    generateConfig: generateConfig2
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const yearPrefixCls = `${prefixCls}-cell`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  const endYear = startYear + YEAR_DECADE_COUNT - 1;
  const baseYear = generateConfig2.setYear(viewDate, startYear - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2));
  const isInView = (date) => {
    const currentYearNumber = generateConfig2.getYear(date);
    return startYear <= currentYearNumber && currentYearNumber <= endYear;
  };
  const getCellClassName = useCellClassName({
    cellPrefixCls: yearPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: (current, target) => isSameYear(generateConfig2, current, target),
    isInView,
    offsetCell: (date, offset) => generateConfig2.addYear(date, offset)
  });
  return createVNode(PanelBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "rowNum": YEAR_ROW_COUNT,
    "colNum": YEAR_COL_COUNT,
    "baseDate": baseYear,
    "getCellText": generateConfig2.getYear,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addYear,
    "titleCell": (date) => formatValue(date, {
      locale,
      format: "YYYY",
      generateConfig: generateConfig2
    })
  }), null);
}
YearBody.displayName = "YearBody";
YearBody.inheritAttrs = false;
var YearBody_default = YearBody;

// node_modules/ant-design-vue/es/vc-picker/panels/YearPanel/index.js
var YEAR_DECADE_COUNT = 10;
function YearPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    onViewDateChange,
    generateConfig: generateConfig2,
    value,
    viewDate,
    sourceMode,
    onSelect,
    onPanelChange
  } = props2;
  const panelPrefixCls = `${prefixCls}-year-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_DECADE_COUNT), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_COL_COUNT), "key");
      },
      onEnter: () => {
        onPanelChange(sourceMode === "date" ? "date" : "month", value || viewDate);
      }
    })
  };
  const onDecadeChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff * 10);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(YearHeader_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevDecade": () => {
      onDecadeChange(-1);
    },
    "onNextDecade": () => {
      onDecadeChange(1);
    },
    "onDecadeClick": () => {
      onPanelChange("decade", viewDate);
    }
  }), null), createVNode(YearBody_default, _objectSpread2(_objectSpread2({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": (date) => {
      onPanelChange(sourceMode === "date" ? "date" : "month", date);
      onSelect(date, "mouse");
    }
  }), null)]);
}
YearPanel.displayName = "YearPanel";
YearPanel.inheritAttrs = false;
var YearPanel_default = YearPanel;

// node_modules/ant-design-vue/es/vc-picker/utils/getExtraFooter.js
function getExtraFooter(prefixCls, mode, renderExtraFooter) {
  if (!renderExtraFooter) {
    return null;
  }
  return createVNode("div", {
    "class": `${prefixCls}-footer-extra`
  }, [renderExtraFooter(mode)]);
}

// node_modules/ant-design-vue/es/vc-picker/utils/getRanges.js
function getRanges(_ref) {
  let {
    prefixCls,
    components = {},
    needConfirmButton,
    onNow,
    onOk,
    okDisabled,
    showNow,
    locale
  } = _ref;
  let presetNode;
  let okNode;
  if (needConfirmButton) {
    const Button = components.button || "button";
    if (onNow && showNow !== false) {
      presetNode = createVNode("li", {
        "class": `${prefixCls}-now`
      }, [createVNode("a", {
        "class": `${prefixCls}-now-btn`,
        "onClick": onNow
      }, [locale.now])]);
    }
    okNode = needConfirmButton && createVNode("li", {
      "class": `${prefixCls}-ok`
    }, [createVNode(Button, {
      "disabled": okDisabled,
      "onClick": (e) => {
        e.stopPropagation();
        onOk && onOk();
      }
    }, {
      default: () => [locale.ok]
    })]);
  }
  if (!presetNode && !okNode) {
    return null;
  }
  return createVNode("ul", {
    "class": `${prefixCls}-ranges`
  }, [presetNode, okNode]);
}

// node_modules/ant-design-vue/es/vc-picker/PickerPanel.js
function PickerPanel() {
  return defineComponent({
    name: "PickerPanel",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      locale: Object,
      generateConfig: Object,
      value: Object,
      defaultValue: Object,
      pickerValue: Object,
      defaultPickerValue: Object,
      disabledDate: Function,
      mode: String,
      picker: {
        type: String,
        default: "date"
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      showNow: {
        type: Boolean,
        default: void 0
      },
      showTime: [Boolean, Object],
      showToday: Boolean,
      renderExtraFooter: Function,
      dateRender: Function,
      hideHeader: {
        type: Boolean,
        default: void 0
      },
      onSelect: Function,
      onChange: Function,
      onPanelChange: Function,
      onMousedown: Function,
      onPickerValueChange: Function,
      onOk: Function,
      components: Object,
      direction: String,
      hourStep: {
        type: Number,
        default: 1
      },
      minuteStep: {
        type: Number,
        default: 1
      },
      secondStep: {
        type: Number,
        default: 1
      }
    },
    setup(props2, _ref) {
      let {
        attrs
      } = _ref;
      const needConfirmButton = computed(() => props2.picker === "date" && !!props2.showTime || props2.picker === "time");
      const isHourStepValid = computed(() => 24 % props2.hourStep === 0);
      const isMinuteStepValid = computed(() => 60 % props2.minuteStep === 0);
      const isSecondStepValid = computed(() => 60 % props2.secondStep === 0);
      if (true) {
        watchEffect(() => {
          const {
            generateConfig: generateConfig2,
            value,
            hourStep = 1,
            minuteStep = 1,
            secondStep = 1
          } = props2;
          warning(!value || generateConfig2.isValidate(value), "Invalidate date pass to `value`.");
          warning(!value || generateConfig2.isValidate(value), "Invalidate date pass to `defaultValue`.");
          warning(isHourStepValid.value, `\`hourStep\` ${hourStep} is invalid. It should be a factor of 24.`);
          warning(isMinuteStepValid.value, `\`minuteStep\` ${minuteStep} is invalid. It should be a factor of 60.`);
          warning(isSecondStepValid.value, `\`secondStep\` ${secondStep} is invalid. It should be a factor of 60.`);
        });
      }
      const panelContext = useInjectPanel();
      const {
        operationRef,
        onSelect: onContextSelect,
        hideRanges,
        defaultOpenValue
      } = panelContext;
      const {
        inRange,
        panelPosition,
        rangedValue,
        hoverRangedValue
      } = useInjectRange();
      const panelRef = ref({});
      const [mergedValue, setInnerValue] = useMergedState(null, {
        value: toRef(props2, "value"),
        defaultValue: props2.defaultValue,
        postState: (val) => {
          if (!val && (defaultOpenValue === null || defaultOpenValue === void 0 ? void 0 : defaultOpenValue.value) && props2.picker === "time") {
            return defaultOpenValue.value;
          }
          return val;
        }
      });
      const [viewDate, setInnerViewDate] = useMergedState(null, {
        value: toRef(props2, "pickerValue"),
        defaultValue: props2.defaultPickerValue || mergedValue.value,
        postState: (date) => {
          const {
            generateConfig: generateConfig2,
            showTime,
            defaultValue
          } = props2;
          const now2 = generateConfig2.getNow();
          if (!date)
            return now2;
          if (!mergedValue.value && props2.showTime) {
            if (typeof showTime === "object") {
              return setDateTime(generateConfig2, Array.isArray(date) ? date[0] : date, showTime.defaultValue || now2);
            }
            if (defaultValue) {
              return setDateTime(generateConfig2, Array.isArray(date) ? date[0] : date, defaultValue);
            }
            return setDateTime(generateConfig2, Array.isArray(date) ? date[0] : date, now2);
          }
          return date;
        }
      });
      const setViewDate = (date) => {
        setInnerViewDate(date);
        if (props2.onPickerValueChange) {
          props2.onPickerValueChange(date);
        }
      };
      const getInternalNextMode = (nextMode) => {
        const getNextMode = PickerModeMap[props2.picker];
        if (getNextMode) {
          return getNextMode(nextMode);
        }
        return nextMode;
      };
      const [mergedMode, setInnerMode] = useMergedState(() => {
        if (props2.picker === "time") {
          return "time";
        }
        return getInternalNextMode("date");
      }, {
        value: toRef(props2, "mode")
      });
      watch(() => props2.picker, () => {
        setInnerMode(props2.picker);
      });
      const sourceMode = ref(mergedMode.value);
      const setSourceMode = (val) => {
        sourceMode.value = val;
      };
      const onInternalPanelChange = (newMode, viewValue) => {
        const {
          onPanelChange,
          generateConfig: generateConfig2
        } = props2;
        const nextMode = getInternalNextMode(newMode || mergedMode.value);
        setSourceMode(mergedMode.value);
        setInnerMode(nextMode);
        if (onPanelChange && (mergedMode.value !== nextMode || isEqual(generateConfig2, viewDate.value, viewDate.value))) {
          onPanelChange(viewValue, nextMode);
        }
      };
      const triggerSelect = function(date, type) {
        let forceTriggerSelect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const {
          picker,
          generateConfig: generateConfig2,
          onSelect,
          onChange,
          disabledDate
        } = props2;
        if (mergedMode.value === picker || forceTriggerSelect) {
          setInnerValue(date);
          if (onSelect) {
            onSelect(date);
          }
          if (onContextSelect) {
            onContextSelect(date, type);
          }
          if (onChange && !isEqual(generateConfig2, date, mergedValue.value) && !(disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date))) {
            onChange(date);
          }
        }
      };
      const onInternalKeydown = (e) => {
        if (panelRef.value && panelRef.value.onKeydown) {
          if ([KeyCode_default.LEFT, KeyCode_default.RIGHT, KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.PAGE_UP, KeyCode_default.PAGE_DOWN, KeyCode_default.ENTER].includes(e.which)) {
            e.preventDefault();
          }
          return panelRef.value.onKeydown(e);
        }
        {
          warning(false, "Panel not correct handle keyDown event. Please help to fire issue about this.");
          return false;
        }
      };
      const onInternalBlur = (e) => {
        if (panelRef.value && panelRef.value.onBlur) {
          panelRef.value.onBlur(e);
        }
      };
      const onNow = () => {
        const {
          generateConfig: generateConfig2,
          hourStep,
          minuteStep,
          secondStep
        } = props2;
        const now2 = generateConfig2.getNow();
        const lowerBoundTime = getLowerBoundTime(generateConfig2.getHour(now2), generateConfig2.getMinute(now2), generateConfig2.getSecond(now2), isHourStepValid.value ? hourStep : 1, isMinuteStepValid.value ? minuteStep : 1, isSecondStepValid.value ? secondStep : 1);
        const adjustedNow = setTime(
          generateConfig2,
          now2,
          lowerBoundTime[0],
          // hour
          lowerBoundTime[1],
          // minute
          lowerBoundTime[2]
        );
        triggerSelect(adjustedNow, "submit");
      };
      const classString = computed(() => {
        const {
          prefixCls,
          direction
        } = props2;
        return classNames_default(`${prefixCls}-panel`, {
          [`${prefixCls}-panel-has-range`]: rangedValue && rangedValue.value && rangedValue.value[0] && rangedValue.value[1],
          [`${prefixCls}-panel-has-range-hover`]: hoverRangedValue && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1],
          [`${prefixCls}-panel-rtl`]: direction === "rtl"
        });
      });
      useProvidePanel(_extends(_extends({}, panelContext), {
        mode: mergedMode,
        hideHeader: computed(() => {
          var _a2;
          return props2.hideHeader !== void 0 ? props2.hideHeader : (_a2 = panelContext.hideHeader) === null || _a2 === void 0 ? void 0 : _a2.value;
        }),
        hidePrevBtn: computed(() => inRange.value && panelPosition.value === "right"),
        hideNextBtn: computed(() => inRange.value && panelPosition.value === "left")
      }));
      watch(() => props2.value, () => {
        if (props2.value) {
          setInnerViewDate(props2.value);
        }
      });
      return () => {
        const {
          prefixCls = "ant-picker",
          locale,
          generateConfig: generateConfig2,
          disabledDate,
          picker = "date",
          tabindex = 0,
          showNow,
          showTime,
          showToday,
          renderExtraFooter,
          onMousedown,
          onOk,
          components
        } = props2;
        if (operationRef && panelPosition.value !== "right") {
          operationRef.value = {
            onKeydown: onInternalKeydown,
            onClose: () => {
              if (panelRef.value && panelRef.value.onClose) {
                panelRef.value.onClose();
              }
            }
          };
        }
        let panelNode;
        const pickerProps = _extends(_extends(_extends({}, attrs), props2), {
          operationRef: panelRef,
          prefixCls,
          viewDate: viewDate.value,
          value: mergedValue.value,
          onViewDateChange: setViewDate,
          sourceMode: sourceMode.value,
          onPanelChange: onInternalPanelChange,
          disabledDate
        });
        delete pickerProps.onChange;
        delete pickerProps.onSelect;
        switch (mergedMode.value) {
          case "decade":
            panelNode = createVNode(DecadePanel_default, _objectSpread2(_objectSpread2({}, pickerProps), {}, {
              "onSelect": (date, type) => {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }), null);
            break;
          case "year":
            panelNode = createVNode(YearPanel_default, _objectSpread2(_objectSpread2({}, pickerProps), {}, {
              "onSelect": (date, type) => {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }), null);
            break;
          case "month":
            panelNode = createVNode(MonthPanel_default, _objectSpread2(_objectSpread2({}, pickerProps), {}, {
              "onSelect": (date, type) => {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }), null);
            break;
          case "quarter":
            panelNode = createVNode(QuarterPanel_default, _objectSpread2(_objectSpread2({}, pickerProps), {}, {
              "onSelect": (date, type) => {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }), null);
            break;
          case "week":
            panelNode = createVNode(WeekPanel_default, _objectSpread2(_objectSpread2({}, pickerProps), {}, {
              "onSelect": (date, type) => {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }), null);
            break;
          case "time":
            delete pickerProps.showTime;
            panelNode = createVNode(TimePanel_default, _objectSpread2(_objectSpread2(_objectSpread2({}, pickerProps), typeof showTime === "object" ? showTime : null), {}, {
              "onSelect": (date, type) => {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }), null);
            break;
          default:
            if (showTime) {
              panelNode = createVNode(DatetimePanel_default, _objectSpread2(_objectSpread2({}, pickerProps), {}, {
                "onSelect": (date, type) => {
                  setViewDate(date);
                  triggerSelect(date, type);
                }
              }), null);
            } else {
              panelNode = createVNode(DatePanel_default, _objectSpread2(_objectSpread2({}, pickerProps), {}, {
                "onSelect": (date, type) => {
                  setViewDate(date);
                  triggerSelect(date, type);
                }
              }), null);
            }
        }
        let extraFooter;
        let rangesNode;
        if (!(hideRanges === null || hideRanges === void 0 ? void 0 : hideRanges.value)) {
          extraFooter = getExtraFooter(prefixCls, mergedMode.value, renderExtraFooter);
          rangesNode = getRanges({
            prefixCls,
            components,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !mergedValue.value || disabledDate && disabledDate(mergedValue.value),
            locale,
            showNow,
            onNow: needConfirmButton.value && onNow,
            onOk: () => {
              if (mergedValue.value) {
                triggerSelect(mergedValue.value, "submit", true);
                if (onOk) {
                  onOk(mergedValue.value);
                }
              }
            }
          });
        }
        let todayNode;
        if (showToday && mergedMode.value === "date" && picker === "date" && !showTime) {
          const now2 = generateConfig2.getNow();
          const todayCls = `${prefixCls}-today-btn`;
          const disabled = disabledDate && disabledDate(now2);
          todayNode = createVNode("a", {
            "class": classNames_default(todayCls, disabled && `${todayCls}-disabled`),
            "aria-disabled": disabled,
            "onClick": () => {
              if (!disabled) {
                triggerSelect(now2, "mouse", true);
              }
            }
          }, [locale.today]);
        }
        return createVNode("div", {
          "tabindex": tabindex,
          "class": classNames_default(classString.value, attrs.class),
          "style": attrs.style,
          "onKeydown": onInternalKeydown,
          "onBlur": onInternalBlur,
          "onMousedown": onMousedown
        }, [panelNode, extraFooter || rangesNode || todayNode ? createVNode("div", {
          "class": `${prefixCls}-footer`
        }, [extraFooter, rangesNode, todayNode]) : null]);
      };
    }
  });
}
var InterPickerPanel = PickerPanel();
var PickerPanel_default = (props2) => createVNode(InterPickerPanel, props2);

// node_modules/ant-design-vue/es/vc-picker/PickerTrigger.js
var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger(props2, _ref) {
  let {
    slots
  } = _ref;
  const {
    prefixCls,
    popupStyle,
    visible,
    dropdownClassName,
    dropdownAlign,
    transitionName,
    getPopupContainer,
    range,
    popupPlacement,
    direction
  } = useMergeProps(props2);
  const dropdownPrefixCls = `${prefixCls}-dropdown`;
  const getPopupPlacement = () => {
    if (popupPlacement !== void 0) {
      return popupPlacement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  };
  return createVNode(vc_trigger_default, {
    "showAction": [],
    "hideAction": [],
    "popupPlacement": getPopupPlacement(),
    "builtinPlacements": BUILT_IN_PLACEMENTS,
    "prefixCls": dropdownPrefixCls,
    "popupTransitionName": transitionName,
    "popupAlign": dropdownAlign,
    "popupVisible": visible,
    "popupClassName": classNames_default(dropdownClassName, {
      [`${dropdownPrefixCls}-range`]: range,
      [`${dropdownPrefixCls}-rtl`]: direction === "rtl"
    }),
    "popupStyle": popupStyle,
    "getPopupContainer": getPopupContainer
  }, {
    default: slots.default,
    popup: slots.popupElement
  });
}
var PickerTrigger_default = PickerTrigger;

// node_modules/ant-design-vue/es/vc-picker/PresetPanel.js
var PresetPanel_default = defineComponent({
  name: "PresetPanel",
  props: {
    prefixCls: String,
    presets: {
      type: Array,
      default: () => []
    },
    onClick: Function,
    onHover: Function
  },
  setup(props2) {
    return () => {
      if (!props2.presets.length) {
        return null;
      }
      return createVNode("div", {
        "class": `${props2.prefixCls}-presets`
      }, [createVNode("ul", null, [props2.presets.map((_ref, index2) => {
        let {
          label,
          value
        } = _ref;
        return createVNode("li", {
          "key": index2,
          "onClick": (e) => {
            e.stopPropagation();
            props2.onClick(value);
          },
          "onMouseenter": () => {
            var _a2;
            (_a2 = props2.onHover) === null || _a2 === void 0 ? void 0 : _a2.call(props2, value);
          },
          "onMouseleave": () => {
            var _a2;
            (_a2 = props2.onHover) === null || _a2 === void 0 ? void 0 : _a2.call(props2, null);
          }
        }, [label]);
      })])]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-picker/hooks/usePickerInput.js
function usePickerInput(_ref) {
  let {
    open: open2,
    value,
    isClickOutside,
    triggerOpen,
    forwardKeydown,
    onKeydown,
    blurToCancel,
    onSubmit,
    onCancel,
    onFocus,
    onBlur
  } = _ref;
  const typing = shallowRef(false);
  const focused = shallowRef(false);
  const preventBlurRef = shallowRef(false);
  const valueChangedRef = shallowRef(false);
  const preventDefaultRef = shallowRef(false);
  const inputProps = computed(() => ({
    onMousedown: () => {
      typing.value = true;
      triggerOpen(true);
    },
    onKeydown: (e) => {
      const preventDefault = () => {
        preventDefaultRef.value = true;
      };
      onKeydown(e, preventDefault);
      if (preventDefaultRef.value)
        return;
      switch (e.which) {
        case KeyCode_default.ENTER: {
          if (!open2.value) {
            triggerOpen(true);
          } else if (onSubmit() !== false) {
            typing.value = true;
          }
          e.preventDefault();
          return;
        }
        case KeyCode_default.TAB: {
          if (typing.value && open2.value && !e.shiftKey) {
            typing.value = false;
            e.preventDefault();
          } else if (!typing.value && open2.value) {
            if (!forwardKeydown(e) && e.shiftKey) {
              typing.value = true;
              e.preventDefault();
            }
          }
          return;
        }
        case KeyCode_default.ESC: {
          typing.value = true;
          onCancel();
          return;
        }
      }
      if (!open2.value && ![KeyCode_default.SHIFT].includes(e.which)) {
        triggerOpen(true);
      } else if (!typing.value) {
        forwardKeydown(e);
      }
    },
    onFocus: (e) => {
      typing.value = true;
      focused.value = true;
      if (onFocus) {
        onFocus(e);
      }
    },
    onBlur: (e) => {
      if (preventBlurRef.value || !isClickOutside(document.activeElement)) {
        preventBlurRef.value = false;
        return;
      }
      if (blurToCancel.value) {
        setTimeout(() => {
          let {
            activeElement
          } = document;
          while (activeElement && activeElement.shadowRoot) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
          if (isClickOutside(activeElement)) {
            onCancel();
          }
        }, 0);
      } else if (open2.value) {
        triggerOpen(false);
        if (valueChangedRef.value) {
          onSubmit();
        }
      }
      focused.value = false;
      if (onBlur) {
        onBlur(e);
      }
    }
  }));
  watch(open2, () => {
    valueChangedRef.value = false;
  });
  watch(value, () => {
    valueChangedRef.value = true;
  });
  const globalMousedownEvent = shallowRef();
  onMounted(() => {
    globalMousedownEvent.value = addGlobalMousedownEvent((e) => {
      const target = getTargetFromEvent(e);
      if (open2.value) {
        const clickedOutside = isClickOutside(target);
        if (!clickedOutside) {
          preventBlurRef.value = true;
          wrapperRaf(() => {
            preventBlurRef.value = false;
          });
        } else if (!focused.value || clickedOutside) {
          triggerOpen(false);
        }
      }
    });
  });
  onBeforeUnmount(() => {
    globalMousedownEvent.value && globalMousedownEvent.value();
  });
  return [inputProps, {
    focused,
    typing
  }];
}

// node_modules/ant-design-vue/es/vc-picker/hooks/useTextValueMapping.js
function useTextValueMapping(_ref) {
  let {
    valueTexts,
    onTextChange
  } = _ref;
  const text = ref("");
  function triggerTextChange(value) {
    text.value = value;
    onTextChange(value);
  }
  function resetText() {
    text.value = valueTexts.value[0];
  }
  watch(() => [...valueTexts.value], function(cur) {
    let pre = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (cur.join("||") !== pre.join("||") && valueTexts.value.every((valText) => valText !== text.value)) {
      resetText();
    }
  }, {
    immediate: true
  });
  return [text, triggerTextChange, resetText];
}

// node_modules/ant-design-vue/es/vc-picker/hooks/useValueTexts.js
function useValueTexts(value, _ref) {
  let {
    formatList,
    generateConfig: generateConfig2,
    locale
  } = _ref;
  const texts = useMemo(() => {
    if (!value.value) {
      return [[""], ""];
    }
    let firstValueText2 = "";
    const fullValueTexts2 = [];
    for (let i = 0; i < formatList.value.length; i += 1) {
      const format2 = formatList.value[i];
      const formatStr = formatValue(value.value, {
        generateConfig: generateConfig2.value,
        locale: locale.value,
        format: format2
      });
      fullValueTexts2.push(formatStr);
      if (i === 0) {
        firstValueText2 = formatStr;
      }
    }
    return [fullValueTexts2, firstValueText2];
  }, [value, formatList], (next, prev) => prev[0] !== next[0] || !shallowequal_default(prev[1], next[1]));
  const fullValueTexts = computed(() => texts.value[0]);
  const firstValueText = computed(() => texts.value[1]);
  return [fullValueTexts, firstValueText];
}

// node_modules/ant-design-vue/es/vc-picker/hooks/useHoverValue.js
function useHoverValue(valueText, _ref) {
  let {
    formatList,
    generateConfig: generateConfig2,
    locale
  } = _ref;
  const innerValue = ref(null);
  let rafId;
  function setValue(val) {
    let immediately = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    wrapperRaf.cancel(rafId);
    if (immediately) {
      innerValue.value = val;
      return;
    }
    rafId = wrapperRaf(() => {
      innerValue.value = val;
    });
  }
  const [, firstText] = useValueTexts(innerValue, {
    formatList,
    generateConfig: generateConfig2,
    locale
  });
  function onEnter(date) {
    setValue(date);
  }
  function onLeave() {
    let immediately = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    setValue(null, immediately);
  }
  watch(valueText, () => {
    onLeave(true);
  });
  onBeforeUnmount(() => {
    wrapperRaf.cancel(rafId);
  });
  return [firstText, onEnter, onLeave];
}

// node_modules/ant-design-vue/es/vc-picker/hooks/usePresets.js
function usePresets(presets, legacyRanges) {
  return computed(() => {
    if (presets === null || presets === void 0 ? void 0 : presets.value) {
      return presets.value;
    }
    if (legacyRanges === null || legacyRanges === void 0 ? void 0 : legacyRanges.value) {
      warning_default(false, "`ranges` is deprecated. Please use `presets` instead.");
      const rangeLabels = Object.keys(legacyRanges.value);
      return rangeLabels.map((label) => {
        const range = legacyRanges.value[label];
        const newValues = typeof range === "function" ? range() : range;
        return {
          label,
          value: newValues
        };
      });
    }
    return [];
  });
}

// node_modules/ant-design-vue/es/vc-picker/utils/warnUtil.js
function legacyPropsWarning(props2) {
  const {
    picker,
    disabledHours,
    disabledMinutes,
    disabledSeconds
  } = props2;
  if (picker === "time" && (disabledHours || disabledMinutes || disabledSeconds)) {
    warning(false, `'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.`);
  }
}

// node_modules/ant-design-vue/es/vc-picker/Picker.js
function Picker() {
  return defineComponent({
    name: "Picker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle", "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus", "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours", "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "presets", "clearIcon", "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender", "onChange", "onOpenChange", "onPanelChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction", "autocomplete", "showToday", "renderExtraFooter", "dateRender", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions"],
    setup(props2, _ref) {
      let {
        attrs,
        expose
      } = _ref;
      const inputRef = ref(null);
      const presets = computed(() => props2.presets);
      const presetList = usePresets(presets);
      const picker = computed(() => {
        var _a2;
        return (_a2 = props2.picker) !== null && _a2 !== void 0 ? _a2 : "date";
      });
      const needConfirmButton = computed(() => picker.value === "date" && !!props2.showTime || picker.value === "time");
      if (true) {
        legacyPropsWarning(props2);
      }
      const formatList = computed(() => toArray(getDefaultFormat(props2.format, picker.value, props2.showTime, props2.use12Hours)));
      const panelDivRef = ref(null);
      const inputDivRef = ref(null);
      const containerRef = ref(null);
      const [mergedValue, setInnerValue] = useMergedState(null, {
        value: toRef(props2, "value"),
        defaultValue: props2.defaultValue
      });
      const selectedValue = ref(mergedValue.value);
      const setSelectedValue = (val) => {
        selectedValue.value = val;
      };
      const operationRef = ref(null);
      const [mergedOpen, triggerInnerOpen] = useMergedState(false, {
        value: toRef(props2, "open"),
        defaultValue: props2.defaultOpen,
        postState: (postOpen) => props2.disabled ? false : postOpen,
        onChange: (newOpen) => {
          if (props2.onOpenChange) {
            props2.onOpenChange(newOpen);
          }
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      });
      const [valueTexts, firstValueText] = useValueTexts(selectedValue, {
        formatList,
        generateConfig: toRef(props2, "generateConfig"),
        locale: toRef(props2, "locale")
      });
      const [text, triggerTextChange, resetText] = useTextValueMapping({
        valueTexts,
        onTextChange: (newText) => {
          const inputDate = parseValue(newText, {
            locale: props2.locale,
            formatList: formatList.value,
            generateConfig: props2.generateConfig
          });
          if (inputDate && (!props2.disabledDate || !props2.disabledDate(inputDate))) {
            setSelectedValue(inputDate);
          }
        }
      });
      const triggerChange = (newValue) => {
        const {
          onChange,
          generateConfig: generateConfig2,
          locale
        } = props2;
        setSelectedValue(newValue);
        setInnerValue(newValue);
        if (onChange && !isEqual(generateConfig2, mergedValue.value, newValue)) {
          onChange(newValue, newValue ? formatValue(newValue, {
            generateConfig: generateConfig2,
            locale,
            format: formatList.value[0]
          }) : "");
        }
      };
      const triggerOpen = (newOpen) => {
        if (props2.disabled && newOpen) {
          return;
        }
        triggerInnerOpen(newOpen);
      };
      const forwardKeydown = (e) => {
        if (mergedOpen.value && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e);
        }
        {
          warning(false, "Picker not correct forward Keydown operation. Please help to fire issue about this.");
          return false;
        }
      };
      const onInternalMouseup = function() {
        if (props2.onMouseup) {
          props2.onMouseup(...arguments);
        }
        if (inputRef.value) {
          inputRef.value.focus();
          triggerOpen(true);
        }
      };
      const [inputProps, {
        focused,
        typing
      }] = usePickerInput({
        blurToCancel: needConfirmButton,
        open: mergedOpen,
        value: text,
        triggerOpen,
        forwardKeydown,
        isClickOutside: (target) => !elementsContains([panelDivRef.value, inputDivRef.value, containerRef.value], target),
        onSubmit: () => {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !selectedValue.value || // Normal disabled check
            props2.disabledDate && props2.disabledDate(selectedValue.value)
          ) {
            return false;
          }
          triggerChange(selectedValue.value);
          triggerOpen(false);
          resetText();
          return true;
        },
        onCancel: () => {
          triggerOpen(false);
          setSelectedValue(mergedValue.value);
          resetText();
        },
        onKeydown: (e, preventDefault) => {
          var _a2;
          (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e, preventDefault);
        },
        onFocus: (e) => {
          var _a2;
          (_a2 = props2.onFocus) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
        },
        onBlur: (e) => {
          var _a2;
          (_a2 = props2.onBlur) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
        }
      });
      watch([mergedOpen, valueTexts], () => {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!valueTexts.value.length || valueTexts.value[0] === "") {
            triggerTextChange("");
          } else if (firstValueText.value !== text.value) {
            resetText();
          }
        }
      });
      watch(picker, () => {
        if (!mergedOpen.value) {
          resetText();
        }
      });
      watch(mergedValue, () => {
        setSelectedValue(mergedValue.value);
      });
      const [hoverValue, onEnter, onLeave] = useHoverValue(text, {
        formatList,
        generateConfig: toRef(props2, "generateConfig"),
        locale: toRef(props2, "locale")
      });
      const onContextSelect = (date, type) => {
        if (type === "submit" || type !== "key" && !needConfirmButton.value) {
          triggerChange(date);
          triggerOpen(false);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: computed(() => picker.value === "time"),
        onSelect: onContextSelect,
        open: mergedOpen,
        defaultOpenValue: toRef(props2, "defaultOpenValue"),
        onDateMouseenter: onEnter,
        onDateMouseleave: onLeave
      });
      expose({
        focus: () => {
          if (inputRef.value) {
            inputRef.value.focus();
          }
        },
        blur: () => {
          if (inputRef.value) {
            inputRef.value.blur();
          }
        }
      });
      return () => {
        const {
          prefixCls = "rc-picker",
          id,
          tabindex,
          dropdownClassName,
          dropdownAlign,
          popupStyle,
          transitionName,
          generateConfig: generateConfig2,
          locale,
          inputReadOnly,
          allowClear,
          autofocus,
          picker: picker2 = "date",
          defaultOpenValue,
          suffixIcon,
          clearIcon,
          disabled,
          placeholder,
          getPopupContainer,
          panelRender: panelRender2,
          onMousedown,
          onMouseenter,
          onMouseleave,
          onContextmenu,
          onClick,
          onSelect,
          direction,
          autocomplete = "off"
        } = props2;
        const panelProps = _extends(_extends(_extends({}, props2), attrs), {
          class: classNames_default({
            [`${prefixCls}-panel-focused`]: !typing.value
          }),
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        let panelNode = createVNode("div", {
          "class": `${prefixCls}-panel-layout`
        }, [createVNode(PresetPanel_default, {
          "prefixCls": prefixCls,
          "presets": presetList.value,
          "onClick": (nextValue) => {
            triggerChange(nextValue);
            triggerOpen(false);
          }
        }, null), createVNode(PickerPanel_default, _objectSpread2(_objectSpread2({}, panelProps), {}, {
          "generateConfig": generateConfig2,
          "value": selectedValue.value,
          "locale": locale,
          "tabindex": -1,
          "onSelect": (date) => {
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(date);
            setSelectedValue(date);
          },
          "direction": direction,
          "onPanelChange": (viewDate, mode) => {
            const {
              onPanelChange
            } = props2;
            onLeave(true);
            onPanelChange === null || onPanelChange === void 0 ? void 0 : onPanelChange(viewDate, mode);
          }
        }), null)]);
        if (panelRender2) {
          panelNode = panelRender2(panelNode);
        }
        const panel = createVNode("div", {
          "class": `${prefixCls}-panel-container`,
          "ref": panelDivRef,
          "onMousedown": (e) => {
            e.preventDefault();
          }
        }, [panelNode]);
        let suffixNode;
        if (suffixIcon) {
          suffixNode = createVNode("span", {
            "class": `${prefixCls}-suffix`
          }, [suffixIcon]);
        }
        let clearNode;
        if (allowClear && mergedValue.value && !disabled) {
          clearNode = createVNode("span", {
            "onMousedown": (e) => {
              e.preventDefault();
              e.stopPropagation();
            },
            "onMouseup": (e) => {
              e.preventDefault();
              e.stopPropagation();
              triggerChange(null);
              triggerOpen(false);
            },
            "class": `${prefixCls}-clear`,
            "role": "button"
          }, [clearIcon || createVNode("span", {
            "class": `${prefixCls}-clear-btn`
          }, null)]);
        }
        const mergedInputProps = _extends(_extends(_extends(_extends({
          id,
          tabindex,
          disabled,
          readonly: inputReadOnly || typeof formatList.value[0] === "function" || !typing.value,
          value: hoverValue.value || text.value,
          onInput: (e) => {
            triggerTextChange(e.target.value);
          },
          autofocus,
          placeholder,
          ref: inputRef,
          title: text.value
        }, inputProps.value), {
          size: getInputSize(picker2, formatList.value[0], generateConfig2)
        }), getDataOrAriaProps(props2)), {
          autocomplete
        });
        const inputNode = props2.inputRender ? props2.inputRender(mergedInputProps) : createVNode("input", mergedInputProps, null);
        if (true) {
          warning(!defaultOpenValue, "`defaultOpenValue` may confuse user for the current value status. Please use `defaultValue` instead.");
        }
        const popupPlacement = direction === "rtl" ? "bottomRight" : "bottomLeft";
        return createVNode("div", {
          "ref": containerRef,
          "class": classNames_default(prefixCls, attrs.class, {
            [`${prefixCls}-disabled`]: disabled,
            [`${prefixCls}-focused`]: focused.value,
            [`${prefixCls}-rtl`]: direction === "rtl"
          }),
          "style": attrs.style,
          "onMousedown": onMousedown,
          "onMouseup": onInternalMouseup,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "onContextmenu": onContextmenu,
          "onClick": onClick
        }, [createVNode("div", {
          "class": classNames_default(`${prefixCls}-input`, {
            [`${prefixCls}-input-placeholder`]: !!hoverValue.value
          }),
          "ref": inputDivRef
        }, [inputNode, suffixNode, clearNode]), createVNode(PickerTrigger_default, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName,
          "popupPlacement": popupPlacement,
          "direction": direction
        }, {
          default: () => [createVNode("div", {
            "style": {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => panel
        })]);
      };
    }
  });
}
var Picker_default = Picker();

// node_modules/ant-design-vue/es/vc-picker/hooks/useRangeDisabled.js
function useRangeDisabled(_ref, openRecordsRef) {
  let {
    picker,
    locale,
    selectedValue,
    disabledDate,
    disabled,
    generateConfig: generateConfig2
  } = _ref;
  const startDate = computed(() => getValue(selectedValue.value, 0));
  const endDate = computed(() => getValue(selectedValue.value, 1));
  function weekFirstDate(date) {
    return generateConfig2.value.locale.getWeekFirstDate(locale.value.locale, date);
  }
  function monthNumber(date) {
    const year = generateConfig2.value.getYear(date);
    const month = generateConfig2.value.getMonth(date);
    return year * 100 + month;
  }
  function quarterNumber(date) {
    const year = generateConfig2.value.getYear(date);
    const quarter = getQuarter(generateConfig2.value, date);
    return year * 10 + quarter;
  }
  const disabledStartDate = (date) => {
    var _a2;
    if (disabledDate && ((_a2 = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate.value) === null || _a2 === void 0 ? void 0 : _a2.call(disabledDate, date))) {
      return true;
    }
    if (disabled[1] && endDate) {
      return !isSameDate(generateConfig2.value, date, endDate.value) && generateConfig2.value.isAfter(date, endDate.value);
    }
    if (openRecordsRef.value[1] && endDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date) > quarterNumber(endDate.value);
        case "month":
          return monthNumber(date) > monthNumber(endDate.value);
        case "week":
          return weekFirstDate(date) > weekFirstDate(endDate.value);
        default:
          return !isSameDate(generateConfig2.value, date, endDate.value) && generateConfig2.value.isAfter(date, endDate.value);
      }
    }
    return false;
  };
  const disabledEndDate = (date) => {
    var _a2;
    if ((_a2 = disabledDate.value) === null || _a2 === void 0 ? void 0 : _a2.call(disabledDate, date)) {
      return true;
    }
    if (disabled[0] && startDate) {
      return !isSameDate(generateConfig2.value, date, endDate.value) && generateConfig2.value.isAfter(startDate.value, date);
    }
    if (openRecordsRef.value[0] && startDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date) < quarterNumber(startDate.value);
        case "month":
          return monthNumber(date) < monthNumber(startDate.value);
        case "week":
          return weekFirstDate(date) < weekFirstDate(startDate.value);
        default:
          return !isSameDate(generateConfig2.value, date, startDate.value) && generateConfig2.value.isAfter(startDate.value, date);
      }
    }
    return false;
  };
  return [disabledStartDate, disabledEndDate];
}

// node_modules/ant-design-vue/es/vc-picker/hooks/useRangeViewDates.js
function getStartEndDistance(startDate, endDate, picker, generateConfig2) {
  const startNext = getClosingViewDate(startDate, picker, generateConfig2, 1);
  function getDistance(compareFunc) {
    if (compareFunc(startDate, endDate)) {
      return "same";
    }
    if (compareFunc(startNext, endDate)) {
      return "closing";
    }
    return "far";
  }
  switch (picker) {
    case "year":
      return getDistance((start, end) => isSameDecade(generateConfig2, start, end));
    case "quarter":
    case "month":
      return getDistance((start, end) => isSameYear(generateConfig2, start, end));
    default:
      return getDistance((start, end) => isSameMonth(generateConfig2, start, end));
  }
}
function getRangeViewDate(values, index2, picker, generateConfig2) {
  const startDate = getValue(values, 0);
  const endDate = getValue(values, 1);
  if (index2 === 0) {
    return startDate;
  }
  if (startDate && endDate) {
    const distance = getStartEndDistance(startDate, endDate, picker, generateConfig2);
    switch (distance) {
      case "same":
        return startDate;
      case "closing":
        return startDate;
      default:
        return getClosingViewDate(endDate, picker, generateConfig2, -1);
    }
  }
  return startDate;
}
function useRangeViewDates(_ref) {
  let {
    values,
    picker,
    defaultDates,
    generateConfig: generateConfig2
  } = _ref;
  const defaultViewDates = ref([getValue(defaultDates, 0), getValue(defaultDates, 1)]);
  const viewDates = ref(null);
  const startDate = computed(() => getValue(values.value, 0));
  const endDate = computed(() => getValue(values.value, 1));
  const getViewDate = (index2) => {
    if (defaultViewDates.value[index2]) {
      return defaultViewDates.value[index2];
    }
    return getValue(viewDates.value, index2) || getRangeViewDate(values.value, index2, picker.value, generateConfig2.value) || startDate.value || endDate.value || generateConfig2.value.getNow();
  };
  const startViewDate = ref(null);
  const endViewDate = ref(null);
  watchEffect(() => {
    startViewDate.value = getViewDate(0);
    endViewDate.value = getViewDate(1);
  });
  function setViewDate(viewDate, index2) {
    if (viewDate) {
      let newViewDates = updateValues(viewDates.value, viewDate, index2);
      defaultViewDates.value = updateValues(defaultViewDates.value, null, index2) || [null, null];
      const anotherIndex = (index2 + 1) % 2;
      if (!getValue(values.value, anotherIndex)) {
        newViewDates = updateValues(newViewDates, viewDate, anotherIndex);
      }
      viewDates.value = newViewDates;
    } else if (startDate.value || endDate.value) {
      viewDates.value = null;
    }
  }
  return [startViewDate, endViewDate, setViewDate];
}

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/tryOnScopeDispose.js
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/resolveUnref.js
function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/unrefElement.js
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _a2 !== void 0 ? _a2 : plain;
}

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/tryOnMounted.js
function tryOnMounted(fn) {
  let sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/useSupported.js
function useSupported(callback) {
  let sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const isSupported = shallowRef();
  const update = () => isSupported.value = Boolean(callback());
  update();
  tryOnMounted(update, sync);
  return isSupported;
}

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/is.js
var _a;
var isClient = typeof window !== "undefined";
var isIOS = isClient && ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/_configurable.js
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/useResizeObserver.js
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function useResizeObserver(target, callback) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: window2 = defaultWindow
  } = options, observerOptions = __rest5(options, ["window"]);
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported.value && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, {
    immediate: true,
    flush: "post"
  });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/useElementSize.js
function useElementSize(target) {
  let initialSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    width: 0,
    height: 0
  };
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    box = "content-box"
  } = options;
  const width = shallowRef(initialSize.width);
  const height = shallowRef(initialSize.height);
  useResizeObserver(target, (_ref) => {
    let [entry] = _ref;
    const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
    if (boxSize) {
      width.value = boxSize.reduce((acc, _ref2) => {
        let {
          inlineSize
        } = _ref2;
        return acc + inlineSize;
      }, 0);
      height.value = boxSize.reduce((acc, _ref3) => {
        let {
          blockSize
        } = _ref3;
        return acc + blockSize;
      }, 0);
    } else {
      width.value = entry.contentRect.width;
      height.value = entry.contentRect.height;
    }
  }, options);
  watch(() => unrefElement(target), (ele) => {
    width.value = ele ? initialSize.width : 0;
    height.value = ele ? initialSize.height : 0;
  });
  return {
    width,
    height
  };
}

// node_modules/ant-design-vue/es/vc-picker/RangePicker.js
function reorderValues(values, generateConfig2) {
  if (values && values[0] && values[1] && generateConfig2.isAfter(values[0], values[1])) {
    return [values[1], values[0]];
  }
  return values;
}
function canValueTrigger(value, index2, disabled, allowEmpty) {
  if (value) {
    return true;
  }
  if (allowEmpty && allowEmpty[index2]) {
    return true;
  }
  if (disabled[(index2 + 1) % 2]) {
    return true;
  }
  return false;
}
function RangerPicker() {
  return defineComponent({
    name: "RangerPicker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign", "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled", "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours", "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen", "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty", "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode", "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk", "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions", "disabledMinutes", "presets", "prevIcon", "nextIcon", "superPrevIcon", "superNextIcon"],
    setup(props2, _ref) {
      let {
        attrs,
        expose
      } = _ref;
      const needConfirmButton = computed(() => props2.picker === "date" && !!props2.showTime || props2.picker === "time");
      const presets = computed(() => props2.presets);
      const ranges = computed(() => props2.ranges);
      const presetList = usePresets(presets, ranges);
      const openRecordsRef = ref({});
      const containerRef = ref(null);
      const panelDivRef = ref(null);
      const startInputDivRef = ref(null);
      const endInputDivRef = ref(null);
      const separatorRef = ref(null);
      const startInputRef = ref(null);
      const endInputRef = ref(null);
      const arrowRef = ref(null);
      if (true) {
        legacyPropsWarning(props2);
      }
      const formatList = computed(() => toArray(getDefaultFormat(props2.format, props2.picker, props2.showTime, props2.use12Hours)));
      const [mergedActivePickerIndex, setMergedActivePickerIndex] = useMergedState(0, {
        value: toRef(props2, "activePickerIndex")
      });
      const operationRef = ref(null);
      const mergedDisabled = computed(() => {
        const {
          disabled
        } = props2;
        if (Array.isArray(disabled)) {
          return disabled;
        }
        return [disabled || false, disabled || false];
      });
      const [mergedValue, setInnerValue] = useMergedState(null, {
        value: toRef(props2, "value"),
        defaultValue: props2.defaultValue,
        postState: (values) => props2.picker === "time" && !props2.order ? values : reorderValues(values, props2.generateConfig)
      });
      const [startViewDate, endViewDate, setViewDate] = useRangeViewDates({
        values: mergedValue,
        picker: toRef(props2, "picker"),
        defaultDates: props2.defaultPickerValue,
        generateConfig: toRef(props2, "generateConfig")
      });
      const [selectedValue, setSelectedValue] = useMergedState(mergedValue.value, {
        postState: (values) => {
          let postValues = values;
          if (mergedDisabled.value[0] && mergedDisabled.value[1]) {
            return postValues;
          }
          for (let i = 0; i < 2; i += 1) {
            if (mergedDisabled.value[i] && !getValue(postValues, i) && !getValue(props2.allowEmpty, i)) {
              postValues = updateValues(postValues, props2.generateConfig.getNow(), i);
            }
          }
          return postValues;
        }
      });
      const [mergedModes, setInnerModes] = useMergedState([props2.picker, props2.picker], {
        value: toRef(props2, "mode")
      });
      watch(() => props2.picker, () => {
        setInnerModes([props2.picker, props2.picker]);
      });
      const triggerModesChange = (modes, values) => {
        var _a2;
        setInnerModes(modes);
        (_a2 = props2.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, values, modes);
      };
      const [disabledStartDate, disabledEndDate] = useRangeDisabled({
        picker: toRef(props2, "picker"),
        selectedValue,
        locale: toRef(props2, "locale"),
        disabled: mergedDisabled,
        disabledDate: toRef(props2, "disabledDate"),
        generateConfig: toRef(props2, "generateConfig")
      }, openRecordsRef);
      const [mergedOpen, triggerInnerOpen] = useMergedState(false, {
        value: toRef(props2, "open"),
        defaultValue: props2.defaultOpen,
        postState: (postOpen) => mergedDisabled.value[mergedActivePickerIndex.value] ? false : postOpen,
        onChange: (newOpen) => {
          var _a2;
          (_a2 = props2.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, newOpen);
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      });
      const startOpen = computed(() => mergedOpen.value && mergedActivePickerIndex.value === 0);
      const endOpen = computed(() => mergedOpen.value && mergedActivePickerIndex.value === 1);
      const panelLeft = ref(0);
      const arrowLeft = ref(0);
      const popupMinWidth = ref(0);
      const {
        width: containerWidth
      } = useElementSize(containerRef);
      watch([mergedOpen, containerWidth], () => {
        if (!mergedOpen.value && containerRef.value) {
          popupMinWidth.value = containerWidth.value;
        }
      });
      const {
        width: panelDivWidth
      } = useElementSize(panelDivRef);
      const {
        width: arrowWidth
      } = useElementSize(arrowRef);
      const {
        width: startInputDivWidth
      } = useElementSize(startInputDivRef);
      const {
        width: separatorWidth
      } = useElementSize(separatorRef);
      watch([mergedActivePickerIndex, mergedOpen, panelDivWidth, arrowWidth, startInputDivWidth, separatorWidth, () => props2.direction], () => {
        arrowLeft.value = 0;
        if (mergedActivePickerIndex.value) {
          if (startInputDivRef.value && separatorRef.value) {
            arrowLeft.value = startInputDivWidth.value + separatorWidth.value;
            if (panelDivWidth.value && arrowWidth.value && arrowLeft.value > panelDivWidth.value - arrowWidth.value - (props2.direction === "rtl" || arrowRef.value.offsetLeft > arrowLeft.value ? 0 : arrowRef.value.offsetLeft)) {
              panelLeft.value = arrowLeft.value;
            }
          }
        } else if (mergedActivePickerIndex.value === 0) {
          panelLeft.value = 0;
        }
      }, {
        immediate: true
      });
      const triggerRef2 = ref();
      function triggerOpen(newOpen, index2) {
        if (newOpen) {
          clearTimeout(triggerRef2.value);
          openRecordsRef.value[index2] = true;
          setMergedActivePickerIndex(index2);
          triggerInnerOpen(newOpen);
          if (!mergedOpen.value) {
            setViewDate(null, index2);
          }
        } else if (mergedActivePickerIndex.value === index2) {
          triggerInnerOpen(newOpen);
          const openRecords = openRecordsRef.value;
          triggerRef2.value = setTimeout(() => {
            if (openRecords === openRecordsRef.value) {
              openRecordsRef.value = {};
            }
          });
        }
      }
      function triggerOpenAndFocus(index2) {
        triggerOpen(true, index2);
        setTimeout(() => {
          const inputRef = [startInputRef, endInputRef][index2];
          if (inputRef.value) {
            inputRef.value.focus();
          }
        }, 0);
      }
      function triggerChange(newValue, sourceIndex) {
        let values = newValue;
        let startValue = getValue(values, 0);
        let endValue = getValue(values, 1);
        const {
          generateConfig: generateConfig2,
          locale,
          picker,
          order,
          onCalendarChange,
          allowEmpty,
          onChange,
          showTime
        } = props2;
        if (startValue && endValue && generateConfig2.isAfter(startValue, endValue)) {
          if (
            // WeekPicker only compare week
            picker === "week" && !isSameWeek(generateConfig2, locale.locale, startValue, endValue) || // QuotaPicker only compare week
            picker === "quarter" && !isSameQuarter(generateConfig2, startValue, endValue) || // Other non-TimePicker compare date
            picker !== "week" && picker !== "quarter" && picker !== "time" && !(showTime ? isEqual(generateConfig2, startValue, endValue) : isSameDate(generateConfig2, startValue, endValue))
          ) {
            if (sourceIndex === 0) {
              values = [startValue, null];
              endValue = null;
            } else {
              startValue = null;
              values = [null, endValue];
            }
            openRecordsRef.value = {
              [sourceIndex]: true
            };
          } else if (picker !== "time" || order !== false) {
            values = reorderValues(values, generateConfig2);
          }
        }
        setSelectedValue(values);
        const startStr2 = values && values[0] ? formatValue(values[0], {
          generateConfig: generateConfig2,
          locale,
          format: formatList.value[0]
        }) : "";
        const endStr2 = values && values[1] ? formatValue(values[1], {
          generateConfig: generateConfig2,
          locale,
          format: formatList.value[0]
        }) : "";
        if (onCalendarChange) {
          const info = {
            range: sourceIndex === 0 ? "start" : "end"
          };
          onCalendarChange(values, [startStr2, endStr2], info);
        }
        const canStartValueTrigger = canValueTrigger(startValue, 0, mergedDisabled.value, allowEmpty);
        const canEndValueTrigger = canValueTrigger(endValue, 1, mergedDisabled.value, allowEmpty);
        const canTrigger = values === null || canStartValueTrigger && canEndValueTrigger;
        if (canTrigger) {
          setInnerValue(values);
          if (onChange && (!isEqual(generateConfig2, getValue(mergedValue.value, 0), startValue) || !isEqual(generateConfig2, getValue(mergedValue.value, 1), endValue))) {
            onChange(values, [startStr2, endStr2]);
          }
        }
        let nextOpenIndex = null;
        if (sourceIndex === 0 && !mergedDisabled.value[1]) {
          nextOpenIndex = 1;
        } else if (sourceIndex === 1 && !mergedDisabled.value[0]) {
          nextOpenIndex = 0;
        }
        if (nextOpenIndex !== null && nextOpenIndex !== mergedActivePickerIndex.value && (!openRecordsRef.value[nextOpenIndex] || !getValue(values, nextOpenIndex)) && getValue(values, sourceIndex)) {
          triggerOpenAndFocus(nextOpenIndex);
        } else {
          triggerOpen(false, sourceIndex);
        }
      }
      const forwardKeydown = (e) => {
        if (mergedOpen && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e);
        }
        {
          warning(false, "Picker not correct forward Keydown operation. Please help to fire issue about this.");
          return false;
        }
      };
      const sharedTextHooksProps = {
        formatList,
        generateConfig: toRef(props2, "generateConfig"),
        locale: toRef(props2, "locale")
      };
      const [startValueTexts, firstStartValueText] = useValueTexts(computed(() => getValue(selectedValue.value, 0)), sharedTextHooksProps);
      const [endValueTexts, firstEndValueText] = useValueTexts(computed(() => getValue(selectedValue.value, 1)), sharedTextHooksProps);
      const onTextChange = (newText, index2) => {
        const inputDate = parseValue(newText, {
          locale: props2.locale,
          formatList: formatList.value,
          generateConfig: props2.generateConfig
        });
        const disabledFunc = index2 === 0 ? disabledStartDate : disabledEndDate;
        if (inputDate && !disabledFunc(inputDate)) {
          setSelectedValue(updateValues(selectedValue.value, inputDate, index2));
          setViewDate(inputDate, index2);
        }
      };
      const [startText, triggerStartTextChange, resetStartText] = useTextValueMapping({
        valueTexts: startValueTexts,
        onTextChange: (newText) => onTextChange(newText, 0)
      });
      const [endText, triggerEndTextChange, resetEndText] = useTextValueMapping({
        valueTexts: endValueTexts,
        onTextChange: (newText) => onTextChange(newText, 1)
      });
      const [rangeHoverValue, setRangeHoverValue] = useState(null);
      const [hoverRangedValue, setHoverRangedValue] = useState(null);
      const [startHoverValue, onStartEnter, onStartLeave] = useHoverValue(startText, sharedTextHooksProps);
      const [endHoverValue, onEndEnter, onEndLeave] = useHoverValue(endText, sharedTextHooksProps);
      const onDateMouseenter = (date) => {
        setHoverRangedValue(updateValues(selectedValue.value, date, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartEnter(date);
        } else {
          onEndEnter(date);
        }
      };
      const onDateMouseleave = () => {
        setHoverRangedValue(updateValues(selectedValue.value, null, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartLeave();
        } else {
          onEndLeave();
        }
      };
      const getSharedInputHookProps = (index2, resetText) => ({
        forwardKeydown,
        onBlur: (e) => {
          var _a2;
          (_a2 = props2.onBlur) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
        },
        isClickOutside: (target) => !elementsContains([panelDivRef.value, startInputDivRef.value, endInputDivRef.value, containerRef.value], target),
        onFocus: (e) => {
          var _a2;
          setMergedActivePickerIndex(index2);
          (_a2 = props2.onFocus) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
        },
        triggerOpen: (newOpen) => {
          triggerOpen(newOpen, index2);
        },
        onSubmit: () => {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !selectedValue.value || // Normal disabled check
            props2.disabledDate && props2.disabledDate(selectedValue.value[index2])
          ) {
            return false;
          }
          triggerChange(selectedValue.value, index2);
          resetText();
        },
        onCancel: () => {
          triggerOpen(false, index2);
          setSelectedValue(mergedValue.value);
          resetText();
        }
      });
      const [startInputProps, {
        focused: startFocused,
        typing: startTyping
      }] = usePickerInput(_extends(_extends({}, getSharedInputHookProps(0, resetStartText)), {
        blurToCancel: needConfirmButton,
        open: startOpen,
        value: startText,
        onKeydown: (e, preventDefault) => {
          var _a2;
          (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e, preventDefault);
        }
      }));
      const [endInputProps, {
        focused: endFocused,
        typing: endTyping
      }] = usePickerInput(_extends(_extends({}, getSharedInputHookProps(1, resetEndText)), {
        blurToCancel: needConfirmButton,
        open: endOpen,
        value: endText,
        onKeydown: (e, preventDefault) => {
          var _a2;
          (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e, preventDefault);
        }
      }));
      const onPickerClick = (e) => {
        var _a2;
        (_a2 = props2.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
        if (!mergedOpen.value && !startInputRef.value.contains(e.target) && !endInputRef.value.contains(e.target)) {
          if (!mergedDisabled.value[0]) {
            triggerOpenAndFocus(0);
          } else if (!mergedDisabled.value[1]) {
            triggerOpenAndFocus(1);
          }
        }
      };
      const onPickerMousedown = (e) => {
        var _a2;
        (_a2 = props2.onMousedown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
        if (mergedOpen.value && (startFocused.value || endFocused.value) && !startInputRef.value.contains(e.target) && !endInputRef.value.contains(e.target)) {
          e.preventDefault();
        }
      };
      const startStr = computed(() => {
        var _a2;
        return ((_a2 = mergedValue.value) === null || _a2 === void 0 ? void 0 : _a2[0]) ? formatValue(mergedValue.value[0], {
          locale: props2.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props2.generateConfig
        }) : "";
      });
      const endStr = computed(() => {
        var _a2;
        return ((_a2 = mergedValue.value) === null || _a2 === void 0 ? void 0 : _a2[1]) ? formatValue(mergedValue.value[1], {
          locale: props2.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props2.generateConfig
        }) : "";
      });
      watch([mergedOpen, startValueTexts, endValueTexts], () => {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!startValueTexts.value.length || startValueTexts.value[0] === "") {
            triggerStartTextChange("");
          } else if (firstStartValueText.value !== startText.value) {
            resetStartText();
          }
          if (!endValueTexts.value.length || endValueTexts.value[0] === "") {
            triggerEndTextChange("");
          } else if (firstEndValueText.value !== endText.value) {
            resetEndText();
          }
        }
      });
      watch([startStr, endStr], () => {
        setSelectedValue(mergedValue.value);
      });
      if (true) {
        watchEffect(() => {
          const {
            value,
            disabled
          } = props2;
          if (value && Array.isArray(disabled) && (getValue(disabled, 0) && !getValue(value, 0) || getValue(disabled, 1) && !getValue(value, 1))) {
            warning(false, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
          }
        });
      }
      expose({
        focus: () => {
          if (startInputRef.value) {
            startInputRef.value.focus();
          }
        },
        blur: () => {
          if (startInputRef.value) {
            startInputRef.value.blur();
          }
          if (endInputRef.value) {
            endInputRef.value.blur();
          }
        }
      });
      const panelHoverRangedValue = computed(() => {
        if (mergedOpen.value && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1] && props2.generateConfig.isAfter(hoverRangedValue.value[1], hoverRangedValue.value[0])) {
          return hoverRangedValue.value;
        } else {
          return null;
        }
      });
      function renderPanel() {
        let panelPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        let panelProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          generateConfig: generateConfig2,
          showTime,
          dateRender,
          direction,
          disabledTime,
          prefixCls,
          locale
        } = props2;
        let panelShowTime = showTime;
        if (showTime && typeof showTime === "object" && showTime.defaultValue) {
          const timeDefaultValues = showTime.defaultValue;
          panelShowTime = _extends(_extends({}, showTime), {
            defaultValue: getValue(timeDefaultValues, mergedActivePickerIndex.value) || void 0
          });
        }
        let panelDateRender = null;
        if (dateRender) {
          panelDateRender = (_ref2) => {
            let {
              current: date,
              today
            } = _ref2;
            return dateRender({
              current: date,
              today,
              info: {
                range: mergedActivePickerIndex.value ? "end" : "start"
              }
            });
          };
        }
        return createVNode(RangeContextProvider, {
          "value": {
            inRange: true,
            panelPosition,
            rangedValue: rangeHoverValue.value || selectedValue.value,
            hoverRangedValue: panelHoverRangedValue.value
          }
        }, {
          default: () => [createVNode(PickerPanel_default, _objectSpread2(_objectSpread2(_objectSpread2({}, props2), panelProps), {}, {
            "dateRender": panelDateRender,
            "showTime": panelShowTime,
            "mode": mergedModes.value[mergedActivePickerIndex.value],
            "generateConfig": generateConfig2,
            "style": void 0,
            "direction": direction,
            "disabledDate": mergedActivePickerIndex.value === 0 ? disabledStartDate : disabledEndDate,
            "disabledTime": (date) => {
              if (disabledTime) {
                return disabledTime(date, mergedActivePickerIndex.value === 0 ? "start" : "end");
              }
              return false;
            },
            "class": classNames_default({
              [`${prefixCls}-panel-focused`]: mergedActivePickerIndex.value === 0 ? !startTyping.value : !endTyping.value
            }),
            "value": getValue(selectedValue.value, mergedActivePickerIndex.value),
            "locale": locale,
            "tabIndex": -1,
            "onPanelChange": (date, newMode) => {
              if (mergedActivePickerIndex.value === 0) {
                onStartLeave(true);
              }
              if (mergedActivePickerIndex.value === 1) {
                onEndLeave(true);
              }
              triggerModesChange(updateValues(mergedModes.value, newMode, mergedActivePickerIndex.value), updateValues(selectedValue.value, date, mergedActivePickerIndex.value));
              let viewDate = date;
              if (panelPosition === "right" && mergedModes.value[mergedActivePickerIndex.value] === newMode) {
                viewDate = getClosingViewDate(viewDate, newMode, generateConfig2, -1);
              }
              setViewDate(viewDate, mergedActivePickerIndex.value);
            },
            "onOk": null,
            "onSelect": void 0,
            "onChange": void 0,
            "defaultValue": mergedActivePickerIndex.value === 0 ? getValue(selectedValue.value, 1) : getValue(selectedValue.value, 0)
          }), null)]
        });
      }
      const onContextSelect = (date, type) => {
        const values = updateValues(selectedValue.value, date, mergedActivePickerIndex.value);
        if (type === "submit" || type !== "key" && !needConfirmButton.value) {
          triggerChange(values, mergedActivePickerIndex.value);
          if (mergedActivePickerIndex.value === 0) {
            onStartLeave();
          } else {
            onEndLeave();
          }
        } else {
          setSelectedValue(values);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: computed(() => props2.picker === "time"),
        onDateMouseenter,
        onDateMouseleave,
        hideRanges: computed(() => true),
        onSelect: onContextSelect,
        open: mergedOpen
      });
      return () => {
        const {
          prefixCls = "rc-picker",
          id,
          popupStyle,
          dropdownClassName,
          transitionName,
          dropdownAlign,
          getPopupContainer,
          generateConfig: generateConfig2,
          locale,
          placeholder,
          autofocus,
          picker = "date",
          showTime,
          separator = "~",
          disabledDate,
          panelRender: panelRender2,
          allowClear,
          suffixIcon,
          clearIcon,
          inputReadOnly,
          renderExtraFooter,
          onMouseenter,
          onMouseleave,
          onMouseup,
          onOk,
          components,
          direction,
          autocomplete = "off"
        } = props2;
        const arrowPositionStyle = direction === "rtl" ? {
          right: `${arrowLeft.value}px`
        } : {
          left: `${arrowLeft.value}px`
        };
        function renderPanels() {
          let panels;
          const extraNode = getExtraFooter(prefixCls, mergedModes.value[mergedActivePickerIndex.value], renderExtraFooter);
          const rangesNode = getRanges({
            prefixCls,
            components,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !getValue(selectedValue.value, mergedActivePickerIndex.value) || disabledDate && disabledDate(selectedValue.value[mergedActivePickerIndex.value]),
            locale,
            onOk: () => {
              if (getValue(selectedValue.value, mergedActivePickerIndex.value)) {
                triggerChange(selectedValue.value, mergedActivePickerIndex.value);
                if (onOk) {
                  onOk(selectedValue.value);
                }
              }
            }
          });
          if (picker !== "time" && !showTime) {
            const viewDate = mergedActivePickerIndex.value === 0 ? startViewDate.value : endViewDate.value;
            const nextViewDate = getClosingViewDate(viewDate, picker, generateConfig2);
            const currentMode = mergedModes.value[mergedActivePickerIndex.value];
            const showDoublePanel = currentMode === picker;
            const leftPanel = renderPanel(showDoublePanel ? "left" : false, {
              pickerValue: viewDate,
              onPickerValueChange: (newViewDate) => {
                setViewDate(newViewDate, mergedActivePickerIndex.value);
              }
            });
            const rightPanel = renderPanel("right", {
              pickerValue: nextViewDate,
              onPickerValueChange: (newViewDate) => {
                setViewDate(getClosingViewDate(newViewDate, picker, generateConfig2, -1), mergedActivePickerIndex.value);
              }
            });
            if (direction === "rtl") {
              panels = createVNode(Fragment, null, [rightPanel, showDoublePanel && leftPanel]);
            } else {
              panels = createVNode(Fragment, null, [leftPanel, showDoublePanel && rightPanel]);
            }
          } else {
            panels = renderPanel();
          }
          let mergedNodes = createVNode("div", {
            "class": `${prefixCls}-panel-layout`
          }, [createVNode(PresetPanel_default, {
            "prefixCls": prefixCls,
            "presets": presetList.value,
            "onClick": (nextValue) => {
              triggerChange(nextValue, null);
              triggerOpen(false, mergedActivePickerIndex.value);
            },
            "onHover": (hoverValue) => {
              setRangeHoverValue(hoverValue);
            }
          }, null), createVNode("div", null, [createVNode("div", {
            "class": `${prefixCls}-panels`
          }, [panels]), (extraNode || rangesNode) && createVNode("div", {
            "class": `${prefixCls}-footer`
          }, [extraNode, rangesNode])])]);
          if (panelRender2) {
            mergedNodes = panelRender2(mergedNodes);
          }
          return createVNode("div", {
            "class": `${prefixCls}-panel-container`,
            "style": {
              marginLeft: `${panelLeft.value}px`
            },
            "ref": panelDivRef,
            "onMousedown": (e) => {
              e.preventDefault();
            }
          }, [mergedNodes]);
        }
        const rangePanel = createVNode("div", {
          "class": classNames_default(`${prefixCls}-range-wrapper`, `${prefixCls}-${picker}-range-wrapper`),
          "style": {
            minWidth: `${popupMinWidth.value}px`
          }
        }, [createVNode("div", {
          "ref": arrowRef,
          "class": `${prefixCls}-range-arrow`,
          "style": arrowPositionStyle
        }, null), renderPanels()]);
        let suffixNode;
        if (suffixIcon) {
          suffixNode = createVNode("span", {
            "class": `${prefixCls}-suffix`
          }, [suffixIcon]);
        }
        let clearNode;
        if (allowClear && (getValue(mergedValue.value, 0) && !mergedDisabled.value[0] || getValue(mergedValue.value, 1) && !mergedDisabled.value[1])) {
          clearNode = createVNode("span", {
            "onMousedown": (e) => {
              e.preventDefault();
              e.stopPropagation();
            },
            "onMouseup": (e) => {
              e.preventDefault();
              e.stopPropagation();
              let values = mergedValue.value;
              if (!mergedDisabled.value[0]) {
                values = updateValues(values, null, 0);
              }
              if (!mergedDisabled.value[1]) {
                values = updateValues(values, null, 1);
              }
              triggerChange(values, null);
              triggerOpen(false, mergedActivePickerIndex.value);
            },
            "class": `${prefixCls}-clear`
          }, [clearIcon || createVNode("span", {
            "class": `${prefixCls}-clear-btn`
          }, null)]);
        }
        const inputSharedProps = {
          size: getInputSize(picker, formatList.value[0], generateConfig2)
        };
        let activeBarLeft = 0;
        let activeBarWidth = 0;
        if (startInputDivRef.value && endInputDivRef.value && separatorRef.value) {
          if (mergedActivePickerIndex.value === 0) {
            activeBarWidth = startInputDivRef.value.offsetWidth;
          } else {
            activeBarLeft = arrowLeft.value;
            activeBarWidth = endInputDivRef.value.offsetWidth;
          }
        }
        const activeBarPositionStyle = direction === "rtl" ? {
          right: `${activeBarLeft}px`
        } : {
          left: `${activeBarLeft}px`
        };
        return createVNode("div", _objectSpread2({
          "ref": containerRef,
          "class": classNames_default(prefixCls, `${prefixCls}-range`, attrs.class, {
            [`${prefixCls}-disabled`]: mergedDisabled.value[0] && mergedDisabled.value[1],
            [`${prefixCls}-focused`]: mergedActivePickerIndex.value === 0 ? startFocused.value : endFocused.value,
            [`${prefixCls}-rtl`]: direction === "rtl"
          }),
          "style": attrs.style,
          "onClick": onPickerClick,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "onMousedown": onPickerMousedown,
          "onMouseup": onMouseup
        }, getDataOrAriaProps(props2)), [createVNode("div", {
          "class": classNames_default(`${prefixCls}-input`, {
            [`${prefixCls}-input-active`]: mergedActivePickerIndex.value === 0,
            [`${prefixCls}-input-placeholder`]: !!startHoverValue.value
          }),
          "ref": startInputDivRef
        }, [createVNode("input", _objectSpread2(_objectSpread2(_objectSpread2({
          "id": id,
          "disabled": mergedDisabled.value[0],
          "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !startTyping.value,
          "value": startHoverValue.value || startText.value,
          "onInput": (e) => {
            triggerStartTextChange(e.target.value);
          },
          "autofocus": autofocus,
          "placeholder": getValue(placeholder, 0) || "",
          "ref": startInputRef
        }, startInputProps.value), inputSharedProps), {}, {
          "autocomplete": autocomplete
        }), null)]), createVNode("div", {
          "class": `${prefixCls}-range-separator`,
          "ref": separatorRef
        }, [separator]), createVNode("div", {
          "class": classNames_default(`${prefixCls}-input`, {
            [`${prefixCls}-input-active`]: mergedActivePickerIndex.value === 1,
            [`${prefixCls}-input-placeholder`]: !!endHoverValue.value
          }),
          "ref": endInputDivRef
        }, [createVNode("input", _objectSpread2(_objectSpread2(_objectSpread2({
          "disabled": mergedDisabled.value[1],
          "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !endTyping.value,
          "value": endHoverValue.value || endText.value,
          "onInput": (e) => {
            triggerEndTextChange(e.target.value);
          },
          "placeholder": getValue(placeholder, 1) || "",
          "ref": endInputRef
        }, endInputProps.value), inputSharedProps), {}, {
          "autocomplete": autocomplete
        }), null)]), createVNode("div", {
          "class": `${prefixCls}-active-bar`,
          "style": _extends(_extends({}, activeBarPositionStyle), {
            width: `${activeBarWidth}px`,
            position: "absolute"
          })
        }, null), suffixNode, clearNode, createVNode(PickerTrigger_default, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName,
          "range": true,
          "direction": direction
        }, {
          default: () => [createVNode("div", {
            "style": {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => rangePanel
        })]);
      };
    }
  });
}
var InterRangerPicker = RangerPicker();
var RangePicker_default = InterRangerPicker;

// node_modules/ant-design-vue/es/vc-picker/index.js
var vc_picker_default = Picker_default;

// node_modules/ant-design-vue/es/calendar/Header.js
var YearSelectOffset = 10;
var YearSelectTotal = 20;
function YearSelect(props2) {
  const {
    fullscreen,
    validRange,
    generateConfig: generateConfig2,
    locale,
    prefixCls,
    value,
    onChange,
    divRef
  } = props2;
  const year = generateConfig2.getYear(value || generateConfig2.getNow());
  let start = year - YearSelectOffset;
  let end = start + YearSelectTotal;
  if (validRange) {
    start = generateConfig2.getYear(validRange[0]);
    end = generateConfig2.getYear(validRange[1]) + 1;
  }
  const suffix = locale && locale.year === "年" ? "年" : "";
  const options = [];
  for (let index2 = start; index2 < end; index2++) {
    options.push({
      label: `${index2}${suffix}`,
      value: index2
    });
  }
  return createVNode(select_default, {
    "size": fullscreen ? void 0 : "small",
    "options": options,
    "value": year,
    "class": `${prefixCls}-year-select`,
    "onChange": (numYear) => {
      let newDate = generateConfig2.setYear(value, numYear);
      if (validRange) {
        const [startDate, endDate] = validRange;
        const newYear = generateConfig2.getYear(newDate);
        const newMonth = generateConfig2.getMonth(newDate);
        if (newYear === generateConfig2.getYear(endDate) && newMonth > generateConfig2.getMonth(endDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(endDate));
        }
        if (newYear === generateConfig2.getYear(startDate) && newMonth < generateConfig2.getMonth(startDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(startDate));
        }
      }
      onChange(newDate);
    },
    "getPopupContainer": () => divRef.value
  }, null);
}
YearSelect.inheritAttrs = false;
function MonthSelect(props2) {
  const {
    prefixCls,
    fullscreen,
    validRange,
    value,
    generateConfig: generateConfig2,
    locale,
    onChange,
    divRef
  } = props2;
  const month = generateConfig2.getMonth(value || generateConfig2.getNow());
  let start = 0;
  let end = 11;
  if (validRange) {
    const [rangeStart, rangeEnd] = validRange;
    const currentYear = generateConfig2.getYear(value);
    if (generateConfig2.getYear(rangeEnd) === currentYear) {
      end = generateConfig2.getMonth(rangeEnd);
    }
    if (generateConfig2.getYear(rangeStart) === currentYear) {
      start = generateConfig2.getMonth(rangeStart);
    }
  }
  const months = locale.shortMonths || generateConfig2.locale.getShortMonths(locale.locale);
  const options = [];
  for (let index2 = start; index2 <= end; index2 += 1) {
    options.push({
      label: months[index2],
      value: index2
    });
  }
  return createVNode(select_default, {
    "size": fullscreen ? void 0 : "small",
    "class": `${prefixCls}-month-select`,
    "value": month,
    "options": options,
    "onChange": (newMonth) => {
      onChange(generateConfig2.setMonth(value, newMonth));
    },
    "getPopupContainer": () => divRef.value
  }, null);
}
MonthSelect.inheritAttrs = false;
function ModeSwitch(props2) {
  const {
    prefixCls,
    locale,
    mode,
    fullscreen,
    onModeChange
  } = props2;
  return createVNode(Group_default, {
    "onChange": (_ref) => {
      let {
        target: {
          value
        }
      } = _ref;
      onModeChange(value);
    },
    "value": mode,
    "size": fullscreen ? void 0 : "small",
    "class": `${prefixCls}-mode-switch`
  }, {
    default: () => [createVNode(RadioButton_default, {
      "value": "month"
    }, {
      default: () => [locale.month]
    }), createVNode(RadioButton_default, {
      "value": "year"
    }, {
      default: () => [locale.year]
    })]
  });
}
ModeSwitch.inheritAttrs = false;
var Header_default2 = defineComponent({
  name: "CalendarHeader",
  inheritAttrs: false,
  props: ["mode", "prefixCls", "value", "validRange", "generateConfig", "locale", "mode", "fullscreen"],
  setup(_props, _ref2) {
    let {
      attrs
    } = _ref2;
    const divRef = ref(null);
    const formItemInputContext = FormItemInputContext.useInject();
    FormItemInputContext.useProvide(formItemInputContext, {
      isFormItemInput: false
    });
    return () => {
      const props2 = _extends(_extends({}, _props), attrs);
      const {
        prefixCls,
        fullscreen,
        mode,
        onChange,
        onModeChange
      } = props2;
      const sharedProps = _extends(_extends({}, props2), {
        fullscreen,
        divRef
      });
      return createVNode("div", {
        "class": `${prefixCls}-header`,
        "ref": divRef
      }, [createVNode(YearSelect, _objectSpread2(_objectSpread2({}, sharedProps), {}, {
        "onChange": (v) => {
          onChange(v, "year");
        }
      }), null), mode === "month" && createVNode(MonthSelect, _objectSpread2(_objectSpread2({}, sharedProps), {}, {
        "onChange": (v) => {
          onChange(v, "month");
        }
      }), null), createVNode(ModeSwitch, _objectSpread2(_objectSpread2({}, sharedProps), {}, {
        "onModeChange": onModeChange
      }), null)]);
    };
  }
});

// node_modules/ant-design-vue/es/date-picker/style/index.js
var genPikerPadding = (token, inputHeight, fontSize, paddingHorizontal) => {
  const {
    lineHeight
  } = token;
  const fontHeight = Math.floor(fontSize * lineHeight) + 2;
  const paddingTop = Math.max((inputHeight - fontHeight) / 2, 0);
  const paddingBottom = Math.max(inputHeight - fontHeight - paddingTop, 0);
  return {
    padding: `${paddingTop}px ${paddingHorizontal}px ${paddingBottom}px`
  };
};
var genPickerCellInnerStyle = (token) => {
  const {
    componentCls,
    pickerCellCls,
    pickerCellInnerCls,
    pickerPanelCellHeight,
    motionDurationSlow,
    borderRadiusSM,
    motionDurationMid,
    controlItemBgHover,
    lineWidth,
    lineType,
    colorPrimary,
    controlItemBgActive,
    colorTextLightSolid,
    controlHeightSM,
    pickerDateHoverRangeBorderColor,
    pickerCellBorderGap,
    pickerBasicCellHoverWithRangeColor,
    pickerPanelCellWidth,
    colorTextDisabled,
    colorBgContainerDisabled
  } = token;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: pickerPanelCellHeight,
      transform: "translateY(-50%)",
      transition: `all ${motionDurationSlow}`,
      content: '""'
    },
    // >>> Default
    [pickerCellInnerCls]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: pickerPanelCellHeight,
      height: pickerPanelCellHeight,
      lineHeight: `${pickerPanelCellHeight}px`,
      borderRadius: borderRadiusSM,
      transition: `background ${motionDurationMid}, border ${motionDurationMid}`
    },
    // >>> Hover
    [`&:hover:not(${pickerCellCls}-in-view),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-range-hover-start):not(${pickerCellCls}-range-hover-end)`]: {
      [pickerCellInnerCls]: {
        background: controlItemBgHover
      }
    },
    // >>> Today
    [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${lineWidth}px ${lineType} ${colorPrimary}`,
        borderRadius: borderRadiusSM,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${pickerCellCls}-in-range`]: {
      position: "relative",
      "&::before": {
        background: controlItemBgActive
      }
    },
    // >>> Selected
    [`&-in-view${pickerCellCls}-selected ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-start ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-end ${pickerCellInnerCls}`]: {
      color: colorTextLightSolid,
      background: colorPrimary
    },
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single),
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)`]: {
      "&::before": {
        background: controlItemBgActive
      }
    },
    [`&-in-view${pickerCellCls}-range-start::before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${pickerCellCls}-range-end::before`]: {
      insetInlineEnd: "50%"
    },
    // >>> Range Hover
    [`&-in-view${pickerCellCls}-range-hover-start:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-end:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start-single,
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-end-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-start-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-end-single,
      &-in-view${pickerCellCls}-range-hover:not(${pickerCellCls}-in-range)`]: {
      "&::after": {
        position: "absolute",
        top: "50%",
        zIndex: 0,
        height: controlHeightSM,
        borderTop: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
        borderBottom: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
        transform: "translateY(-50%)",
        transition: `all ${motionDurationSlow}`,
        content: '""'
      }
    },
    // Add space for stash
    [`&-range-hover-start::after,
      &-range-hover-end::after,
      &-range-hover::after`]: {
      insetInlineEnd: 0,
      insetInlineStart: pickerCellBorderGap
    },
    // Hover with in range
    [`&-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-start${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-end${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single)${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)${pickerCellCls}-range-hover-end::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before`]: {
      background: pickerBasicCellHoverWithRangeColor
    },
    // range start border-radius
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single):not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: borderRadiusSM,
      borderEndStartRadius: borderRadiusSM,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single):not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: borderRadiusSM,
      borderEndEndRadius: borderRadiusSM
    },
    [`&-range-hover${pickerCellCls}-range-end::after`]: {
      insetInlineStart: "50%"
    },
    // Edge start
    [`tr > &-in-view${pickerCellCls}-range-hover:first-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-end:first-child::after,
      &-in-view${pickerCellCls}-start${pickerCellCls}-range-hover-edge-start${pickerCellCls}-range-hover-edge-start-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-start:not(${pickerCellCls}-range-hover-edge-start-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-start::after`]: {
      insetInlineStart: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
      borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
      borderStartStartRadius: lineWidth,
      borderEndStartRadius: lineWidth
    },
    // Edge end
    [`tr > &-in-view${pickerCellCls}-range-hover:last-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-start:last-child::after,
      &-in-view${pickerCellCls}-end${pickerCellCls}-range-hover-edge-end${pickerCellCls}-range-hover-edge-end-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-end:not(${pickerCellCls}-range-hover-edge-end-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-end::after`]: {
      insetInlineEnd: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
      borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
      borderStartEndRadius: lineWidth,
      borderEndEndRadius: lineWidth
    },
    // >>> Disabled
    "&-disabled": {
      color: colorTextDisabled,
      pointerEvents: "none",
      [pickerCellInnerCls]: {
        background: "transparent"
      },
      "&::before": {
        background: colorBgContainerDisabled
      }
    },
    [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
      borderColor: colorTextDisabled
    }
  };
};
var genPanelStyle = (token) => {
  const {
    componentCls,
    pickerCellInnerCls,
    pickerYearMonthCellWidth,
    pickerControlIconSize,
    pickerPanelCellWidth,
    paddingSM,
    paddingXS,
    paddingXXS,
    colorBgContainer,
    lineWidth,
    lineType,
    borderRadiusLG,
    colorPrimary,
    colorTextHeading,
    colorSplit,
    pickerControlIconBorderWidth,
    colorIcon,
    pickerTextHeight,
    motionDurationMid,
    colorIconHover,
    fontWeightStrong,
    pickerPanelCellHeight,
    pickerCellPaddingVertical,
    colorTextDisabled,
    colorText,
    fontSize,
    pickerBasicCellHoverWithRangeColor,
    motionDurationSlow,
    pickerPanelWithoutTimeCellHeight,
    pickerQuarterPanelContentHeight,
    colorLink,
    colorLinkActive,
    colorLinkHover,
    pickerDateHoverRangeBorderColor,
    borderRadiusSM,
    colorTextLightSolid,
    borderRadius,
    controlItemBgHover,
    pickerTimePanelColumnHeight,
    pickerTimePanelColumnWidth,
    pickerTimePanelCellHeight,
    controlItemBgActive,
    marginXXS
  } = token;
  const pickerPanelWidth = pickerPanelCellWidth * 7 + paddingSM * 2 + 4;
  const hoverCellFixedDistance = (pickerPanelWidth - paddingXS * 2) / 3 - pickerYearMonthCellWidth - paddingSM;
  return {
    [componentCls]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: colorBgContainer,
        border: `${lineWidth}px ${lineType} ${colorSplit}`,
        borderRadius: borderRadiusLG,
        outline: "none",
        "&-focused": {
          borderColor: colorPrimary
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
        display: "flex",
        flexDirection: "column",
        width: pickerPanelWidth
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${paddingXS}px`,
        color: colorTextHeading,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: colorIcon,
          lineHeight: `${pickerTextHeight}px`,
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${motionDurationMid}`
        },
        "> button": {
          minWidth: "1.6em",
          fontSize,
          "&:hover": {
            color: colorIconHover
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: fontWeightStrong,
          lineHeight: `${pickerTextHeight}px`,
          button: {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: paddingXS
            },
            "&:hover": {
              color: colorPrimary
            }
          }
        }
      },
      // Arrow button
      [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
        position: "relative",
        display: "inline-block",
        width: pickerControlIconSize,
        height: pickerControlIconSize,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: `0 solid currentcolor`,
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      [`&-super-prev-icon,
        &-super-next-icon`]: {
        "&::after": {
          position: "absolute",
          top: Math.ceil(pickerControlIconSize / 2),
          insetInlineStart: Math.ceil(pickerControlIconSize / 2),
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: "0 solid currentcolor",
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      [`&-prev-icon,
        &-super-prev-icon`]: {
        transform: "rotate(-45deg)"
      },
      [`&-next-icon,
        &-super-next-icon`]: {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: pickerPanelCellHeight,
          fontWeight: "normal"
        },
        th: {
          height: pickerPanelCellHeight + pickerCellPaddingVertical * 2,
          color: colorText,
          verticalAlign: "middle"
        }
      },
      "&-cell": _extends({
        padding: `${pickerCellPaddingVertical}px 0`,
        color: colorTextDisabled,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: colorText
        }
      }, genPickerCellInnerStyle(token)),
      // DatePanel only
      [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start ${pickerCellInnerCls},
        &-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}`]: {
        "&::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: -1,
          background: pickerBasicCellHoverWithRangeColor,
          transition: `all ${motionDurationSlow}`,
          content: '""'
        }
      },
      [`&-date-panel
        ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start
        ${pickerCellInnerCls}::after`]: {
        insetInlineEnd: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2,
        insetInlineStart: 0
      },
      [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}::after`]: {
        insetInlineEnd: 0,
        insetInlineStart: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2
      },
      // Hover with range start & end
      [`&-range-hover${componentCls}-range-start::after`]: {
        insetInlineEnd: "50%"
      },
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-content`]: {
          height: pickerPanelWithoutTimeCellHeight * 4
        },
        [pickerCellInnerCls]: {
          padding: `0 ${paddingXS}px`
        }
      },
      "&-quarter-panel": {
        [`${componentCls}-content`]: {
          height: pickerQuarterPanelContentHeight
        }
      },
      // ======================== Footer ========================
      [`&-panel ${componentCls}-footer`]: {
        borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      "&-footer": {
        width: "min-content",
        minWidth: "100%",
        lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
        textAlign: "center",
        "&-extra": {
          padding: `0 ${paddingSM}`,
          lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
          }
        }
      },
      "&-now": {
        textAlign: "start"
      },
      "&-today-btn": {
        color: colorLink,
        "&:hover": {
          color: colorLinkHover
        },
        "&:active": {
          color: colorLinkActive
        },
        [`&${componentCls}-today-btn-disabled`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [pickerCellInnerCls]: {
          padding: `0 ${paddingXS / 2}px`
        },
        [`${componentCls}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-body`]: {
          padding: `0 ${paddingXS}px`
        },
        [pickerCellInnerCls]: {
          width: pickerYearMonthCellWidth
        },
        [`${componentCls}-cell-range-hover-start::after`]: {
          insetInlineStart: hoverCellFixedDistance,
          borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
          borderStartStartRadius: borderRadiusSM,
          borderBottomStartRadius: borderRadiusSM,
          borderStartEndRadius: 0,
          borderBottomEndRadius: 0,
          [`${componentCls}-panel-rtl &`]: {
            insetInlineEnd: hoverCellFixedDistance,
            borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            borderStartStartRadius: 0,
            borderBottomStartRadius: 0,
            borderStartEndRadius: borderRadiusSM,
            borderBottomEndRadius: borderRadiusSM
          }
        },
        [`${componentCls}-cell-range-hover-end::after`]: {
          insetInlineEnd: hoverCellFixedDistance,
          borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius,
          [`${componentCls}-panel-rtl &`]: {
            insetInlineStart: hoverCellFixedDistance,
            borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            borderStartStartRadius: borderRadius,
            borderEndStartRadius: borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel": {
        [`${componentCls}-body`]: {
          padding: `${paddingXS}px ${paddingSM}px`
        },
        // Clear cell style
        [`${componentCls}-cell`]: {
          [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
            background: "transparent !important"
          }
        },
        "&-row": {
          td: {
            transition: `background ${motionDurationMid}`,
            "&:first-child": {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM
            }
          },
          "&:hover td": {
            background: controlItemBgHover
          },
          [`&-selected td,
            &-selected:hover td`]: {
            background: colorPrimary,
            [`&${componentCls}-cell-week`]: {
              color: new TinyColor(colorTextLightSolid).setAlpha(0.5).toHexString()
            },
            [`&${componentCls}-cell-today ${pickerCellInnerCls}::before`]: {
              borderColor: colorTextLightSolid
            },
            [pickerCellInnerCls]: {
              color: colorTextLightSolid
            }
          }
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${componentCls}-body`]: {
          padding: `${paddingXS}px ${paddingSM}px`
        },
        [`${componentCls}-content`]: {
          width: pickerPanelCellWidth * 7,
          th: {
            width: pickerPanelCellWidth
          }
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${componentCls}-time-panel`]: {
          borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
        },
        [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
          transition: `opacity ${motionDurationSlow}`
        },
        // Keyboard
        "&-active": {
          [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        direction: "ltr",
        [`${componentCls}-content`]: {
          display: "flex",
          flex: "auto",
          height: pickerTimePanelColumnHeight
        },
        "&-column": {
          flex: "1 0 auto",
          width: pickerTimePanelColumnWidth,
          margin: `${paddingXXS}px 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${motionDurationMid}`,
          overflowX: "hidden",
          "&::after": {
            display: "block",
            height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
          },
          "&-active": {
            background: new TinyColor(controlItemBgActive).setAlpha(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${componentCls}-time-panel-cell`]: {
              marginInline: marginXXS,
              [`${componentCls}-time-panel-cell-inner`]: {
                display: "block",
                width: pickerTimePanelColumnWidth - 2 * marginXXS,
                height: pickerTimePanelCellHeight,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: (pickerTimePanelColumnWidth - pickerTimePanelCellHeight) / 2,
                color: colorText,
                lineHeight: `${pickerTimePanelCellHeight}px`,
                borderRadius: borderRadiusSM,
                cursor: "pointer",
                transition: `background ${motionDurationMid}`,
                "&:hover": {
                  background: controlItemBgHover
                }
              },
              "&-selected": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  background: controlItemBgActive
                }
              },
              "&-disabled": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  color: colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/39227
      [`&-datetime-panel ${componentCls}-time-panel-column:after`]: {
        height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight + paddingXXS * 2
      }
    }
  };
};
var genPickerStatusStyle = (token) => {
  const {
    componentCls,
    colorBgContainer,
    colorError,
    colorErrorOutline,
    colorWarning,
    colorWarningOutline
  } = token;
  return {
    [componentCls]: {
      [`&-status-error${componentCls}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: colorBgContainer,
          borderColor: colorError
        },
        "&-focused, &:focus": _extends({}, genActiveStyle(merge(token, {
          inputBorderActiveColor: colorError,
          inputBorderHoverColor: colorError,
          controlOutline: colorErrorOutline
        }))),
        [`${componentCls}-active-bar`]: {
          background: colorError
        }
      },
      [`&-status-warning${componentCls}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: colorBgContainer,
          borderColor: colorWarning
        },
        "&-focused, &:focus": _extends({}, genActiveStyle(merge(token, {
          inputBorderActiveColor: colorWarning,
          inputBorderHoverColor: colorWarning,
          controlOutline: colorWarningOutline
        }))),
        [`${componentCls}-active-bar`]: {
          background: colorWarning
        }
      }
    }
  };
};
var genPickerStyle = (token) => {
  const {
    componentCls,
    antCls,
    boxShadowPopoverArrow,
    controlHeight,
    fontSize,
    inputPaddingHorizontal,
    colorBgContainer,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    motionDurationMid,
    colorBgContainerDisabled,
    colorTextDisabled,
    colorTextPlaceholder,
    controlHeightLG,
    fontSizeLG,
    controlHeightSM,
    inputPaddingHorizontalSM,
    paddingXS,
    marginXS,
    colorTextDescription,
    lineWidthBold,
    lineHeight,
    colorPrimary,
    motionDurationSlow,
    zIndexPopup,
    paddingXXS,
    paddingSM,
    pickerTextHeight,
    controlItemBgActive,
    colorPrimaryBorder,
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    borderRadiusSM,
    colorSplit,
    controlItemBgHover,
    presetsWidth,
    presetsMaxWidth
  } = token;
  return [
    {
      [componentCls]: _extends(_extends(_extends({}, resetComponent(token)), genPikerPadding(token, controlHeight, fontSize, inputPaddingHorizontal)), {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        background: colorBgContainer,
        lineHeight: 1,
        border: `${lineWidth}px ${lineType} ${colorBorder}`,
        borderRadius,
        transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}`,
        "&:hover, &-focused": _extends({}, genHoverStyle(token)),
        "&-focused": _extends({}, genActiveStyle(token)),
        [`&${componentCls}-disabled`]: {
          background: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          [`${componentCls}-suffix`]: {
            color: colorTextDisabled
          }
        },
        [`&${componentCls}-borderless`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": _extends(_extends({}, genBasicInputStyle(token)), {
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            "&:focus": {
              boxShadow: "none"
            },
            "&[disabled]": {
              background: "transparent"
            }
          }),
          "&:hover": {
            [`${componentCls}-clear`]: {
              opacity: 1
            }
          },
          "&-placeholder": {
            "> input": {
              color: colorTextPlaceholder
            }
          }
        },
        // Size
        "&-large": _extends(_extends({}, genPikerPadding(token, controlHeightLG, fontSizeLG, inputPaddingHorizontal)), {
          [`${componentCls}-input > input`]: {
            fontSize: fontSizeLG
          }
        }),
        "&-small": _extends({}, genPikerPadding(token, controlHeightSM, fontSize, inputPaddingHorizontalSM)),
        [`${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: paddingXS / 2,
          color: colorTextDisabled,
          lineHeight: 1,
          pointerEvents: "none",
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: marginXS
            }
          }
        },
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: colorTextDisabled,
          lineHeight: 1,
          background: colorBgContainer,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: colorTextDescription
          }
        },
        [`${componentCls}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: fontSizeLG,
          color: colorTextDisabled,
          fontSize: fontSizeLG,
          verticalAlign: "top",
          cursor: "default",
          [`${componentCls}-focused &`]: {
            color: colorTextDescription
          },
          [`${componentCls}-range-separator &`]: {
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Clear
          [`${componentCls}-clear`]: {
            insetInlineEnd: inputPaddingHorizontal
          },
          "&:hover": {
            [`${componentCls}-clear`]: {
              opacity: 1
            }
          },
          // Active bar
          [`${componentCls}-active-bar`]: {
            bottom: -lineWidth,
            height: lineWidthBold,
            marginInlineStart: inputPaddingHorizontal,
            background: colorPrimary,
            opacity: 0,
            transition: `all ${motionDurationSlow} ease-out`,
            pointerEvents: "none"
          },
          [`&${componentCls}-focused`]: {
            [`${componentCls}-active-bar`]: {
              opacity: 1
            }
          },
          [`${componentCls}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${paddingXS}px`,
            lineHeight: 1
          },
          [`&${componentCls}-small`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: inputPaddingHorizontalSM
            },
            [`${componentCls}-active-bar`]: {
              marginInlineStart: inputPaddingHorizontalSM
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": _extends(_extends(_extends({}, resetComponent(token)), genPanelStyle(token)), {
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          [`&${componentCls}-dropdown-hidden`]: {
            display: "none"
          },
          [`&${componentCls}-dropdown-placement-bottomLeft`]: {
            [`${componentCls}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${componentCls}-dropdown-placement-topLeft`]: {
            [`${componentCls}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          // Time picker with additional style
          [`${componentCls}-panel > ${componentCls}-time-panel`]: {
            paddingTop: paddingXXS
          },
          // ======================== Ranges ========================
          [`${componentCls}-ranges`]: {
            marginBottom: 0,
            padding: `${paddingXXS}px ${paddingSM}px`,
            overflow: "hidden",
            lineHeight: `${pickerTextHeight - 2 * lineWidth - paddingXS / 2}px`,
            textAlign: "start",
            listStyle: "none",
            display: "flex",
            justifyContent: "space-between",
            "> li": {
              display: "inline-block"
            },
            // https://github.com/ant-design/ant-design/issues/23687
            [`${componentCls}-preset > ${antCls}-tag-blue`]: {
              color: colorPrimary,
              background: controlItemBgActive,
              borderColor: colorPrimaryBorder,
              cursor: "pointer"
            },
            [`${componentCls}-ok`]: {
              marginInlineStart: "auto"
            }
          },
          [`${componentCls}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${componentCls}-range-arrow`]: _extends({
            position: "absolute",
            zIndex: 1,
            display: "none",
            marginInlineStart: inputPaddingHorizontal * 1.5,
            transition: `left ${motionDurationSlow} ease-out`
          }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBgElevated, boxShadowPopoverArrow)),
          [`${componentCls}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            transition: `margin ${motionDurationSlow}`,
            // ======================== Layout ========================
            [`${componentCls}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${componentCls}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: presetsWidth,
              maxWidth: presetsMaxWidth,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: paddingXS,
                borderInlineEnd: `${lineWidth}px ${lineType} ${colorSplit}`,
                li: _extends(_extends({}, textEllipsis), {
                  borderRadius: borderRadiusSM,
                  paddingInline: paddingXS,
                  paddingBlock: (controlHeightSM - Math.round(fontSize * lineHeight)) / 2,
                  cursor: "pointer",
                  transition: `all ${motionDurationSlow}`,
                  "+ li": {
                    marginTop: marginXS
                  },
                  "&:hover": {
                    background: controlItemBgHover
                  }
                })
              }
            },
            // ======================== Panels ========================
            [`${componentCls}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              direction: "ltr",
              [`${componentCls}-panel`]: {
                borderWidth: `0 0 ${lineWidth}px`
              },
              "&:last-child": {
                [`${componentCls}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${componentCls}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${componentCls}-content,
            table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: colorBorder
              }
            }
          }
        }),
        "&-dropdown-range": {
          padding: `${sizePopupArrow * 2 / 3}px 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-separator`]: {
            transform: "rotate(180deg)"
          },
          [`${componentCls}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      })
    },
    // Follow code may reuse in other components
    initSlideMotion(token, "slide-up"),
    initSlideMotion(token, "slide-down"),
    initMoveMotion(token, "move-up"),
    initMoveMotion(token, "move-down")
  ];
};
var initPickerPanelToken = (token) => {
  const pickerTimePanelCellHeight = 28;
  const {
    componentCls,
    controlHeightLG,
    controlHeightSM,
    colorPrimary,
    paddingXXS
  } = token;
  return {
    pickerCellCls: `${componentCls}-cell`,
    pickerCellInnerCls: `${componentCls}-cell-inner`,
    pickerTextHeight: controlHeightLG,
    pickerPanelCellWidth: controlHeightSM * 1.5,
    pickerPanelCellHeight: controlHeightSM,
    pickerDateHoverRangeBorderColor: new TinyColor(colorPrimary).lighten(20).toHexString(),
    pickerBasicCellHoverWithRangeColor: new TinyColor(colorPrimary).lighten(35).toHexString(),
    pickerPanelWithoutTimeCellHeight: controlHeightLG * 1.65,
    pickerYearMonthCellWidth: controlHeightLG * 1.5,
    pickerTimePanelColumnHeight: pickerTimePanelCellHeight * 8,
    pickerTimePanelColumnWidth: controlHeightLG * 1.4,
    pickerTimePanelCellHeight,
    pickerQuarterPanelContentHeight: controlHeightLG * 1.4,
    pickerCellPaddingVertical: paddingXXS,
    pickerCellBorderGap: 2,
    pickerControlIconSize: 7,
    pickerControlIconBorderWidth: 1.5
  };
};
var style_default8 = genComponentStyleHook("DatePicker", (token) => {
  const pickerToken = merge(initInputToken(token), initPickerPanelToken(token));
  return [
    genPickerStyle(pickerToken),
    genPickerStatusStyle(pickerToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token, {
      focusElCls: `${token.componentCls}-focused`
    })
  ];
}, (token) => ({
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: token.zIndexPopupBase + 50
}));

// node_modules/ant-design-vue/es/calendar/style/index.js
var genCalendarStyles = (token) => {
  const {
    calendarCls,
    componentCls,
    calendarFullBg,
    calendarFullPanelBg,
    calendarItemActiveBg
  } = token;
  return {
    [calendarCls]: _extends(_extends(_extends({}, genPanelStyle(token)), resetComponent(token)), {
      background: calendarFullBg,
      "&-rtl": {
        direction: "rtl"
      },
      [`${calendarCls}-header`]: {
        display: "flex",
        justifyContent: "flex-end",
        padding: `${token.paddingSM}px 0`,
        [`${calendarCls}-year-select`]: {
          minWidth: token.yearControlWidth
        },
        [`${calendarCls}-month-select`]: {
          minWidth: token.monthControlWidth,
          marginInlineStart: token.marginXS
        },
        [`${calendarCls}-mode-switch`]: {
          marginInlineStart: token.marginXS
        }
      }
    }),
    [`${calendarCls} ${componentCls}-panel`]: {
      background: calendarFullPanelBg,
      border: 0,
      borderTop: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`,
      borderRadius: 0,
      [`${componentCls}-month-panel, ${componentCls}-date-panel`]: {
        width: "auto"
      },
      [`${componentCls}-body`]: {
        padding: `${token.paddingXS}px 0`
      },
      [`${componentCls}-content`]: {
        width: "100%"
      }
    },
    [`${calendarCls}-mini`]: {
      borderRadius: token.borderRadiusLG,
      [`${calendarCls}-header`]: {
        paddingInlineEnd: token.paddingXS,
        paddingInlineStart: token.paddingXS
      },
      [`${componentCls}-panel`]: {
        borderRadius: `0 0 ${token.borderRadiusLG}px ${token.borderRadiusLG}px`
      },
      [`${componentCls}-content`]: {
        height: token.miniContentHeight,
        th: {
          height: "auto",
          padding: 0,
          lineHeight: `${token.weekHeight}px`
        }
      },
      [`${componentCls}-cell::before`]: {
        pointerEvents: "none"
      }
    },
    [`${calendarCls}${calendarCls}-full`]: {
      [`${componentCls}-panel`]: {
        display: "block",
        width: "100%",
        textAlign: "end",
        background: calendarFullBg,
        border: 0,
        [`${componentCls}-body`]: {
          "th, td": {
            padding: 0
          },
          th: {
            height: "auto",
            paddingInlineEnd: token.paddingSM,
            paddingBottom: token.paddingXXS,
            lineHeight: `${token.weekHeight}px`
          }
        }
      },
      [`${componentCls}-cell`]: {
        "&::before": {
          display: "none"
        },
        "&:hover": {
          [`${calendarCls}-date`]: {
            background: token.controlItemBgHover
          }
        },
        [`${calendarCls}-date-today::before`]: {
          display: "none"
        },
        // >>> Selected
        [`&-in-view${componentCls}-cell-selected`]: {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            background: calendarItemActiveBg
          }
        },
        "&-selected, &-selected:hover": {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            [`${calendarCls}-date-value`]: {
              color: token.colorPrimary
            }
          }
        }
      },
      [`${calendarCls}-date`]: {
        display: "block",
        width: "auto",
        height: "auto",
        margin: `0 ${token.marginXS / 2}px`,
        padding: `${token.paddingXS / 2}px ${token.paddingXS}px 0`,
        border: 0,
        borderTop: `${token.lineWidthBold}px ${token.lineType} ${token.colorSplit}`,
        borderRadius: 0,
        transition: `background ${token.motionDurationSlow}`,
        "&-value": {
          lineHeight: `${token.dateValueHeight}px`,
          transition: `color ${token.motionDurationSlow}`
        },
        "&-content": {
          position: "static",
          width: "auto",
          height: token.dateContentHeight,
          overflowY: "auto",
          color: token.colorText,
          lineHeight: token.lineHeight,
          textAlign: "start"
        },
        "&-today": {
          borderColor: token.colorPrimary,
          [`${calendarCls}-date-value`]: {
            color: token.colorText
          }
        }
      }
    },
    [`@media only screen and (max-width: ${token.screenXS}px) `]: {
      [`${calendarCls}`]: {
        [`${calendarCls}-header`]: {
          display: "block",
          [`${calendarCls}-year-select`]: {
            width: "50%"
          },
          [`${calendarCls}-month-select`]: {
            width: `calc(50% - ${token.paddingXS}px)`
          },
          [`${calendarCls}-mode-switch`]: {
            width: "100%",
            marginTop: token.marginXS,
            marginInlineStart: 0,
            "> label": {
              width: "50%",
              textAlign: "center"
            }
          }
        }
      }
    }
  };
};
var style_default9 = genComponentStyleHook("Calendar", (token) => {
  const calendarCls = `${token.componentCls}-calendar`;
  const calendarToken = merge(initInputToken(token), initPickerPanelToken(token), {
    calendarCls,
    pickerCellInnerCls: `${token.componentCls}-cell-inner`,
    calendarFullBg: token.colorBgContainer,
    calendarFullPanelBg: token.colorBgContainer,
    calendarItemActiveBg: token.controlItemBgActive,
    dateValueHeight: token.controlHeightSM,
    weekHeight: token.controlHeightSM * 0.75,
    dateContentHeight: (token.fontSizeSM * token.lineHeightSM + token.marginXS) * 3 + token.lineWidth * 2
  });
  return [genCalendarStyles(calendarToken)];
}, {
  yearControlWidth: 80,
  monthControlWidth: 70,
  miniContentHeight: 256
});

// node_modules/ant-design-vue/es/calendar/generateCalendar.js
function generateCalendar(generateConfig2) {
  function isSameYear2(date1, date2) {
    return date1 && date2 && generateConfig2.getYear(date1) === generateConfig2.getYear(date2);
  }
  function isSameMonth2(date1, date2) {
    return isSameYear2(date1, date2) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date2);
  }
  function isSameDate2(date1, date2) {
    return isSameMonth2(date1, date2) && generateConfig2.getDate(date1) === generateConfig2.getDate(date2);
  }
  const Calendar2 = defineComponent({
    name: "ACalendar",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      locale: {
        type: Object,
        default: void 0
      },
      validRange: {
        type: Array,
        default: void 0
      },
      disabledDate: {
        type: Function,
        default: void 0
      },
      dateFullCellRender: {
        type: Function,
        default: void 0
      },
      dateCellRender: {
        type: Function,
        default: void 0
      },
      monthFullCellRender: {
        type: Function,
        default: void 0
      },
      monthCellRender: {
        type: Function,
        default: void 0
      },
      headerRender: {
        type: Function,
        default: void 0
      },
      value: {
        type: [Object, String],
        default: void 0
      },
      defaultValue: {
        type: [Object, String],
        default: void 0
      },
      mode: {
        type: String,
        default: void 0
      },
      fullscreen: {
        type: Boolean,
        default: void 0
      },
      onChange: {
        type: Function,
        default: void 0
      },
      "onUpdate:value": {
        type: Function,
        default: void 0
      },
      onPanelChange: {
        type: Function,
        default: void 0
      },
      onSelect: {
        type: Function,
        default: void 0
      },
      valueFormat: {
        type: String,
        default: void 0
      }
    },
    slots: Object,
    setup(p, _ref) {
      let {
        emit,
        slots,
        attrs
      } = _ref;
      const props2 = p;
      const {
        prefixCls,
        direction
      } = useConfigInject_default("picker", props2);
      const [wrapSSR, hashId] = style_default9(prefixCls);
      const calendarPrefixCls = computed(() => `${prefixCls.value}-calendar`);
      const maybeToString = (date) => {
        return props2.valueFormat ? generateConfig2.toString(date, props2.valueFormat) : date;
      };
      const value = computed(() => {
        if (props2.value) {
          return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
        }
        return props2.value === "" ? void 0 : props2.value;
      });
      const defaultValue = computed(() => {
        if (props2.defaultValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
        }
        return props2.defaultValue === "" ? void 0 : props2.defaultValue;
      });
      const [mergedValue, setMergedValue] = useMergedState(() => value.value || generateConfig2.getNow(), {
        defaultValue: defaultValue.value,
        value
      });
      const [mergedMode, setMergedMode] = useMergedState("month", {
        value: toRef(props2, "mode")
      });
      const panelMode = computed(() => mergedMode.value === "year" ? "month" : "date");
      const mergedDisabledDate = computed(() => {
        return (date) => {
          var _a2;
          const notInRange = props2.validRange ? generateConfig2.isAfter(props2.validRange[0], date) || generateConfig2.isAfter(date, props2.validRange[1]) : false;
          return notInRange || !!((_a2 = props2.disabledDate) === null || _a2 === void 0 ? void 0 : _a2.call(props2, date));
        };
      });
      const triggerPanelChange = (date, newMode) => {
        emit("panelChange", maybeToString(date), newMode);
      };
      const triggerChange = (date) => {
        setMergedValue(date);
        if (!isSameDate2(date, mergedValue.value)) {
          if (panelMode.value === "date" && !isSameMonth2(date, mergedValue.value) || panelMode.value === "month" && !isSameYear2(date, mergedValue.value)) {
            triggerPanelChange(date, mergedMode.value);
          }
          const val = maybeToString(date);
          emit("update:value", val);
          emit("change", val);
        }
      };
      const triggerModeChange = (newMode) => {
        setMergedMode(newMode);
        triggerPanelChange(mergedValue.value, newMode);
      };
      const onInternalSelect = (date, source) => {
        triggerChange(date);
        emit("select", maybeToString(date), {
          source
        });
      };
      const defaultLocale = computed(() => {
        const {
          locale
        } = props2;
        const result = _extends(_extends({}, en_US_default2), locale);
        result.lang = _extends(_extends({}, result.lang), (locale || {}).lang);
        return result;
      });
      const [mergedLocale] = useLocaleReceiver("Calendar", defaultLocale);
      return () => {
        const today = generateConfig2.getNow();
        const {
          dateFullCellRender = slots === null || slots === void 0 ? void 0 : slots.dateFullCellRender,
          dateCellRender = slots === null || slots === void 0 ? void 0 : slots.dateCellRender,
          monthFullCellRender = slots === null || slots === void 0 ? void 0 : slots.monthFullCellRender,
          monthCellRender = slots === null || slots === void 0 ? void 0 : slots.monthCellRender,
          headerRender = slots === null || slots === void 0 ? void 0 : slots.headerRender,
          fullscreen = true,
          validRange
        } = props2;
        const dateRender = (_ref2) => {
          let {
            current: date
          } = _ref2;
          if (dateFullCellRender) {
            return dateFullCellRender({
              current: date
            });
          }
          return createVNode("div", {
            "class": classNames_default(`${prefixCls.value}-cell-inner`, `${calendarPrefixCls.value}-date`, {
              [`${calendarPrefixCls.value}-date-today`]: isSameDate2(today, date)
            })
          }, [createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-value`
          }, [String(generateConfig2.getDate(date)).padStart(2, "0")]), createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-content`
          }, [dateCellRender && dateCellRender({
            current: date
          })])]);
        };
        const monthRender = (_ref3, locale) => {
          let {
            current: date
          } = _ref3;
          if (monthFullCellRender) {
            return monthFullCellRender({
              current: date
            });
          }
          const months = locale.shortMonths || generateConfig2.locale.getShortMonths(locale.locale);
          return createVNode("div", {
            "class": classNames_default(`${prefixCls.value}-cell-inner`, `${calendarPrefixCls.value}-date`, {
              [`${calendarPrefixCls.value}-date-today`]: isSameMonth2(today, date)
            })
          }, [createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-value`
          }, [months[generateConfig2.getMonth(date)]]), createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-content`
          }, [monthCellRender && monthCellRender({
            current: date
          })])]);
        };
        return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
          "class": classNames_default(calendarPrefixCls.value, {
            [`${calendarPrefixCls.value}-full`]: fullscreen,
            [`${calendarPrefixCls.value}-mini`]: !fullscreen,
            [`${calendarPrefixCls.value}-rtl`]: direction.value === "rtl"
          }, attrs.class, hashId.value)
        }), [headerRender ? headerRender({
          value: mergedValue.value,
          type: mergedMode.value,
          onChange: (nextDate) => {
            onInternalSelect(nextDate, "customize");
          },
          onTypeChange: triggerModeChange
        }) : createVNode(Header_default2, {
          "prefixCls": calendarPrefixCls.value,
          "value": mergedValue.value,
          "generateConfig": generateConfig2,
          "mode": mergedMode.value,
          "fullscreen": fullscreen,
          "locale": mergedLocale.value.lang,
          "validRange": validRange,
          "onChange": onInternalSelect,
          "onModeChange": triggerModeChange
        }, null), createVNode(PickerPanel_default, {
          "value": mergedValue.value,
          "prefixCls": prefixCls.value,
          "locale": mergedLocale.value.lang,
          "generateConfig": generateConfig2,
          "dateRender": dateRender,
          "monthCellRender": (obj) => monthRender(obj, mergedLocale.value.lang),
          "onSelect": (nextDate) => {
            onInternalSelect(nextDate, panelMode.value);
          },
          "mode": panelMode.value,
          "picker": panelMode.value,
          "disabledDate": mergedDisabledDate.value,
          "hideHeader": true
        }, null)]));
      };
    }
  });
  Calendar2.install = function(app) {
    app.component(Calendar2.name, Calendar2);
    return app;
  };
  return Calendar2;
}
var generateCalendar_default = generateCalendar;

// node_modules/ant-design-vue/es/calendar/dayjs.js
var Calendar = generateCalendar_default(dayjs_default);
var dayjs_default2 = withInstall(Calendar);

// node_modules/ant-design-vue/es/calendar/index.js
var calendar_default = dayjs_default2;

// node_modules/ant-design-vue/es/tabs/src/hooks/useRaf.js
function useRaf(callback) {
  const rafRef = shallowRef();
  const removedRef = shallowRef(false);
  function trigger() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!removedRef.value) {
      wrapperRaf.cancel(rafRef.value);
      rafRef.value = wrapperRaf(() => {
        callback(...args);
      });
    }
  }
  onBeforeUnmount(() => {
    removedRef.value = true;
    wrapperRaf.cancel(rafRef.value);
  });
  return trigger;
}
function useRafState(defaultState) {
  const batchRef = shallowRef([]);
  const state = shallowRef(typeof defaultState === "function" ? defaultState() : defaultState);
  const flushUpdate = useRaf(() => {
    let value = state.value;
    batchRef.value.forEach((callback) => {
      value = callback(value);
    });
    batchRef.value = [];
    state.value = value;
  });
  function updater(callback) {
    batchRef.value.push(callback);
    flushUpdate();
  }
  return [state, updater];
}

// node_modules/ant-design-vue/es/tabs/src/TabNavList/TabNode.js
var TabNode_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabNode",
  props: {
    id: {
      type: String
    },
    prefixCls: {
      type: String
    },
    tab: {
      type: Object
    },
    active: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    editable: {
      type: Object
    },
    onClick: {
      type: Function
    },
    onResize: {
      type: Function
    },
    renderWrapper: {
      type: Function
    },
    removeAriaLabel: {
      type: String
    },
    // onRemove: { type: Function as PropType<() => void> },
    onFocus: {
      type: Function
    }
  },
  emits: ["click", "resize", "remove", "focus"],
  setup(props2, _ref) {
    let {
      expose,
      attrs
    } = _ref;
    const domRef = ref();
    function onInternalClick(e) {
      var _a2;
      if ((_a2 = props2.tab) === null || _a2 === void 0 ? void 0 : _a2.disabled) {
        return;
      }
      props2.onClick(e);
    }
    expose({
      domRef
    });
    function onRemoveTab(event) {
      var _a2;
      event.preventDefault();
      event.stopPropagation();
      props2.editable.onEdit("remove", {
        key: (_a2 = props2.tab) === null || _a2 === void 0 ? void 0 : _a2.key,
        event
      });
    }
    const removable = computed(() => {
      var _a2;
      return props2.editable && props2.closable !== false && !((_a2 = props2.tab) === null || _a2 === void 0 ? void 0 : _a2.disabled);
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        id,
        active,
        tab: {
          key,
          tab,
          disabled,
          closeIcon
        },
        renderWrapper,
        removeAriaLabel,
        editable,
        onFocus
      } = props2;
      const tabPrefix = `${prefixCls}-tab`;
      const node = createVNode("div", {
        "key": key,
        "ref": domRef,
        "class": classNames_default(tabPrefix, {
          [`${tabPrefix}-with-remove`]: removable.value,
          [`${tabPrefix}-active`]: active,
          [`${tabPrefix}-disabled`]: disabled
        }),
        "style": attrs.style,
        "onClick": onInternalClick
      }, [createVNode("div", {
        "role": "tab",
        "aria-selected": active,
        "id": id && `${id}-tab-${key}`,
        "class": `${tabPrefix}-btn`,
        "aria-controls": id && `${id}-panel-${key}`,
        "aria-disabled": disabled,
        "tabindex": disabled ? null : 0,
        "onClick": (e) => {
          e.stopPropagation();
          onInternalClick(e);
        },
        "onKeydown": (e) => {
          if ([KeyCode_default.SPACE, KeyCode_default.ENTER].includes(e.which)) {
            e.preventDefault();
            onInternalClick(e);
          }
        },
        "onFocus": onFocus
      }, [typeof tab === "function" ? tab() : tab]), removable.value && createVNode("button", {
        "type": "button",
        "aria-label": removeAriaLabel || "remove",
        "tabindex": 0,
        "class": `${tabPrefix}-remove`,
        "onClick": (e) => {
          e.stopPropagation();
          onRemoveTab(e);
        }
      }, [(closeIcon === null || closeIcon === void 0 ? void 0 : closeIcon()) || ((_a2 = editable.removeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(editable)) || "×"])]);
      return renderWrapper ? renderWrapper(node) : node;
    };
  }
});

// node_modules/ant-design-vue/es/tabs/src/hooks/useOffsets.js
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes) {
  const offsetMap = ref(/* @__PURE__ */ new Map());
  watchEffect(() => {
    var _a2, _b;
    const map = /* @__PURE__ */ new Map();
    const tabsValue = tabs.value;
    const lastOffset = tabSizes.value.get((_a2 = tabsValue[0]) === null || _a2 === void 0 ? void 0 : _a2.key) || DEFAULT_SIZE;
    const rightOffset = lastOffset.left + lastOffset.width;
    for (let i = 0; i < tabsValue.length; i += 1) {
      const {
        key
      } = tabsValue[i];
      let data = tabSizes.value.get(key);
      if (!data) {
        data = tabSizes.value.get((_b = tabsValue[i - 1]) === null || _b === void 0 ? void 0 : _b.key) || DEFAULT_SIZE;
      }
      const entity = map.get(key) || _extends({}, data);
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key, entity);
    }
    offsetMap.value = new Map(map);
  });
  return offsetMap;
}

// node_modules/ant-design-vue/es/tabs/src/TabNavList/AddButton.js
var AddButton_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AddButton",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    editable: {
      type: Object
    },
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup(props2, _ref) {
    let {
      expose,
      attrs
    } = _ref;
    const domRef = ref();
    expose({
      domRef
    });
    return () => {
      const {
        prefixCls,
        editable,
        locale
      } = props2;
      if (!editable || editable.showAdd === false) {
        return null;
      }
      return createVNode("button", {
        "ref": domRef,
        "type": "button",
        "class": `${prefixCls}-nav-add`,
        "style": attrs.style,
        "aria-label": (locale === null || locale === void 0 ? void 0 : locale.addAriaLabel) || "Add tab",
        "onClick": (event) => {
          editable.onEdit("add", {
            event
          });
        }
      }, [editable.addIcon ? editable.addIcon() : "+"]);
    };
  }
});

// node_modules/ant-design-vue/es/tabs/src/TabNavList/OperationNode.js
var operationNodeProps = {
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  tabs: {
    type: Object
  },
  rtl: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  activeKey: {
    type: [String, Number]
  },
  mobile: {
    type: Boolean
  },
  moreIcon: vue_types_default.any,
  moreTransitionName: {
    type: String
  },
  editable: {
    type: Object
  },
  locale: {
    type: Object,
    default: void 0
  },
  removeAriaLabel: String,
  onTabClick: {
    type: Function
  },
  popupClassName: String,
  getPopupContainer: functionType()
};
var OperationNode_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OperationNode",
  inheritAttrs: false,
  props: operationNodeProps,
  emits: ["tabClick"],
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const [open2, setOpen] = useState(false);
    const [selectedKey, setSelectedKey] = useState(null);
    const selectOffset = (offset) => {
      const enabledTabs = props2.tabs.filter((tab) => !tab.disabled);
      let selectedIndex = enabledTabs.findIndex((tab) => tab.key === selectedKey.value) || 0;
      const len = enabledTabs.length;
      for (let i = 0; i < len; i += 1) {
        selectedIndex = (selectedIndex + offset + len) % len;
        const tab = enabledTabs[selectedIndex];
        if (!tab.disabled) {
          setSelectedKey(tab.key);
          return;
        }
      }
    };
    const onKeyDown = (e) => {
      const {
        which
      } = e;
      if (!open2.value) {
        if ([KeyCode_default.DOWN, KeyCode_default.SPACE, KeyCode_default.ENTER].includes(which)) {
          setOpen(true);
          e.preventDefault();
        }
        return;
      }
      switch (which) {
        case KeyCode_default.UP:
          selectOffset(-1);
          e.preventDefault();
          break;
        case KeyCode_default.DOWN:
          selectOffset(1);
          e.preventDefault();
          break;
        case KeyCode_default.ESC:
          setOpen(false);
          break;
        case KeyCode_default.SPACE:
        case KeyCode_default.ENTER:
          if (selectedKey.value !== null)
            props2.onTabClick(selectedKey.value, e);
          break;
      }
    };
    const popupId = computed(() => `${props2.id}-more-popup`);
    const selectedItemId = computed(() => selectedKey.value !== null ? `${popupId.value}-${selectedKey.value}` : null);
    const onRemoveTab = (event, key) => {
      event.preventDefault();
      event.stopPropagation();
      props2.editable.onEdit("remove", {
        key,
        event
      });
    };
    onMounted(() => {
      watch(selectedKey, () => {
        const ele = document.getElementById(selectedItemId.value);
        if (ele && ele.scrollIntoView) {
          ele.scrollIntoView(false);
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    watch(open2, () => {
      if (!open2.value) {
        setSelectedKey(null);
      }
    });
    useProvideOverride({});
    return () => {
      var _a2;
      const {
        prefixCls,
        id,
        tabs,
        locale,
        mobile,
        moreIcon = ((_a2 = slots.moreIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || createVNode(EllipsisOutlined_default, null, null),
        moreTransitionName,
        editable,
        tabBarGutter,
        rtl,
        onTabClick,
        popupClassName
      } = props2;
      if (!tabs.length)
        return null;
      const dropdownPrefix = `${prefixCls}-dropdown`;
      const dropdownAriaLabel = locale === null || locale === void 0 ? void 0 : locale.dropdownAriaLabel;
      const moreStyle = {
        [rtl ? "marginRight" : "marginLeft"]: tabBarGutter
      };
      if (!tabs.length) {
        moreStyle.visibility = "hidden";
        moreStyle.order = 1;
      }
      const overlayClassName = classNames_default({
        [`${dropdownPrefix}-rtl`]: rtl,
        [`${popupClassName}`]: true
      });
      const moreNode = mobile ? null : createVNode(vc_dropdown_default, {
        "prefixCls": dropdownPrefix,
        "trigger": ["hover"],
        "visible": open2.value,
        "transitionName": moreTransitionName,
        "onVisibleChange": setOpen,
        "overlayClassName": overlayClassName,
        "mouseEnterDelay": 0.1,
        "mouseLeaveDelay": 0.1,
        "getPopupContainer": props2.getPopupContainer
      }, {
        overlay: () => createVNode(menu_default, {
          "onClick": (_ref2) => {
            let {
              key,
              domEvent
            } = _ref2;
            onTabClick(key, domEvent);
            setOpen(false);
          },
          "id": popupId.value,
          "tabindex": -1,
          "role": "listbox",
          "aria-activedescendant": selectedItemId.value,
          "selectedKeys": [selectedKey.value],
          "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
        }, {
          default: () => [tabs.map((tab) => {
            var _a3, _b;
            const removable = editable && tab.closable !== false && !tab.disabled;
            return createVNode(MenuItem_default, {
              "key": tab.key,
              "id": `${popupId.value}-${tab.key}`,
              "role": "option",
              "aria-controls": id && `${id}-panel-${tab.key}`,
              "disabled": tab.disabled
            }, {
              default: () => [createVNode("span", null, [typeof tab.tab === "function" ? tab.tab() : tab.tab]), removable && createVNode("button", {
                "type": "button",
                "aria-label": props2.removeAriaLabel || "remove",
                "tabindex": 0,
                "class": `${dropdownPrefix}-menu-item-remove`,
                "onClick": (e) => {
                  e.stopPropagation();
                  onRemoveTab(e, tab.key);
                }
              }, [((_a3 = tab.closeIcon) === null || _a3 === void 0 ? void 0 : _a3.call(tab)) || ((_b = editable.removeIcon) === null || _b === void 0 ? void 0 : _b.call(editable)) || "×"])]
            });
          })]
        }),
        default: () => createVNode("button", {
          "type": "button",
          "class": `${prefixCls}-nav-more`,
          "style": moreStyle,
          "tabindex": -1,
          "aria-hidden": "true",
          "aria-haspopup": "listbox",
          "aria-controls": popupId.value,
          "id": `${id}-more`,
          "aria-expanded": open2.value,
          "onKeydown": onKeyDown
        }, [moreIcon])
      });
      return createVNode("div", {
        "class": classNames_default(`${prefixCls}-nav-operations`, attrs.class),
        "style": attrs.style
      }, [moreNode, createVNode(AddButton_default, {
        "prefixCls": prefixCls,
        "locale": locale,
        "editable": editable
      }, null)]);
    };
  }
});

// node_modules/ant-design-vue/es/tabs/src/TabContext.js
var TabsContextKey = Symbol("tabsContextKey");
var useProvideTabs = (props2) => {
  provide(TabsContextKey, props2);
};
var useInjectTabs = () => {
  return inject(TabsContextKey, {
    tabs: ref([]),
    prefixCls: ref()
  });
};
var TabsContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabsContextProvider",
  inheritAttrs: false,
  props: {
    tabs: {
      type: Object,
      default: void 0
    },
    prefixCls: {
      type: String,
      default: void 0
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useProvideTabs(toRefs(props2));
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});

// node_modules/ant-design-vue/es/tabs/src/hooks/useTouchMove.js
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
function useTouchMove(domRef, onOffset) {
  const [touchPosition, setTouchPosition] = useState();
  const [lastTimestamp, setLastTimestamp] = useState(0);
  const [lastTimeDiff, setLastTimeDiff] = useState(0);
  const [lastOffset, setLastOffset] = useState();
  const motionInterval = ref();
  function onTouchStart(e) {
    const {
      screenX,
      screenY
    } = e.touches[0];
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    clearInterval(motionInterval.value);
  }
  function onTouchMove(e) {
    if (!touchPosition.value)
      return;
    e.preventDefault();
    const {
      screenX,
      screenY
    } = e.touches[0];
    const offsetX = screenX - touchPosition.value.x;
    const offsetY = screenY - touchPosition.value.y;
    onOffset(offsetX, offsetY);
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    const now2 = Date.now();
    setLastTimeDiff(now2 - lastTimestamp.value);
    setLastTimestamp(now2);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition.value)
      return;
    const lastOffsetValue = lastOffset.value;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffsetValue) {
      const distanceX = lastOffsetValue.x / lastTimeDiff.value;
      const distanceY = lastOffsetValue.y / lastTimeDiff.value;
      const absX = Math.abs(distanceX);
      const absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
        return;
      let currentX = distanceX;
      let currentY = distanceY;
      motionInterval.value = setInterval(() => {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          clearInterval(motionInterval.value);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  const lastWheelDirectionRef = ref();
  function onWheel(e) {
    const {
      deltaX,
      deltaY
    } = e;
    let mixed = 0;
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.value === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.value = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.value = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e.preventDefault();
    }
  }
  const touchEventsRef = ref({
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  });
  function onProxyTouchStart(e) {
    touchEventsRef.value.onTouchStart(e);
  }
  function onProxyTouchMove(e) {
    touchEventsRef.value.onTouchMove(e);
  }
  function onProxyTouchEnd(e) {
    touchEventsRef.value.onTouchEnd(e);
  }
  function onProxyWheel(e) {
    touchEventsRef.value.onWheel(e);
  }
  onMounted(() => {
    var _a2, _b;
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: false
    });
    (_a2 = domRef.value) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("touchstart", onProxyTouchStart, {
      passive: false
    });
    (_b = domRef.value) === null || _b === void 0 ? void 0 : _b.addEventListener("wheel", onProxyWheel, {
      passive: false
    });
  });
  onBeforeUnmount(() => {
    document.removeEventListener("touchmove", onProxyTouchMove);
    document.removeEventListener("touchend", onProxyTouchEnd);
  });
}

// node_modules/ant-design-vue/es/tabs/src/hooks/useSyncState.js
function useSyncState(defaultState, onChange) {
  const stateRef = ref(defaultState);
  function setState(updater) {
    const newValue = typeof updater === "function" ? updater(stateRef.value) : updater;
    if (newValue !== stateRef.value) {
      onChange(newValue, stateRef.value);
    }
    stateRef.value = newValue;
  }
  return [stateRef, setState];
}

// node_modules/ant-design-vue/es/_util/hooks/useRefs.js
var useRefs = () => {
  const refs = ref(/* @__PURE__ */ new Map());
  const setRef = (key) => (el) => {
    refs.value.set(key, el);
  };
  onBeforeUpdate(() => {
    refs.value = /* @__PURE__ */ new Map();
  });
  return [setRef, refs];
};
var useRefs_default = useRefs;

// node_modules/ant-design-vue/es/tabs/src/TabNavList/index.js
var DEFAULT_SIZE2 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
var tabNavListProps = () => {
  return {
    id: {
      type: String
    },
    tabPosition: {
      type: String
    },
    activeKey: {
      type: [String, Number]
    },
    rtl: {
      type: Boolean
    },
    animated: objectType(),
    editable: objectType(),
    moreIcon: vue_types_default.any,
    moreTransitionName: {
      type: String
    },
    mobile: {
      type: Boolean
    },
    tabBarGutter: {
      type: Number
    },
    renderTabBar: {
      type: Function
    },
    locale: objectType(),
    popupClassName: String,
    getPopupContainer: functionType(),
    onTabClick: {
      type: Function
    },
    onTabScroll: {
      type: Function
    }
  };
};
var getTabSize = (tab, containerRect) => {
  const {
    offsetWidth,
    offsetHeight,
    offsetTop,
    offsetLeft
  } = tab;
  const {
    width,
    height,
    x,
    y
  } = tab.getBoundingClientRect();
  if (Math.abs(width - offsetWidth) < 1) {
    return [width, height, x - containerRect.x, y - containerRect.y];
  }
  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
};
var TabNavList_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabNavList",
  inheritAttrs: false,
  props: tabNavListProps(),
  slots: Object,
  emits: ["tabClick", "tabScroll"],
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      tabs,
      prefixCls
    } = useInjectTabs();
    const tabsWrapperRef = shallowRef();
    const tabListRef = shallowRef();
    const operationsRef = shallowRef();
    const innerAddButtonRef = shallowRef();
    const [setRef, btnRefs] = useRefs_default();
    const tabPositionTopOrBottom = computed(() => props2.tabPosition === "top" || props2.tabPosition === "bottom");
    const [transformLeft, setTransformLeft] = useSyncState(0, (next, prev) => {
      if (tabPositionTopOrBottom.value && props2.onTabScroll) {
        props2.onTabScroll({
          direction: next > prev ? "left" : "right"
        });
      }
    });
    const [transformTop, setTransformTop] = useSyncState(0, (next, prev) => {
      if (!tabPositionTopOrBottom.value && props2.onTabScroll) {
        props2.onTabScroll({
          direction: next > prev ? "top" : "bottom"
        });
      }
    });
    const [wrapperScrollWidth, setWrapperScrollWidth] = useState(0);
    const [wrapperScrollHeight, setWrapperScrollHeight] = useState(0);
    const [wrapperWidth, setWrapperWidth] = useState(null);
    const [wrapperHeight, setWrapperHeight] = useState(null);
    const [addWidth, setAddWidth] = useState(0);
    const [addHeight, setAddHeight] = useState(0);
    const [tabSizes, setTabSizes] = useRafState(/* @__PURE__ */ new Map());
    const tabOffsets = useOffsets(tabs, tabSizes);
    const operationsHiddenClassName = computed(() => `${prefixCls.value}-nav-operations-hidden`);
    const transformMin = shallowRef(0);
    const transformMax = shallowRef(0);
    watchEffect(() => {
      if (!tabPositionTopOrBottom.value) {
        transformMin.value = Math.min(0, wrapperHeight.value - wrapperScrollHeight.value);
        transformMax.value = 0;
      } else if (props2.rtl) {
        transformMin.value = 0;
        transformMax.value = Math.max(0, wrapperScrollWidth.value - wrapperWidth.value);
      } else {
        transformMin.value = Math.min(0, wrapperWidth.value - wrapperScrollWidth.value);
        transformMax.value = 0;
      }
    });
    const alignInRange = (value) => {
      if (value < transformMin.value) {
        return transformMin.value;
      }
      if (value > transformMax.value) {
        return transformMax.value;
      }
      return value;
    };
    const touchMovingRef = shallowRef();
    const [lockAnimation, setLockAnimation] = useState();
    const doLockAnimation = () => {
      setLockAnimation(Date.now());
    };
    const clearTouchMoving = () => {
      clearTimeout(touchMovingRef.value);
    };
    const doMove = (setState, offset) => {
      setState((value) => {
        const newValue = alignInRange(value + offset);
        return newValue;
      });
    };
    useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {
      if (tabPositionTopOrBottom.value) {
        if (wrapperWidth.value >= wrapperScrollWidth.value) {
          return false;
        }
        doMove(setTransformLeft, offsetX);
      } else {
        if (wrapperHeight.value >= wrapperScrollHeight.value) {
          return false;
        }
        doMove(setTransformTop, offsetY);
      }
      clearTouchMoving();
      doLockAnimation();
      return true;
    });
    watch(lockAnimation, () => {
      clearTouchMoving();
      if (lockAnimation.value) {
        touchMovingRef.value = setTimeout(() => {
          setLockAnimation(0);
        }, 100);
      }
    });
    const scrollToTab = function() {
      let key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props2.activeKey;
      const tabOffset = tabOffsets.value.get(key) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (tabPositionTopOrBottom.value) {
        let newTransform = transformLeft.value;
        if (props2.rtl) {
          if (tabOffset.right < transformLeft.value) {
            newTransform = tabOffset.right;
          } else if (tabOffset.right + tabOffset.width > transformLeft.value + wrapperWidth.value) {
            newTransform = tabOffset.right + tabOffset.width - wrapperWidth.value;
          }
        } else if (tabOffset.left < -transformLeft.value) {
          newTransform = -tabOffset.left;
        } else if (tabOffset.left + tabOffset.width > -transformLeft.value + wrapperWidth.value) {
          newTransform = -(tabOffset.left + tabOffset.width - wrapperWidth.value);
        }
        setTransformTop(0);
        setTransformLeft(alignInRange(newTransform));
      } else {
        let newTransform = transformTop.value;
        if (tabOffset.top < -transformTop.value) {
          newTransform = -tabOffset.top;
        } else if (tabOffset.top + tabOffset.height > -transformTop.value + wrapperHeight.value) {
          newTransform = -(tabOffset.top + tabOffset.height - wrapperHeight.value);
        }
        setTransformLeft(0);
        setTransformTop(alignInRange(newTransform));
      }
    };
    const visibleStart = shallowRef(0);
    const visibleEnd = shallowRef(0);
    watchEffect(() => {
      let unit;
      let position;
      let transformSize;
      let basicSize;
      let tabContentSize;
      let addSize;
      const tabOffsetsValue = tabOffsets.value;
      if (["top", "bottom"].includes(props2.tabPosition)) {
        unit = "width";
        basicSize = wrapperWidth.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addWidth.value;
        position = props2.rtl ? "right" : "left";
        transformSize = Math.abs(transformLeft.value);
      } else {
        unit = "height";
        basicSize = wrapperHeight.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addHeight.value;
        position = "top";
        transformSize = -transformTop.value;
      }
      let mergedBasicSize = basicSize;
      if (tabContentSize + addSize > basicSize && tabContentSize < basicSize) {
        mergedBasicSize = basicSize - addSize;
      }
      const tabsVal = tabs.value;
      if (!tabsVal.length) {
        return [visibleStart.value, visibleEnd.value] = [0, 0];
      }
      const len = tabsVal.length;
      let endIndex = len;
      for (let i = 0; i < len; i += 1) {
        const offset = tabOffsetsValue.get(tabsVal[i].key) || DEFAULT_SIZE2;
        if (offset[position] + offset[unit] > transformSize + mergedBasicSize) {
          endIndex = i - 1;
          break;
        }
      }
      let startIndex = 0;
      for (let i = len - 1; i >= 0; i -= 1) {
        const offset = tabOffsetsValue.get(tabsVal[i].key) || DEFAULT_SIZE2;
        if (offset[position] < transformSize) {
          startIndex = i + 1;
          break;
        }
      }
      return [visibleStart.value, visibleEnd.value] = [startIndex, endIndex];
    });
    const updateTabSizes = () => {
      setTabSizes(() => {
        var _a2;
        const newSizes = /* @__PURE__ */ new Map();
        const listRect = (_a2 = tabListRef.value) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect();
        tabs.value.forEach((_ref2) => {
          let {
            key
          } = _ref2;
          const btnRef = btnRefs.value.get(key);
          const btnNode = (btnRef === null || btnRef === void 0 ? void 0 : btnRef.$el) || btnRef;
          if (btnNode) {
            const [width, height, left, top] = getTabSize(btnNode, listRect);
            newSizes.set(key, {
              width,
              height,
              left,
              top
            });
          }
        });
        return newSizes;
      });
    };
    watch(() => tabs.value.map((tab) => tab.key).join("%%"), () => {
      updateTabSizes();
    }, {
      flush: "post"
    });
    const onListHolderResize = () => {
      var _a2, _b, _c, _d, _e;
      const offsetWidth = ((_a2 = tabsWrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetWidth) || 0;
      const offsetHeight = ((_b = tabsWrapperRef.value) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
      const addDom = ((_c = innerAddButtonRef.value) === null || _c === void 0 ? void 0 : _c.$el) || {};
      const newAddWidth = addDom.offsetWidth || 0;
      const newAddHeight = addDom.offsetHeight || 0;
      setWrapperWidth(offsetWidth);
      setWrapperHeight(offsetHeight);
      setAddWidth(newAddWidth);
      setAddHeight(newAddHeight);
      const newWrapperScrollWidth = (((_d = tabListRef.value) === null || _d === void 0 ? void 0 : _d.offsetWidth) || 0) - newAddWidth;
      const newWrapperScrollHeight = (((_e = tabListRef.value) === null || _e === void 0 ? void 0 : _e.offsetHeight) || 0) - newAddHeight;
      setWrapperScrollWidth(newWrapperScrollWidth);
      setWrapperScrollHeight(newWrapperScrollHeight);
      updateTabSizes();
    };
    const hiddenTabs = computed(() => [...tabs.value.slice(0, visibleStart.value), ...tabs.value.slice(visibleEnd.value + 1)]);
    const [inkStyle, setInkStyle] = useState();
    const activeTabOffset = computed(() => tabOffsets.value.get(props2.activeKey));
    const inkBarRafRef = shallowRef();
    const cleanInkBarRaf = () => {
      wrapperRaf.cancel(inkBarRafRef.value);
    };
    watch([activeTabOffset, tabPositionTopOrBottom, () => props2.rtl], () => {
      const newInkStyle = {};
      if (activeTabOffset.value) {
        if (tabPositionTopOrBottom.value) {
          if (props2.rtl) {
            newInkStyle.right = toPx(activeTabOffset.value.right);
          } else {
            newInkStyle.left = toPx(activeTabOffset.value.left);
          }
          newInkStyle.width = toPx(activeTabOffset.value.width);
        } else {
          newInkStyle.top = toPx(activeTabOffset.value.top);
          newInkStyle.height = toPx(activeTabOffset.value.height);
        }
      }
      cleanInkBarRaf();
      inkBarRafRef.value = wrapperRaf(() => {
        setInkStyle(newInkStyle);
      });
    });
    watch([() => props2.activeKey, activeTabOffset, tabOffsets, tabPositionTopOrBottom], () => {
      scrollToTab();
    }, {
      flush: "post"
    });
    watch([() => props2.rtl, () => props2.tabBarGutter, () => props2.activeKey, () => tabs.value], () => {
      onListHolderResize();
    }, {
      flush: "post"
    });
    const ExtraContent = (_ref3) => {
      let {
        position,
        prefixCls: prefixCls2,
        extra
      } = _ref3;
      if (!extra)
        return null;
      const content = extra === null || extra === void 0 ? void 0 : extra({
        position
      });
      return content ? createVNode("div", {
        "class": `${prefixCls2}-extra-content`
      }, [content]) : null;
    };
    onBeforeUnmount(() => {
      clearTouchMoving();
      cleanInkBarRaf();
    });
    return () => {
      const {
        id,
        animated,
        activeKey,
        rtl,
        editable,
        locale,
        tabPosition,
        tabBarGutter,
        onTabClick
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const pre = prefixCls.value;
      const hasDropdown = !!hiddenTabs.value.length;
      const wrapPrefix = `${pre}-nav-wrap`;
      let pingLeft;
      let pingRight;
      let pingTop;
      let pingBottom;
      if (tabPositionTopOrBottom.value) {
        if (rtl) {
          pingRight = transformLeft.value > 0;
          pingLeft = transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        } else {
          pingLeft = transformLeft.value < 0;
          pingRight = -transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        }
      } else {
        pingTop = transformTop.value < 0;
        pingBottom = -transformTop.value + wrapperHeight.value < wrapperScrollHeight.value;
      }
      const tabNodeStyle = {};
      if (tabPosition === "top" || tabPosition === "bottom") {
        tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = typeof tabBarGutter === "number" ? `${tabBarGutter}px` : tabBarGutter;
      } else {
        tabNodeStyle.marginTop = typeof tabBarGutter === "number" ? `${tabBarGutter}px` : tabBarGutter;
      }
      const tabNodes = tabs.value.map((tab, i) => {
        const {
          key
        } = tab;
        return createVNode(TabNode_default, {
          "id": id,
          "prefixCls": pre,
          "key": key,
          "tab": tab,
          "style": i === 0 ? void 0 : tabNodeStyle,
          "closable": tab.closable,
          "editable": editable,
          "active": key === activeKey,
          "removeAriaLabel": locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,
          "ref": setRef(key),
          "onClick": (e) => {
            onTabClick(key, e);
          },
          "onFocus": () => {
            scrollToTab(key);
            doLockAnimation();
            if (!tabsWrapperRef.value) {
              return;
            }
            if (!rtl) {
              tabsWrapperRef.value.scrollLeft = 0;
            }
            tabsWrapperRef.value.scrollTop = 0;
          }
        }, slots);
      });
      return createVNode("div", {
        "role": "tablist",
        "class": classNames_default(`${pre}-nav`, className),
        "style": style,
        "onKeydown": () => {
          doLockAnimation();
        }
      }, [createVNode(ExtraContent, {
        "position": "left",
        "prefixCls": pre,
        "extra": slots.leftExtra
      }, null), createVNode(vc_resize_observer_default, {
        "onResize": onListHolderResize
      }, {
        default: () => [createVNode("div", {
          "class": classNames_default(wrapPrefix, {
            [`${wrapPrefix}-ping-left`]: pingLeft,
            [`${wrapPrefix}-ping-right`]: pingRight,
            [`${wrapPrefix}-ping-top`]: pingTop,
            [`${wrapPrefix}-ping-bottom`]: pingBottom
          }),
          "ref": tabsWrapperRef
        }, [createVNode(vc_resize_observer_default, {
          "onResize": onListHolderResize
        }, {
          default: () => [createVNode("div", {
            "ref": tabListRef,
            "class": `${pre}-nav-list`,
            "style": {
              transform: `translate(${transformLeft.value}px, ${transformTop.value}px)`,
              transition: lockAnimation.value ? "none" : void 0
            }
          }, [tabNodes, createVNode(AddButton_default, {
            "ref": innerAddButtonRef,
            "prefixCls": pre,
            "locale": locale,
            "editable": editable,
            "style": _extends(_extends({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {
              visibility: hasDropdown ? "hidden" : null
            })
          }, null), createVNode("div", {
            "class": classNames_default(`${pre}-ink-bar`, {
              [`${pre}-ink-bar-animated`]: animated.inkBar
            }),
            "style": inkStyle.value
          }, null)])]
        })])]
      }), createVNode(OperationNode_default, _objectSpread2(_objectSpread2({}, props2), {}, {
        "removeAriaLabel": locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,
        "ref": operationsRef,
        "prefixCls": pre,
        "tabs": hiddenTabs.value,
        "class": !hasDropdown && operationsHiddenClassName.value
      }), pick_default(slots, ["moreIcon"])), createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.rightExtra
      }, null), createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.tabBarExtraContent
      }, null)]);
    };
  }
});

// node_modules/ant-design-vue/es/tabs/src/TabPanelList/index.js
var TabPanelList_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabPanelList",
  inheritAttrs: false,
  props: {
    activeKey: {
      type: [String, Number]
    },
    id: {
      type: String
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    }
  },
  setup(props2) {
    const {
      tabs,
      prefixCls
    } = useInjectTabs();
    return () => {
      const {
        id,
        activeKey,
        animated,
        tabPosition,
        rtl,
        destroyInactiveTabPane
      } = props2;
      const tabPaneAnimated = animated.tabPane;
      const pre = prefixCls.value;
      const activeIndex = tabs.value.findIndex((tab) => tab.key === activeKey);
      return createVNode("div", {
        "class": `${pre}-content-holder`
      }, [createVNode("div", {
        "class": [`${pre}-content`, `${pre}-content-${tabPosition}`, {
          [`${pre}-content-animated`]: tabPaneAnimated
        }],
        "style": activeIndex && tabPaneAnimated ? {
          [rtl ? "marginRight" : "marginLeft"]: `-${activeIndex}00%`
        } : null
      }, [tabs.value.map((tab) => {
        return cloneElement(tab.node, {
          key: tab.key,
          prefixCls: pre,
          tabKey: tab.key,
          id,
          animated: tabPaneAnimated,
          active: tab.key === activeKey,
          destroyInactiveTabPane
        });
      })])]);
    };
  }
});

// node_modules/ant-design-vue/es/tabs/style/motion.js
var genMotionStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow
  } = token;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token, "slide-up"), initSlideMotion(token, "slide-down")]
  ];
};
var motion_default = genMotionStyle;

// node_modules/ant-design-vue/es/tabs/style/index.js
var genCardStyle = (token) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeadBackground,
    tabsCardGutter,
    colorSplit
  } = token;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardHorizontalPadding,
          background: tabsCardHeadBackground,
          border: `${token.lineWidth}px ${token.lineType} ${colorSplit}`,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: token.colorPrimary,
          background: token.colorBgContainer
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${token.borderRadiusLG}px ${token.borderRadiusLG}px 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${token.borderRadiusLG}px ${token.borderRadiusLG}px`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: `${tabsCardGutter}px`
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token.borderRadiusLG}px 0 0 ${token.borderRadiusLG}px`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token.borderRadiusLG}px ${token.borderRadiusLG}px 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token.colorBgContainer
            }
          }
        }
      }
    }
  };
};
var genDropdownStyle = (token) => {
  const {
    componentCls,
    tabsHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token;
  return {
    [`${componentCls}-dropdown`]: _extends(_extends({}, resetComponent(token)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token.tabsDropdownHeight,
        margin: 0,
        padding: `${dropdownEdgeChildVerticalPadding}px 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: true,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token.borderRadiusLG,
        outline: "none",
        boxShadow: token.boxShadowSecondary,
        "&-item": _extends(_extends({}, textEllipsis), {
          display: "flex",
          alignItems: "center",
          minWidth: token.tabsDropdownWidth,
          margin: 0,
          padding: `${token.paddingXXS}px ${token.paddingSM}px`,
          color: token.colorText,
          fontWeight: "normal",
          fontSize: token.fontSize,
          lineHeight: token.lineHeight,
          cursor: "pointer",
          transition: `all ${token.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: true,
              value: token.marginSM
            },
            color: token.colorTextDescription,
            fontSize: token.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: tabsHoverColor
            }
          },
          "&:hover": {
            background: token.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
};
var genPositionStyle = (token) => {
  const {
    componentCls,
    margin,
    colorSplit
  } = token;
  return {
    // ========================== Top & Bottom ==========================
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: `0 0 ${margin}px 0`,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${token.lineWidth}px ${token.lineType} ${colorSplit}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token.lineWidthBold,
          "&-animated": {
            transition: `width ${token.motionDurationSlow}, left ${token.motionDurationSlow},
            right ${token.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: `${margin}px`,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: token.controlHeight * 1.25,
        // >>>>>>>>>>> Tab
        [`${componentCls}-tab`]: {
          padding: `${token.paddingXS}px ${token.paddingLG}px`,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: `${token.margin}px 0 0 0`
        },
        // >>>>>>>>>>> Nav
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${componentCls}-ink-bar`]: {
          width: token.lineWidthBold,
          "&-animated": {
            transition: `height ${token.motionDurationSlow}, top ${token.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: `-${token.lineWidth}px`
        },
        borderLeft: {
          _skip_check_: true,
          value: `${token.lineWidth}px ${token.lineType} ${token.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: -token.lineWidth
        },
        borderRight: {
          _skip_check_: true,
          value: `${token.lineWidth}px ${token.lineType} ${token.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token.paddingLG
          }
        }
      }
    }
  };
};
var genSizeStyle = (token) => {
  const {
    componentCls,
    padding
  } = token;
  return {
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token.paddingXS}px 0`,
            fontSize: token.fontSize
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${padding}px 0`,
            fontSize: token.fontSizeLG
          }
        }
      }
    },
    [`${componentCls}-card`]: {
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token.paddingXXS * 1.5}px ${padding}px`
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${token.borderRadius}px ${token.borderRadius}px`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${token.borderRadius}px ${token.borderRadius}px 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token.borderRadius}px ${token.borderRadius}px 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token.borderRadius}px 0 0 ${token.borderRadius}px`
            }
          }
        }
      },
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token.paddingXS}px ${padding}px ${token.paddingXXS * 1.5}px`
          }
        }
      }
    }
  };
};
var genTabStyle = (token) => {
  const {
    componentCls,
    tabsActiveColor,
    tabsHoverColor,
    iconCls,
    tabsHorizontalGutter
  } = token;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      padding: `${token.paddingSM}px 0`,
      fontSize: `${token.fontSize}px`,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      "&-btn, &-remove": _extends({
        "&:focus:not(:focus-visible), &:active": {
          color: tabsActiveColor
        }
      }, genFocusStyle(token)),
      "&-btn": {
        outline: "none",
        transition: "all 0.3s"
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: true,
          value: -token.marginXXS
        },
        marginLeft: {
          _skip_check_: true,
          value: token.marginXS
        },
        color: token.colorTextDescription,
        fontSize: token.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token.motionDurationSlow}`,
        "&:hover": {
          color: token.colorTextHeading
        }
      },
      "&:hover": {
        color: tabsHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: token.colorPrimary,
        textShadow: token.tabsActiveTextShadow
      },
      [`&${tabCls}-disabled`]: {
        color: token.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0
      },
      [iconCls]: {
        marginRight: {
          _skip_check_: true,
          value: token.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: `0 0 0 ${tabsHorizontalGutter}px`
      }
    }
  };
};
var genRtlStyle = (token) => {
  const {
    componentCls,
    tabsHorizontalGutter,
    iconCls,
    tabsCardGutter
  } = token;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: `0 0 0 ${tabsHorizontalGutter}px`
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: `${token.marginSM}px`
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: `${token.marginXS}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: `-${token.marginXXS}px`
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: "right"
        }
      }
    }
  };
};
var genTabsStyle = (token) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeight,
    tabsCardGutter,
    tabsHoverColor,
    tabsActiveColor,
    colorSplit
  } = token;
  return {
    [componentCls]: _extends(_extends(_extends(_extends({}, resetComponent(token)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardHorizontalPadding,
          background: "transparent",
          border: 0,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token.controlHeightLG / 8,
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: _extends({
          minWidth: `${tabsCardHeight}px`,
          marginLeft: {
            _skip_check_: true,
            value: `${tabsCardGutter}px`
          },
          padding: `0 ${token.paddingXS}px`,
          background: "transparent",
          border: `${token.lineWidth}px ${token.lineType} ${colorSplit}`,
          borderRadius: `${token.borderRadiusLG}px ${token.borderRadiusLG}px 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token.colorText,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseInOut}`,
          "&:hover": {
            color: tabsHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: tabsActiveColor
          }
        }, genFocusStyle(token))
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token.colorPrimary,
        pointerEvents: "none"
      }
    }), genTabStyle(token)), {
      // =========================== TabPanes ===========================
      [`${componentCls}-content`]: {
        position: "relative",
        display: "flex",
        width: "100%",
        ["&-animated"]: {
          transition: "margin 0.3s"
        }
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        outline: "none",
        flex: "none",
        width: "100%"
      }
    }),
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
};
var style_default10 = genComponentStyleHook("Tabs", (token) => {
  const tabsCardHeight = token.controlHeightLG;
  const tabsToken = merge(token, {
    tabsHoverColor: token.colorPrimaryHover,
    tabsActiveColor: token.colorPrimaryActive,
    tabsCardHorizontalPadding: `${(tabsCardHeight - Math.round(token.fontSize * token.lineHeight)) / 2 - token.lineWidth}px ${token.padding}px`,
    tabsCardHeight,
    tabsCardGutter: token.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: token.colorFillAlter,
    dropdownEdgeChildVerticalPadding: token.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [genSizeStyle(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), motion_default(tabsToken)];
}, (token) => ({
  zIndexPopup: token.zIndexPopupBase + 50
}));

// node_modules/ant-design-vue/es/tabs/src/Tabs.js
var uuid = 0;
var tabsProps = () => {
  return {
    prefixCls: {
      type: String
    },
    id: {
      type: String
    },
    popupClassName: String,
    getPopupContainer: functionType(),
    activeKey: {
      type: [String, Number]
    },
    defaultActiveKey: {
      type: [String, Number]
    },
    direction: stringType(),
    animated: someType([Boolean, Object]),
    renderTabBar: functionType(),
    tabBarGutter: {
      type: Number
    },
    tabBarStyle: objectType(),
    tabPosition: stringType(),
    destroyInactiveTabPane: booleanType(),
    hideAdd: Boolean,
    type: stringType(),
    size: stringType(),
    centered: Boolean,
    onEdit: functionType(),
    onChange: functionType(),
    onTabClick: functionType(),
    onTabScroll: functionType(),
    "onUpdate:activeKey": functionType(),
    // Accessibility
    locale: objectType(),
    onPrevClick: functionType(),
    onNextClick: functionType(),
    tabBarExtraContent: vue_types_default.any
  };
};
function parseTabList(children) {
  return children.map((node) => {
    if (isValidElement(node)) {
      const props2 = _extends({}, node.props || {});
      for (const [k, v] of Object.entries(props2)) {
        delete props2[k];
        props2[camelize(k)] = v;
      }
      const slots = node.children || {};
      const key = node.key !== void 0 ? node.key : void 0;
      const {
        tab = slots.tab,
        disabled,
        forceRender,
        closable,
        animated,
        active,
        destroyInactiveTabPane
      } = props2;
      return _extends(_extends({
        key
      }, props2), {
        node,
        closeIcon: slots.closeIcon,
        tab,
        disabled: disabled === "" || disabled,
        forceRender: forceRender === "" || forceRender,
        closable: closable === "" || closable,
        animated: animated === "" || animated,
        active: active === "" || active,
        destroyInactiveTabPane: destroyInactiveTabPane === "" || destroyInactiveTabPane
      });
    }
    return null;
  }).filter((tab) => tab);
}
var InternalTabs = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InternalTabs",
  inheritAttrs: false,
  props: _extends(_extends({}, initDefaultProps_default(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  })), {
    tabs: arrayType()
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    devWarning_default(!(props2.onPrevClick !== void 0) && !(props2.onNextClick !== void 0), "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead.");
    devWarning_default(!(props2.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead.");
    devWarning_default(!(slots.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
    const {
      prefixCls,
      direction,
      size,
      rootPrefixCls,
      getPopupContainer
    } = useConfigInject_default("tabs", props2);
    const [wrapSSR, hashId] = style_default10(prefixCls);
    const rtl = computed(() => direction.value === "rtl");
    const mergedAnimated = computed(() => {
      const {
        animated,
        tabPosition
      } = props2;
      if (animated === false || ["left", "right"].includes(tabPosition)) {
        return {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        return {
          inkBar: true,
          tabPane: true
        };
      } else {
        return _extends({
          inkBar: true,
          tabPane: false
        }, typeof animated === "object" ? animated : {});
      }
    });
    const [mobile, setMobile] = useState(false);
    onMounted(() => {
      setMobile(isMobile_default());
    });
    const [mergedActiveKey, setMergedActiveKey] = useMergedState(() => {
      var _a2;
      return (_a2 = props2.tabs[0]) === null || _a2 === void 0 ? void 0 : _a2.key;
    }, {
      value: computed(() => props2.activeKey),
      defaultValue: props2.defaultActiveKey
    });
    const [activeIndex, setActiveIndex] = useState(() => props2.tabs.findIndex((tab) => tab.key === mergedActiveKey.value));
    watchEffect(() => {
      var _a2;
      let newActiveIndex = props2.tabs.findIndex((tab) => tab.key === mergedActiveKey.value);
      if (newActiveIndex === -1) {
        newActiveIndex = Math.max(0, Math.min(activeIndex.value, props2.tabs.length - 1));
        setMergedActiveKey((_a2 = props2.tabs[newActiveIndex]) === null || _a2 === void 0 ? void 0 : _a2.key);
      }
      setActiveIndex(newActiveIndex);
    });
    const [mergedId, setMergedId] = useMergedState(null, {
      value: computed(() => props2.id)
    });
    const mergedTabPosition = computed(() => {
      if (mobile.value && !["left", "right"].includes(props2.tabPosition)) {
        return "top";
      } else {
        return props2.tabPosition;
      }
    });
    onMounted(() => {
      if (!props2.id) {
        setMergedId(`rc-tabs-${false ? "test" : uuid}`);
        uuid += 1;
      }
    });
    const onInternalTabClick = (key, e) => {
      var _a2, _b;
      (_a2 = props2.onTabClick) === null || _a2 === void 0 ? void 0 : _a2.call(props2, key, e);
      const isActiveChanged = key !== mergedActiveKey.value;
      setMergedActiveKey(key);
      if (isActiveChanged) {
        (_b = props2.onChange) === null || _b === void 0 ? void 0 : _b.call(props2, key);
      }
    };
    useProvideTabs({
      tabs: computed(() => props2.tabs),
      prefixCls
    });
    return () => {
      const {
        id,
        type,
        tabBarGutter,
        tabBarStyle,
        locale,
        destroyInactiveTabPane,
        renderTabBar = slots.renderTabBar,
        onTabScroll,
        hideAdd,
        centered
      } = props2;
      const sharedProps = {
        id: mergedId.value,
        activeKey: mergedActiveKey.value,
        animated: mergedAnimated.value,
        tabPosition: mergedTabPosition.value,
        rtl: rtl.value,
        mobile: mobile.value
      };
      let editable;
      if (type === "editable-card") {
        editable = {
          onEdit: (editType, _ref2) => {
            let {
              key,
              event
            } = _ref2;
            var _a2;
            (_a2 = props2.onEdit) === null || _a2 === void 0 ? void 0 : _a2.call(props2, editType === "add" ? event : key, editType);
          },
          removeIcon: () => createVNode(CloseOutlined_default, null, null),
          addIcon: slots.addIcon ? slots.addIcon : () => createVNode(PlusOutlined_default, null, null),
          showAdd: hideAdd !== true
        };
      }
      let tabNavBar;
      const tabNavBarProps = _extends(_extends({}, sharedProps), {
        moreTransitionName: `${rootPrefixCls.value}-slide-up`,
        editable,
        locale,
        tabBarGutter,
        onTabClick: onInternalTabClick,
        onTabScroll,
        style: tabBarStyle,
        getPopupContainer: getPopupContainer.value,
        popupClassName: classNames_default(props2.popupClassName, hashId.value)
      });
      if (renderTabBar) {
        tabNavBar = renderTabBar(_extends(_extends({}, tabNavBarProps), {
          DefaultTabBar: TabNavList_default
        }));
      } else {
        tabNavBar = createVNode(TabNavList_default, tabNavBarProps, pick_default(slots, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"]));
      }
      const pre = prefixCls.value;
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "id": id,
        "class": classNames_default(pre, `${pre}-${mergedTabPosition.value}`, {
          [hashId.value]: true,
          [`${pre}-${size.value}`]: size.value,
          [`${pre}-card`]: ["card", "editable-card"].includes(type),
          [`${pre}-editable-card`]: type === "editable-card",
          [`${pre}-centered`]: centered,
          [`${pre}-mobile`]: mobile.value,
          [`${pre}-editable`]: type === "editable-card",
          [`${pre}-rtl`]: rtl.value
        }, attrs.class)
      }), [tabNavBar, createVNode(TabPanelList_default, _objectSpread2(_objectSpread2({
        "destroyInactiveTabPane": destroyInactiveTabPane
      }, sharedProps), {}, {
        "animated": mergedAnimated.value
      }), null)]));
    };
  }
});
var Tabs_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATabs",
  inheritAttrs: false,
  props: initDefaultProps_default(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(props2, _ref3) {
    let {
      attrs,
      slots,
      emit
    } = _ref3;
    const handleChange = (key) => {
      emit("update:activeKey", key);
      emit("change", key);
    };
    return () => {
      var _a2;
      const tabs = parseTabList(flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)));
      return createVNode(InternalTabs, _objectSpread2(_objectSpread2(_objectSpread2({}, omit_default(props2, ["onUpdate:activeKey"])), attrs), {}, {
        "onChange": handleChange,
        "tabs": tabs
      }), slots);
    };
  }
});

// node_modules/ant-design-vue/es/tabs/src/TabPanelList/TabPane.js
var tabPaneProps = () => ({
  tab: vue_types_default.any,
  disabled: {
    type: Boolean
  },
  forceRender: {
    type: Boolean
  },
  closable: {
    type: Boolean
  },
  animated: {
    type: Boolean
  },
  active: {
    type: Boolean
  },
  destroyInactiveTabPane: {
    type: Boolean
  },
  // Pass by TabPaneList
  prefixCls: {
    type: String
  },
  tabKey: {
    type: [String, Number]
  },
  id: {
    type: String
  }
  // closeIcon: PropTypes.any,
});
var TabPane_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATabPane",
  inheritAttrs: false,
  __ANT_TAB_PANE: true,
  props: tabPaneProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const visited = ref(props2.forceRender);
    watch([() => props2.active, () => props2.destroyInactiveTabPane], () => {
      if (props2.active) {
        visited.value = true;
      } else if (props2.destroyInactiveTabPane) {
        visited.value = false;
      }
    }, {
      immediate: true
    });
    const mergedStyle = computed(() => {
      if (!props2.active) {
        if (props2.animated) {
          return {
            visibility: "hidden",
            height: 0,
            overflowY: "hidden"
          };
        } else {
          return {
            display: "none"
          };
        }
      }
      return {};
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        forceRender,
        id,
        active,
        tabKey
      } = props2;
      return createVNode("div", {
        "id": id && `${id}-panel-${tabKey}`,
        "role": "tabpanel",
        "tabindex": active ? 0 : -1,
        "aria-labelledby": id && `${id}-tab-${tabKey}`,
        "aria-hidden": !active,
        "style": [mergedStyle.value, attrs.style],
        "class": [`${prefixCls}-tabpane`, active && `${prefixCls}-tabpane-active`, attrs.class]
      }, [(active || visited.value || forceRender) && ((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]);
    };
  }
});

// node_modules/ant-design-vue/es/tabs/src/index.js
var src_default = Tabs_default;

// node_modules/ant-design-vue/es/tabs/index.js
src_default.TabPane = TabPane_default;
src_default.install = function(app) {
  app.component(src_default.name, src_default);
  app.component(TabPane_default.name, TabPane_default);
  return app;
};
var tabs_default = src_default;

// node_modules/ant-design-vue/es/card/style/index.js
var genCardHeadStyle = (token) => {
  const {
    antCls,
    componentCls,
    cardHeadHeight,
    cardPaddingBase,
    cardHeadTabsMarginBottom
  } = token;
  return _extends(_extends({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: cardHeadHeight,
    marginBottom: -1,
    padding: `0 ${cardPaddingBase}px`,
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.fontSizeLG,
    background: "transparent",
    borderBottom: `${token.lineWidth}px ${token.lineType} ${token.colorBorderSecondary}`,
    borderRadius: `${token.borderRadiusLG}px ${token.borderRadiusLG}px 0 0`
  }, clearFix()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": _extends(_extends({
      display: "inline-block",
      flex: 1
    }, textEllipsis), {
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: cardHeadTabsMarginBottom,
      color: token.colorText,
      fontWeight: "normal",
      fontSize: token.fontSize,
      "&-bar": {
        borderBottom: `${token.lineWidth}px ${token.lineType} ${token.colorBorderSecondary}`
      }
    }
  });
};
var genCardGridStyle = (token) => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${lineWidth}px 0 0 0 ${colorBorderSecondary},
      0 ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px 0 0 0 ${colorBorderSecondary} inset,
      0 ${lineWidth}px 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
var genCardActionsStyle = (token) => {
  const {
    componentCls,
    iconCls,
    cardActionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary
  } = token;
  return _extends(_extends({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: token.colorBgContainer,
    borderTop: `${token.lineWidth}px ${token.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${token.borderRadiusLG}px ${token.borderRadiusLG}px `
  }, clearFix()), {
    "& > li": {
      margin: cardActionsLiMargin,
      color: token.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token.cardActionsIconSize * 2,
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token.colorPrimary,
          transition: `color ${token.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token.colorTextDescription,
          lineHeight: `${token.fontSize * token.lineHeight}px`,
          transition: `color ${token.motionDurationMid}`,
          "&:hover": {
            color: token.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: `${cardActionsIconSize * token.lineHeight}px`
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${token.lineWidth}px ${token.lineType} ${colorBorderSecondary}`
      }
    }
  });
};
var genCardMetaStyle = (token) => _extends(_extends({
  margin: `-${token.marginXXS}px 0`,
  display: "flex"
}, clearFix()), {
  "&-avatar": {
    paddingInlineEnd: token.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token.marginXS
    }
  },
  "&-title": _extends({
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.fontSizeLG
  }, textEllipsis),
  "&-description": {
    color: token.colorTextDescription
  }
});
var genCardTypeInnerStyle = (token) => {
  const {
    componentCls,
    cardPaddingBase,
    colorFillAlter
  } = token;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${cardPaddingBase}px`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${token.padding}px ${cardPaddingBase}px`
    }
  };
};
var genCardLoadingStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
};
var genCardStyle2 = (token) => {
  const {
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadow,
    cardPaddingBase
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      position: "relative",
      background: token.colorBgContainer,
      borderRadius: token.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow
      },
      [`${componentCls}-head`]: genCardHeadStyle(token),
      [`${componentCls}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: "",
        fontWeight: "normal",
        fontSize: token.fontSize
      },
      [`${componentCls}-body`]: _extends({
        padding: cardPaddingBase,
        borderRadius: ` 0 0 ${token.borderRadiusLG}px ${token.borderRadiusLG}px`
      }, clearFix()),
      [`${componentCls}-grid`]: genCardGridStyle(token),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        img: {
          borderRadius: `${token.borderRadiusLG}px ${token.borderRadiusLG}px 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token),
      [`${componentCls}-meta`]: genCardMetaStyle(token)
    }),
    [`${componentCls}-bordered`]: {
      border: `${token.lineWidth}px ${token.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token.motionDurationMid}, border-color ${token.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: -token.lineWidth,
        marginInlineStart: -token.lineWidth,
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token),
    [`${componentCls}-loading`]: genCardLoadingStyle(token),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var genCardSizeStyle = (token) => {
  const {
    componentCls,
    cardPaddingSM,
    cardHeadHeightSM
  } = token;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: cardHeadHeightSM,
        padding: `0 ${cardPaddingSM}px`,
        fontSize: token.fontSize,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: cardPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          minHeight: cardHeadHeightSM,
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
};
var style_default11 = genComponentStyleHook("Card", (token) => {
  const cardToken = merge(token, {
    cardShadow: token.boxShadowCard,
    cardHeadHeight: token.fontSizeLG * token.lineHeightLG + token.padding * 2,
    cardHeadHeightSM: token.fontSize * token.lineHeight + token.paddingXS * 2,
    cardHeadPadding: token.padding,
    cardPaddingBase: token.paddingLG,
    cardHeadTabsMarginBottom: -token.padding - token.lineWidth,
    cardActionsLiMargin: `${token.paddingSM}px 0`,
    cardActionsIconSize: token.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    genCardStyle2(cardToken),
    // Size
    genCardSizeStyle(cardToken)
  ];
});

// node_modules/ant-design-vue/es/skeleton/Title.js
var skeletonTitleProps = () => ({
  prefixCls: String,
  width: {
    type: [Number, String]
  }
});
var SkeletonTitle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonTitle",
  props: skeletonTitleProps(),
  setup(props2) {
    return () => {
      const {
        prefixCls,
        width
      } = props2;
      const zWidth = typeof width === "number" ? `${width}px` : width;
      return createVNode("h3", {
        "class": prefixCls,
        "style": {
          width: zWidth
        }
      }, null);
    };
  }
});
var Title_default = SkeletonTitle;

// node_modules/ant-design-vue/es/skeleton/Paragraph.js
var skeletonParagraphProps = () => ({
  prefixCls: String,
  width: {
    type: [Number, String, Array]
  },
  rows: Number
});
var SkeletonParagraph = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonParagraph",
  props: skeletonParagraphProps(),
  setup(props2) {
    const getWidth2 = (index2) => {
      const {
        width,
        rows = 2
      } = props2;
      if (Array.isArray(width)) {
        return width[index2];
      }
      if (rows - 1 === index2) {
        return width;
      }
      return void 0;
    };
    return () => {
      const {
        prefixCls,
        rows
      } = props2;
      const rowList = [...Array(rows)].map((_, index2) => {
        const width = getWidth2(index2);
        return createVNode("li", {
          "key": index2,
          "style": {
            width: typeof width === "number" ? `${width}px` : width
          }
        }, null);
      });
      return createVNode("ul", {
        "class": prefixCls
      }, [rowList]);
    };
  }
});
var Paragraph_default = SkeletonParagraph;

// node_modules/ant-design-vue/es/skeleton/Element.js
var skeletonElementProps = () => ({
  prefixCls: String,
  size: [String, Number],
  shape: String,
  active: {
    type: Boolean,
    default: void 0
  }
});
var Element = (props2) => {
  const {
    prefixCls,
    size,
    shape
  } = props2;
  const sizeCls = classNames_default({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const shapeCls = classNames_default({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  });
  const sizeStyle = typeof size === "number" ? {
    width: `${size}px`,
    height: `${size}px`,
    lineHeight: `${size}px`
  } : {};
  return createVNode("span", {
    "class": classNames_default(prefixCls, sizeCls, shapeCls),
    "style": sizeStyle
  }, null);
};
Element.displayName = "SkeletonElement";
var Element_default = Element;

// node_modules/ant-design-vue/es/skeleton/style/index.js
var skeletonClsLoading = new Keyframes_default(`ant-skeleton-loading`, {
  "0%": {
    transform: "translateX(-37.5%)"
  },
  "100%": {
    transform: "translateX(37.5%)"
  }
});
var genSkeletonElementCommonSize = (size) => ({
  height: size,
  lineHeight: `${size}px`
});
var genSkeletonElementAvatarSize = (size) => _extends({
  width: size
}, genSkeletonElementCommonSize(size));
var genSkeletonColor = (token) => ({
  position: "relative",
  // fix https://github.com/ant-design/ant-design/issues/36444
  // https://monshin.github.io/202109/css/safari-border-radius-overflow-hidden/
  /* stylelint-disable-next-line property-no-vendor-prefix,value-no-vendor-prefix */
  zIndex: 0,
  overflow: "hidden",
  background: "transparent",
  "&::after": {
    position: "absolute",
    top: 0,
    insetInlineEnd: "-150%",
    bottom: 0,
    insetInlineStart: "-150%",
    background: token.skeletonLoadingBackground,
    animationName: skeletonClsLoading,
    animationDuration: token.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite",
    content: '""'
  }
});
var genSkeletonElementInputSize = (size) => _extends({
  width: size * 5,
  minWidth: size * 5
}, genSkeletonElementCommonSize(size));
var genSkeletonElementAvatar = (token) => {
  const {
    skeletonAvatarCls,
    color,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token;
  return {
    [`${skeletonAvatarCls}`]: _extends({
      display: "inline-block",
      verticalAlign: "top",
      background: color
    }, genSkeletonElementAvatarSize(controlHeight)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: _extends({}, genSkeletonElementAvatarSize(controlHeightLG)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: _extends({}, genSkeletonElementAvatarSize(controlHeightSM))
  };
};
var genSkeletonElementInput = (token) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    color
  } = token;
  return {
    [`${skeletonInputCls}`]: _extends({
      display: "inline-block",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM
    }, genSkeletonElementInputSize(controlHeight)),
    [`${skeletonInputCls}-lg`]: _extends({}, genSkeletonElementInputSize(controlHeightLG)),
    [`${skeletonInputCls}-sm`]: _extends({}, genSkeletonElementInputSize(controlHeightSM))
  };
};
var genSkeletonElementImageSize = (size) => _extends({
  width: size
}, genSkeletonElementCommonSize(size));
var genSkeletonElementImage = (token) => {
  const {
    skeletonImageCls,
    imageSizeBase,
    color,
    borderRadiusSM
  } = token;
  return {
    [`${skeletonImageCls}`]: _extends(_extends({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM
    }, genSkeletonElementImageSize(imageSizeBase * 2)), {
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: _extends(_extends({}, genSkeletonElementImageSize(imageSizeBase)), {
        maxWidth: imageSizeBase * 4,
        maxHeight: imageSizeBase * 4
      }),
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
};
var genSkeletonElementButtonShape = (token, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
};
var genSkeletonElementButtonSize = (size) => _extends({
  width: size * 2,
  minWidth: size * 2
}, genSkeletonElementCommonSize(size));
var genSkeletonElementButton = (token) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color
  } = token;
  return _extends(_extends(_extends(_extends(_extends({
    [`${skeletonButtonCls}`]: _extends({
      display: "inline-block",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM,
      width: controlHeight * 2,
      minWidth: controlHeight * 2
    }, genSkeletonElementButtonSize(controlHeight))
  }, genSkeletonElementButtonShape(token, controlHeight, skeletonButtonCls)), {
    [`${skeletonButtonCls}-lg`]: _extends({}, genSkeletonElementButtonSize(controlHeightLG))
  }), genSkeletonElementButtonShape(token, controlHeightLG, `${skeletonButtonCls}-lg`)), {
    [`${skeletonButtonCls}-sm`]: _extends({}, genSkeletonElementButtonSize(controlHeightSM))
  }), genSkeletonElementButtonShape(token, controlHeightSM, `${skeletonButtonCls}-sm`));
};
var genBaseStyle3 = (token) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color,
    padding,
    marginSM,
    borderRadius,
    skeletonTitleHeight,
    skeletonBlockRadius,
    skeletonParagraphLineHeight,
    controlHeightXS,
    skeletonParagraphMarginTop
  } = token;
  return {
    [`${componentCls}`]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        // Avatar
        [`${skeletonAvatarCls}`]: _extends({
          display: "inline-block",
          verticalAlign: "top",
          background: color
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: _extends({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}-sm`]: _extends({}, genSkeletonElementAvatarSize(controlHeightSM))
      },
      [`${componentCls}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${skeletonTitleCls}`]: {
          width: "100%",
          height: skeletonTitleHeight,
          background: color,
          borderRadius: skeletonBlockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        // paragraph
        [`${skeletonParagraphCls}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: skeletonParagraphLineHeight,
            listStyle: "none",
            background: color,
            borderRadius: skeletonBlockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-content`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-content`]: {
      // Title
      [`${skeletonTitleCls}`]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: skeletonParagraphMarginTop
        }
      }
    },
    // Skeleton element
    [`${componentCls}${componentCls}-element`]: _extends(_extends(_extends(_extends({
      display: "inline-block",
      width: "auto"
    }, genSkeletonElementButton(token)), genSkeletonElementAvatar(token)), genSkeletonElementInput(token)), genSkeletonElementImage(token)),
    // Skeleton Block Button, Input
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [`${skeletonButtonCls}`]: {
        width: "100%"
      },
      [`${skeletonInputCls}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: _extends({}, genSkeletonColor(token))
    }
  };
};
var style_default12 = genComponentStyleHook("Skeleton", (token) => {
  const {
    componentCls
  } = token;
  const skeletonToken = merge(token, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: token.controlHeight * 1.5,
    skeletonTitleHeight: token.controlHeight / 2,
    skeletonBlockRadius: token.borderRadiusSM,
    skeletonParagraphLineHeight: token.controlHeight / 2,
    skeletonParagraphMarginTop: token.marginLG + token.marginXXS,
    borderRadius: 100,
    skeletonLoadingBackground: `linear-gradient(90deg, ${token.color} 25%, ${token.colorGradientEnd} 37%, ${token.color} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [genBaseStyle3(skeletonToken)];
}, (token) => {
  const {
    colorFillContent,
    colorFill
  } = token;
  return {
    color: colorFillContent,
    colorGradientEnd: colorFill
  };
});

// node_modules/ant-design-vue/es/skeleton/Skeleton.js
var skeletonProps = () => ({
  active: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  avatar: {
    type: [Boolean, Object],
    default: void 0
  },
  title: {
    type: [Boolean, Object],
    default: void 0
  },
  paragraph: {
    type: [Boolean, Object],
    default: void 0
  },
  round: {
    type: Boolean,
    default: void 0
  }
});
function getComponentProps(prop) {
  if (prop && typeof prop === "object") {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return {
      size: "large",
      shape: "square"
    };
  }
  return {
    size: "large",
    shape: "circle"
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: "38%"
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: "50%"
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps2 = {};
  if (!hasAvatar || !hasTitle) {
    basicProps2.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps2.rows = 3;
  } else {
    basicProps2.rows = 2;
  }
  return basicProps2;
}
var Skeleton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeleton",
  props: initDefaultProps_default(skeletonProps(), {
    avatar: false,
    title: true,
    paragraph: true
  }),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("skeleton", props2);
    const [wrapSSR, hashId] = style_default12(prefixCls);
    return () => {
      var _a2;
      const {
        loading,
        avatar,
        title,
        paragraph,
        active,
        round
      } = props2;
      const pre = prefixCls.value;
      if (loading || props2.loading === void 0) {
        const hasAvatar = !!avatar || avatar === "";
        const hasTitle = !!title || title === "";
        const hasParagraph = !!paragraph || paragraph === "";
        let avatarNode;
        if (hasAvatar) {
          const avatarProps3 = _extends(_extends({
            prefixCls: `${pre}-avatar`
          }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
          avatarNode = createVNode("div", {
            "class": `${pre}-header`
          }, [createVNode(Element_default, avatarProps3, null)]);
        }
        let contentNode;
        if (hasTitle || hasParagraph) {
          let $title;
          if (hasTitle) {
            const titleProps2 = _extends(_extends({
              prefixCls: `${pre}-title`
            }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
            $title = createVNode(Title_default, titleProps2, null);
          }
          let paragraphNode;
          if (hasParagraph) {
            const paragraphProps2 = _extends(_extends({
              prefixCls: `${pre}-paragraph`
            }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
            paragraphNode = createVNode(Paragraph_default, paragraphProps2, null);
          }
          contentNode = createVNode("div", {
            "class": `${pre}-content`
          }, [$title, paragraphNode]);
        }
        const cls = classNames_default(pre, {
          [`${pre}-with-avatar`]: hasAvatar,
          [`${pre}-active`]: active,
          [`${pre}-rtl`]: direction.value === "rtl",
          [`${pre}-round`]: round,
          [hashId.value]: true
        });
        return wrapSSR(createVNode("div", {
          "class": cls
        }, [avatarNode, contentNode]));
      }
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
var Skeleton_default = Skeleton;

// node_modules/ant-design-vue/es/skeleton/Button.js
var skeletonButtonProps = () => {
  return _extends(_extends({}, skeletonElementProps()), {
    size: String,
    block: Boolean
  });
};
var SkeletonButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonButton",
  props: initDefaultProps_default(skeletonButtonProps(), {
    size: "default"
  }),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject_default("skeleton", props2);
    const [wrapSSR, hashId] = style_default12(prefixCls);
    const cls = computed(() => classNames_default(prefixCls.value, `${prefixCls.value}-element`, {
      [`${prefixCls.value}-active`]: props2.active,
      [`${prefixCls.value}-block`]: props2.block
    }, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode(Element_default, _objectSpread2(_objectSpread2({}, props2), {}, {
        "prefixCls": `${prefixCls.value}-button`
      }), null)]));
    };
  }
});
var Button_default = SkeletonButton;

// node_modules/ant-design-vue/es/skeleton/Input.js
var SkeletonInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonInput",
  props: _extends(_extends({}, omit_default(skeletonElementProps(), ["shape"])), {
    size: String,
    block: Boolean
  }),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject_default("skeleton", props2);
    const [wrapSSR, hashId] = style_default12(prefixCls);
    const cls = computed(() => classNames_default(prefixCls.value, `${prefixCls.value}-element`, {
      [`${prefixCls.value}-active`]: props2.active,
      [`${prefixCls.value}-block`]: props2.block
    }, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode(Element_default, _objectSpread2(_objectSpread2({}, props2), {}, {
        "prefixCls": `${prefixCls.value}-input`
      }), null)]));
    };
  }
});
var Input_default = SkeletonInput;

// node_modules/ant-design-vue/es/skeleton/Image.js
var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
var SkeletonImage = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonImage",
  props: omit_default(skeletonElementProps(), ["size", "shape", "active"]),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject_default("skeleton", props2);
    const [wrapSSR, hashId] = style_default12(prefixCls);
    const cls = computed(() => classNames_default(prefixCls.value, `${prefixCls.value}-element`, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode("div", {
        "class": `${prefixCls.value}-image`
      }, [createVNode("svg", {
        "viewBox": "0 0 1098 1024",
        "xmlns": "http://www.w3.org/2000/svg",
        "class": `${prefixCls.value}-image-svg`
      }, [createVNode("path", {
        "d": path,
        "class": `${prefixCls.value}-image-path`
      }, null)])])]));
    };
  }
});
var Image_default = SkeletonImage;

// node_modules/ant-design-vue/es/skeleton/Avatar.js
var avatarProps2 = () => {
  return _extends(_extends({}, skeletonElementProps()), {
    shape: String
  });
};
var SkeletonAvatar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonAvatar",
  props: initDefaultProps_default(avatarProps2(), {
    size: "default",
    shape: "circle"
  }),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject_default("skeleton", props2);
    const [wrapSSR, hashId] = style_default12(prefixCls);
    const cls = computed(() => classNames_default(prefixCls.value, `${prefixCls.value}-element`, {
      [`${prefixCls.value}-active`]: props2.active
    }, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode(Element_default, _objectSpread2(_objectSpread2({}, props2), {}, {
        "prefixCls": `${prefixCls.value}-avatar`
      }), null)]));
    };
  }
});
var Avatar_default2 = SkeletonAvatar;

// node_modules/ant-design-vue/es/skeleton/index.js
Skeleton_default.Button = Button_default;
Skeleton_default.Avatar = Avatar_default2;
Skeleton_default.Input = Input_default;
Skeleton_default.Image = Image_default;
Skeleton_default.Title = Title_default;
Skeleton_default.install = function(app) {
  app.component(Skeleton_default.name, Skeleton_default);
  app.component(Skeleton_default.Button.name, Button_default);
  app.component(Skeleton_default.Avatar.name, Avatar_default2);
  app.component(Skeleton_default.Input.name, Input_default);
  app.component(Skeleton_default.Image.name, Image_default);
  app.component(Skeleton_default.Title.name, Title_default);
  return app;
};
var skeleton_default = Skeleton_default;

// node_modules/ant-design-vue/es/card/Card.js
var {
  TabPane
} = tabs_default;
var cardProps = () => ({
  prefixCls: String,
  title: vue_types_default.any,
  extra: vue_types_default.any,
  bordered: {
    type: Boolean,
    default: true
  },
  bodyStyle: {
    type: Object,
    default: void 0
  },
  headStyle: {
    type: Object,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: false
  },
  hoverable: {
    type: Boolean,
    default: false
  },
  type: {
    type: String
  },
  size: {
    type: String
  },
  actions: vue_types_default.any,
  tabList: {
    type: Array
  },
  tabBarExtraContent: vue_types_default.any,
  activeTabKey: String,
  defaultActiveTabKey: String,
  cover: vue_types_default.any,
  onTabChange: {
    type: Function
  }
});
var Card = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACard",
  inheritAttrs: false,
  props: cardProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction,
      size
    } = useConfigInject_default("card", props2);
    const [wrapSSR, hashId] = style_default11(prefixCls);
    const getAction = (actions) => {
      const actionList = actions.map((action, index2) => isVNode(action) && !isEmptyElement(action) || !isVNode(action) ? createVNode("li", {
        "style": {
          width: `${100 / actions.length}%`
        },
        "key": `action-${index2}`
      }, [createVNode("span", null, [action])]) : null);
      return actionList;
    };
    const triggerTabChange = (key) => {
      var _a2;
      (_a2 = props2.onTabChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, key);
    };
    const isContainGrid = function() {
      let obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let containGrid;
      obj.forEach((element) => {
        if (element && isPlainObject_default(element.type) && element.type.__ANT_CARD_GRID) {
          containGrid = true;
        }
      });
      return containGrid;
    };
    return () => {
      var _a2, _b, _c, _d, _e, _f;
      const {
        headStyle = {},
        bodyStyle = {},
        loading,
        bordered = true,
        type,
        tabList,
        hoverable,
        activeTabKey,
        defaultActiveTabKey,
        tabBarExtraContent = filterEmptyWithUndefined((_a2 = slots.tabBarExtraContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots)),
        title = filterEmptyWithUndefined((_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots)),
        extra = filterEmptyWithUndefined((_c = slots.extra) === null || _c === void 0 ? void 0 : _c.call(slots)),
        actions = filterEmptyWithUndefined((_d = slots.actions) === null || _d === void 0 ? void 0 : _d.call(slots)),
        cover = filterEmptyWithUndefined((_e = slots.cover) === null || _e === void 0 ? void 0 : _e.call(slots))
      } = props2;
      const children = flattenChildren((_f = slots.default) === null || _f === void 0 ? void 0 : _f.call(slots));
      const pre = prefixCls.value;
      const classString = {
        [`${pre}`]: true,
        [hashId.value]: true,
        [`${pre}-loading`]: loading,
        [`${pre}-bordered`]: bordered,
        [`${pre}-hoverable`]: !!hoverable,
        [`${pre}-contain-grid`]: isContainGrid(children),
        [`${pre}-contain-tabs`]: tabList && tabList.length,
        [`${pre}-${size.value}`]: size.value,
        [`${pre}-type-${type}`]: !!type,
        [`${pre}-rtl`]: direction.value === "rtl"
      };
      const loadingBlock = createVNode(skeleton_default, {
        "loading": true,
        "active": true,
        "paragraph": {
          rows: 4
        },
        "title": false
      }, {
        default: () => [children]
      });
      const hasActiveTabKey = activeTabKey !== void 0;
      const tabsProps2 = {
        size: "large",
        [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
        onChange: triggerTabChange,
        class: `${pre}-head-tabs`
      };
      let head;
      const tabs = tabList && tabList.length ? createVNode(tabs_default, tabsProps2, {
        default: () => [tabList.map((item) => {
          const {
            tab: temp,
            slots: itemSlots
          } = item;
          const name = itemSlots === null || itemSlots === void 0 ? void 0 : itemSlots.tab;
          devWarning_default(!itemSlots, "Card", `tabList slots is deprecated, Please use \`customTab\` instead.`);
          let tab = temp !== void 0 ? temp : slots[name] ? slots[name](item) : null;
          tab = customRenderSlot(slots, "customTab", item, () => [tab]);
          return createVNode(TabPane, {
            "tab": tab,
            "key": item.key,
            "disabled": item.disabled
          }, null);
        })],
        rightExtra: tabBarExtraContent ? () => tabBarExtraContent : null
      }) : null;
      if (title || extra || tabs) {
        head = createVNode("div", {
          "class": `${pre}-head`,
          "style": headStyle
        }, [createVNode("div", {
          "class": `${pre}-head-wrapper`
        }, [title && createVNode("div", {
          "class": `${pre}-head-title`
        }, [title]), extra && createVNode("div", {
          "class": `${pre}-extra`
        }, [extra])]), tabs]);
      }
      const coverDom = cover ? createVNode("div", {
        "class": `${pre}-cover`
      }, [cover]) : null;
      const body = createVNode("div", {
        "class": `${pre}-body`,
        "style": bodyStyle
      }, [loading ? loadingBlock : children]);
      const actionDom = actions && actions.length ? createVNode("ul", {
        "class": `${pre}-actions`
      }, [getAction(actions)]) : null;
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({
        "ref": "cardContainerRef"
      }, attrs), {}, {
        "class": [classString, attrs.class]
      }), [head, coverDom, children && children.length ? body : null, actionDom]));
    };
  }
});
var Card_default = Card;

// node_modules/ant-design-vue/es/card/Meta.js
var cardMetaProps = () => ({
  prefixCls: String,
  title: vNodeType(),
  description: vNodeType(),
  avatar: vNodeType()
});
var Meta_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACardMeta",
  props: cardMetaProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("card", props2);
    return () => {
      const classString = {
        [`${prefixCls.value}-meta`]: true
      };
      const avatar = getPropsSlot(slots, props2, "avatar");
      const title = getPropsSlot(slots, props2, "title");
      const description = getPropsSlot(slots, props2, "description");
      const avatarDom = avatar ? createVNode("div", {
        "class": `${prefixCls.value}-meta-avatar`
      }, [avatar]) : null;
      const titleDom = title ? createVNode("div", {
        "class": `${prefixCls.value}-meta-title`
      }, [title]) : null;
      const descriptionDom = description ? createVNode("div", {
        "class": `${prefixCls.value}-meta-description`
      }, [description]) : null;
      const MetaDetail = titleDom || descriptionDom ? createVNode("div", {
        "class": `${prefixCls.value}-meta-detail`
      }, [titleDom, descriptionDom]) : null;
      return createVNode("div", {
        "class": classString
      }, [avatarDom, MetaDetail]);
    };
  }
});

// node_modules/ant-design-vue/es/card/Grid.js
var cardGridProps = () => ({
  prefixCls: String,
  hoverable: {
    type: Boolean,
    default: true
  }
});
var Grid_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACardGrid",
  __ANT_CARD_GRID: true,
  props: cardGridProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("card", props2);
    const classNames = computed(() => {
      return {
        [`${prefixCls.value}-grid`]: true,
        [`${prefixCls.value}-grid-hoverable`]: props2.hoverable
      };
    });
    return () => {
      var _a2;
      return createVNode("div", {
        "class": classNames.value
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});

// node_modules/ant-design-vue/es/card/index.js
Card_default.Meta = Meta_default;
Card_default.Grid = Grid_default;
Card_default.install = function(app) {
  app.component(Card_default.name, Card_default);
  app.component(Meta_default.name, Meta_default);
  app.component(Grid_default.name, Grid_default);
  return app;
};
var card_default = Card_default;

// node_modules/ant-design-vue/es/collapse/commonProps.js
var collapseProps = () => ({
  prefixCls: String,
  activeKey: someType([Array, Number, String]),
  defaultActiveKey: someType([Array, Number, String]),
  accordion: booleanType(),
  destroyInactivePanel: booleanType(),
  bordered: booleanType(),
  expandIcon: functionType(),
  openAnimation: vue_types_default.object,
  expandIconPosition: stringType(),
  collapsible: stringType(),
  ghost: booleanType(),
  onChange: functionType(),
  "onUpdate:activeKey": functionType()
});
var collapsePanelProps = () => ({
  openAnimation: vue_types_default.object,
  prefixCls: String,
  header: vue_types_default.any,
  headerClass: String,
  showArrow: booleanType(),
  isActive: booleanType(),
  destroyInactivePanel: booleanType(),
  /** @deprecated Use `collapsible="disabled"` instead */
  disabled: booleanType(),
  accordion: booleanType(),
  forceRender: booleanType(),
  expandIcon: functionType(),
  extra: vue_types_default.any,
  panelKey: someType(),
  collapsible: stringType(),
  role: String,
  onItemClick: functionType()
});

// node_modules/ant-design-vue/es/collapse/style/index.js
var genBaseStyle4 = (token) => {
  const {
    componentCls,
    collapseContentBg,
    padding,
    collapseContentPaddingHorizontal,
    collapseHeaderBg,
    collapseHeaderPadding,
    collapsePanelBorderRadius,
    lineWidth,
    lineType,
    colorBorder,
    colorText,
    colorTextHeading,
    colorTextDisabled,
    fontSize,
    lineHeight,
    marginSM,
    paddingSM,
    motionDurationSlow,
    fontSizeIcon
  } = token;
  const borderBase = `${lineWidth}px ${lineType} ${colorBorder}`;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      backgroundColor: collapseHeaderBg,
      border: borderBase,
      borderBottom: 0,
      borderRadius: `${collapsePanelBorderRadius}px`,
      [`&-rtl`]: {
        direction: "rtl"
      },
      [`& > ${componentCls}-item`]: {
        borderBottom: borderBase,
        [`&:last-child`]: {
          [`
            &,
            & > ${componentCls}-header`]: {
            borderRadius: `0 0 ${collapsePanelBorderRadius}px ${collapsePanelBorderRadius}px`
          }
        },
        [`> ${componentCls}-header`]: {
          position: "relative",
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          padding: collapseHeaderPadding,
          color: colorTextHeading,
          lineHeight,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}, visibility 0s`,
          [`> ${componentCls}-header-text`]: {
            flex: "auto"
          },
          "&:focus": {
            outline: "none"
          },
          // >>>>> Arrow
          [`${componentCls}-expand-icon`]: {
            height: fontSize * lineHeight,
            display: "flex",
            alignItems: "center",
            paddingInlineEnd: marginSM
          },
          [`${componentCls}-arrow`]: _extends(_extends({}, resetIcon()), {
            fontSize: fontSizeIcon,
            svg: {
              transition: `transform ${motionDurationSlow}`
            }
          }),
          // >>>>> Text
          [`${componentCls}-header-text`]: {
            marginInlineEnd: "auto"
          }
        },
        [`${componentCls}-header-collapsible-only`]: {
          cursor: "default",
          [`${componentCls}-header-text`]: {
            flex: "none",
            cursor: "pointer"
          },
          [`${componentCls}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`${componentCls}-icon-collapsible-only`]: {
          cursor: "default",
          [`${componentCls}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`&${componentCls}-no-arrow`]: {
          [`> ${componentCls}-header`]: {
            paddingInlineStart: paddingSM
          }
        }
      },
      [`${componentCls}-content`]: {
        color: colorText,
        backgroundColor: collapseContentBg,
        borderTop: borderBase,
        [`& > ${componentCls}-content-box`]: {
          padding: `${padding}px ${collapseContentPaddingHorizontal}px`
        },
        [`&-hidden`]: {
          display: "none"
        }
      },
      [`${componentCls}-item:last-child`]: {
        [`> ${componentCls}-content`]: {
          borderRadius: `0 0 ${collapsePanelBorderRadius}px ${collapsePanelBorderRadius}px`
        }
      },
      [`& ${componentCls}-item-disabled > ${componentCls}-header`]: {
        [`
          &,
          & > .arrow
        `]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // ========================== Icon Position ==========================
      [`&${componentCls}-icon-position-end`]: {
        [`& > ${componentCls}-item`]: {
          [`> ${componentCls}-header`]: {
            [`${componentCls}-expand-icon`]: {
              order: 1,
              paddingInlineEnd: 0,
              paddingInlineStart: marginSM
            }
          }
        }
      }
    })
  };
};
var genArrowStyle = (token) => {
  const {
    componentCls
  } = token;
  const fixedSelector = `> ${componentCls}-item > ${componentCls}-header ${componentCls}-arrow svg`;
  return {
    [`${componentCls}-rtl`]: {
      [fixedSelector]: {
        transform: `rotate(180deg)`
      }
    }
  };
};
var genBorderlessStyle = (token) => {
  const {
    componentCls,
    collapseHeaderBg,
    paddingXXS,
    colorBorder
  } = token;
  return {
    [`${componentCls}-borderless`]: {
      backgroundColor: collapseHeaderBg,
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: `1px solid ${colorBorder}`
      },
      [`
        > ${componentCls}-item:last-child,
        > ${componentCls}-item:last-child ${componentCls}-header
      `]: {
        borderRadius: 0
      },
      [`> ${componentCls}-item:last-child`]: {
        borderBottom: 0
      },
      [`> ${componentCls}-item > ${componentCls}-content`]: {
        backgroundColor: "transparent",
        borderTop: 0
      },
      [`> ${componentCls}-item > ${componentCls}-content > ${componentCls}-content-box`]: {
        paddingTop: paddingXXS
      }
    }
  };
};
var genGhostStyle = (token) => {
  const {
    componentCls,
    paddingSM
  } = token;
  return {
    [`${componentCls}-ghost`]: {
      backgroundColor: "transparent",
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: 0,
        [`> ${componentCls}-content`]: {
          backgroundColor: "transparent",
          border: 0,
          [`> ${componentCls}-content-box`]: {
            paddingBlock: paddingSM
          }
        }
      }
    }
  };
};
var style_default13 = genComponentStyleHook("Collapse", (token) => {
  const collapseToken = merge(token, {
    collapseContentBg: token.colorBgContainer,
    collapseHeaderBg: token.colorFillAlter,
    collapseHeaderPadding: `${token.paddingSM}px ${token.padding}px`,
    collapsePanelBorderRadius: token.borderRadiusLG,
    collapseContentPaddingHorizontal: 16
    // Fixed value
  });
  return [genBaseStyle4(collapseToken), genBorderlessStyle(collapseToken), genGhostStyle(collapseToken), genArrowStyle(collapseToken), collapse_default(collapseToken)];
});

// node_modules/ant-design-vue/es/collapse/Collapse.js
function getActiveKeysArray(activeKey) {
  let currentActiveKey = activeKey;
  if (!Array.isArray(currentActiveKey)) {
    const activeKeyType = typeof currentActiveKey;
    currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
  }
  return currentActiveKey.map((key) => String(key));
}
var Collapse_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapse",
  inheritAttrs: false,
  props: initDefaultProps_default(collapseProps(), {
    accordion: false,
    destroyInactivePanel: false,
    bordered: true,
    expandIconPosition: "start"
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const stateActiveKey = ref(getActiveKeysArray(firstNotUndefined_default([props2.activeKey, props2.defaultActiveKey])));
    watch(() => props2.activeKey, () => {
      stateActiveKey.value = getActiveKeysArray(props2.activeKey);
    }, {
      deep: true
    });
    const {
      prefixCls,
      direction,
      rootPrefixCls
    } = useConfigInject_default("collapse", props2);
    const [wrapSSR, hashId] = style_default13(prefixCls);
    const iconPosition = computed(() => {
      const {
        expandIconPosition
      } = props2;
      if (expandIconPosition !== void 0) {
        return expandIconPosition;
      }
      return direction.value === "rtl" ? "end" : "start";
    });
    const renderExpandIcon = (panelProps) => {
      const {
        expandIcon = slots.expandIcon
      } = props2;
      const icon = expandIcon ? expandIcon(panelProps) : createVNode(RightOutlined_default, {
        "rotate": panelProps.isActive ? 90 : void 0
      }, null);
      return createVNode("div", {
        "class": [`${prefixCls.value}-expand-icon`, hashId.value],
        "onClick": () => ["header", "icon"].includes(props2.collapsible) && onClickItem(panelProps.panelKey)
      }, [isValidElement(Array.isArray(expandIcon) ? icon[0] : icon) ? cloneElement(icon, {
        class: `${prefixCls.value}-arrow`
      }, false) : icon]);
    };
    const setActiveKey = (activeKey) => {
      if (props2.activeKey === void 0) {
        stateActiveKey.value = activeKey;
      }
      const newKey = props2.accordion ? activeKey[0] : activeKey;
      emit("update:activeKey", newKey);
      emit("change", newKey);
    };
    const onClickItem = (key) => {
      let activeKey = stateActiveKey.value;
      if (props2.accordion) {
        activeKey = activeKey[0] === key ? [] : [key];
      } else {
        activeKey = [...activeKey];
        const index2 = activeKey.indexOf(key);
        const isActive = index2 > -1;
        if (isActive) {
          activeKey.splice(index2, 1);
        } else {
          activeKey.push(key);
        }
      }
      setActiveKey(activeKey);
    };
    const getNewChild = (child, index2) => {
      var _a2, _b, _c;
      if (isEmptyElement(child))
        return;
      const activeKey = stateActiveKey.value;
      const {
        accordion,
        destroyInactivePanel,
        collapsible,
        openAnimation
      } = props2;
      const animation = openAnimation || collapseMotion_default(`${rootPrefixCls.value}-motion-collapse`);
      const key = String((_a2 = child.key) !== null && _a2 !== void 0 ? _a2 : index2);
      const {
        header = (_c = (_b = child.children) === null || _b === void 0 ? void 0 : _b.header) === null || _c === void 0 ? void 0 : _c.call(_b),
        headerClass,
        collapsible: childCollapsible,
        disabled
      } = child.props || {};
      let isActive = false;
      if (accordion) {
        isActive = activeKey[0] === key;
      } else {
        isActive = activeKey.indexOf(key) > -1;
      }
      let mergeCollapsible = childCollapsible !== null && childCollapsible !== void 0 ? childCollapsible : collapsible;
      if (disabled || disabled === "") {
        mergeCollapsible = "disabled";
      }
      const newProps = {
        key,
        panelKey: key,
        header,
        headerClass,
        isActive,
        prefixCls: prefixCls.value,
        destroyInactivePanel,
        openAnimation: animation,
        accordion,
        onItemClick: mergeCollapsible === "disabled" ? null : onClickItem,
        expandIcon: renderExpandIcon,
        collapsible: mergeCollapsible
      };
      return cloneElement(child, newProps);
    };
    const getItems = () => {
      var _a2;
      return flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)).map(getNewChild);
    };
    return () => {
      const {
        accordion,
        bordered,
        ghost
      } = props2;
      const collapseClassName = classNames_default(prefixCls.value, {
        [`${prefixCls.value}-borderless`]: !bordered,
        [`${prefixCls.value}-icon-position-${iconPosition.value}`]: true,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-ghost`]: !!ghost,
        [attrs.class]: !!attrs.class
      }, hashId.value);
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({
        "class": collapseClassName
      }, getDataAndAriaProps(attrs)), {}, {
        "style": attrs.style,
        "role": accordion ? "tablist" : null
      }), [getItems()]));
    };
  }
});

// node_modules/ant-design-vue/es/collapse/PanelContent.js
var PanelContent_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContent",
  props: collapsePanelProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const rendered = shallowRef(false);
    watchEffect(() => {
      if (props2.isActive || props2.forceRender) {
        rendered.value = true;
      }
    });
    return () => {
      var _a2;
      if (!rendered.value)
        return null;
      const {
        prefixCls,
        isActive,
        role
      } = props2;
      return createVNode("div", {
        "class": classNames_default(`${prefixCls}-content`, {
          [`${prefixCls}-content-active`]: isActive,
          [`${prefixCls}-content-inactive`]: !isActive
        }),
        "role": role
      }, [createVNode("div", {
        "class": `${prefixCls}-content-box`
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
    };
  }
});

// node_modules/ant-design-vue/es/collapse/CollapsePanel.js
var CollapsePanel_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapsePanel",
  inheritAttrs: false,
  props: initDefaultProps_default(collapsePanelProps(), {
    showArrow: true,
    isActive: false,
    onItemClick() {
    },
    headerClass: "",
    forceRender: false
  }),
  slots: Object,
  // emits: ['itemClick'],
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs
    } = _ref;
    devWarning_default(props2.disabled === void 0, "Collapse.Panel", '`disabled` is deprecated. Please use `collapsible="disabled"` instead.');
    const {
      prefixCls
    } = useConfigInject_default("collapse", props2);
    const handleItemClick = () => {
      emit("itemClick", props2.panelKey);
    };
    const handleKeyPress = (e) => {
      if (e.key === "Enter" || e.keyCode === 13 || e.which === 13) {
        handleItemClick();
      }
    };
    return () => {
      var _a2, _b;
      const {
        header = (_a2 = slots.header) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        headerClass,
        isActive,
        showArrow,
        destroyInactivePanel,
        accordion,
        forceRender,
        openAnimation,
        expandIcon = slots.expandIcon,
        extra = (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots),
        collapsible
      } = props2;
      const disabled = collapsible === "disabled";
      const prefixClsValue = prefixCls.value;
      const headerCls = classNames_default(`${prefixClsValue}-header`, {
        [headerClass]: headerClass,
        [`${prefixClsValue}-header-collapsible-only`]: collapsible === "header",
        [`${prefixClsValue}-icon-collapsible-only`]: collapsible === "icon"
      });
      const itemCls = classNames_default({
        [`${prefixClsValue}-item`]: true,
        [`${prefixClsValue}-item-active`]: isActive,
        [`${prefixClsValue}-item-disabled`]: disabled,
        [`${prefixClsValue}-no-arrow`]: !showArrow,
        [`${attrs.class}`]: !!attrs.class
      });
      let icon = createVNode("i", {
        "class": "arrow"
      }, null);
      if (showArrow && typeof expandIcon === "function") {
        icon = expandIcon(props2);
      }
      const panelContent = withDirectives(createVNode(PanelContent_default, {
        "prefixCls": prefixClsValue,
        "isActive": isActive,
        "forceRender": forceRender,
        "role": accordion ? "tabpanel" : null
      }, {
        default: slots.default
      }), [[vShow, isActive]]);
      const transitionProps = _extends({
        appear: false,
        css: false
      }, openAnimation);
      return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": itemCls
      }), [createVNode("div", {
        "class": headerCls,
        "onClick": () => !["header", "icon"].includes(collapsible) && handleItemClick(),
        "role": accordion ? "tab" : "button",
        "tabindex": disabled ? -1 : 0,
        "aria-expanded": isActive,
        "onKeypress": handleKeyPress
      }, [showArrow && icon, createVNode("span", {
        "onClick": () => collapsible === "header" && handleItemClick(),
        "class": `${prefixClsValue}-header-text`
      }, [header]), extra && createVNode("div", {
        "class": `${prefixClsValue}-extra`
      }, [extra])]), createVNode(Transition, transitionProps, {
        default: () => [!destroyInactivePanel || isActive ? panelContent : null]
      })]);
    };
  }
});

// node_modules/ant-design-vue/es/collapse/index.js
Collapse_default.Panel = CollapsePanel_default;
Collapse_default.install = function(app) {
  app.component(Collapse_default.name, Collapse_default);
  app.component(CollapsePanel_default.name, CollapsePanel_default);
  return app;
};
var collapse_default2 = Collapse_default;

// node_modules/ant-design-vue/es/_util/json2mq.js
var camel2hyphen = function(str) {
  return str.replace(/[A-Z]/g, function(match) {
    return "-" + match.toLowerCase();
  }).toLowerCase();
};
var isDimension = function(feature) {
  const re = /[height|width]$/;
  return re.test(feature);
};
var obj2mq = function(obj) {
  let mq = "";
  const features = Object.keys(obj);
  features.forEach(function(feature, index2) {
    let value = obj[feature];
    feature = camel2hyphen(feature);
    if (isDimension(feature) && typeof value === "number") {
      value = value + "px";
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += "not " + feature;
    } else {
      mq += "(" + feature + ": " + value + ")";
    }
    if (index2 < features.length - 1) {
      mq += " and ";
    }
  });
  return mq;
};
function json2mq_default(query) {
  let mq = "";
  if (typeof query === "string") {
    return query;
  }
  if (query instanceof Array) {
    query.forEach(function(q, index2) {
      mq += obj2mq(q);
      if (index2 < query.length - 1) {
        mq += ", ";
      }
    });
    return mq;
  }
  return obj2mq(query);
}

// node_modules/ant-design-vue/es/vc-slick/default-props.js
var defaultProps = {
  accessibility: {
    type: Boolean,
    default: true
  },
  // 自定义高度
  adaptiveHeight: {
    type: Boolean,
    default: false
  },
  afterChange: vue_types_default.any.def(null),
  arrows: {
    type: Boolean,
    default: true
  },
  autoplay: {
    type: Boolean,
    default: false
  },
  autoplaySpeed: vue_types_default.number.def(3e3),
  beforeChange: vue_types_default.any.def(null),
  centerMode: {
    type: Boolean,
    default: false
  },
  centerPadding: vue_types_default.string.def("50px"),
  cssEase: vue_types_default.string.def("ease"),
  dots: {
    type: Boolean,
    default: false
  },
  dotsClass: vue_types_default.string.def("slick-dots"),
  draggable: {
    type: Boolean,
    default: true
  },
  unslick: {
    type: Boolean,
    default: false
  },
  easing: vue_types_default.string.def("linear"),
  edgeFriction: vue_types_default.number.def(0.35),
  fade: {
    type: Boolean,
    default: false
  },
  focusOnSelect: {
    type: Boolean,
    default: false
  },
  infinite: {
    type: Boolean,
    default: true
  },
  initialSlide: vue_types_default.number.def(0),
  lazyLoad: vue_types_default.any.def(null),
  verticalSwiping: {
    type: Boolean,
    default: false
  },
  asNavFor: vue_types_default.any.def(null),
  // 圆点hover是否暂停
  pauseOnDotsHover: {
    type: Boolean,
    default: false
  },
  // focus是否暂停
  pauseOnFocus: {
    type: Boolean,
    default: false
  },
  // hover是否暂停
  pauseOnHover: {
    type: Boolean,
    default: true
  },
  responsive: vue_types_default.array,
  rows: vue_types_default.number.def(1),
  rtl: {
    type: Boolean,
    default: false
  },
  slide: vue_types_default.string.def("div"),
  slidesPerRow: vue_types_default.number.def(1),
  slidesToScroll: vue_types_default.number.def(1),
  slidesToShow: vue_types_default.number.def(1),
  speed: vue_types_default.number.def(500),
  swipe: {
    type: Boolean,
    default: true
  },
  swipeEvent: vue_types_default.any.def(null),
  swipeToSlide: {
    type: Boolean,
    default: false
  },
  touchMove: {
    type: Boolean,
    default: true
  },
  touchThreshold: vue_types_default.number.def(5),
  useCSS: {
    type: Boolean,
    default: true
  },
  useTransform: {
    type: Boolean,
    default: true
  },
  variableWidth: {
    type: Boolean,
    default: false
  },
  vertical: {
    type: Boolean,
    default: false
  },
  waitForAnimate: {
    type: Boolean,
    default: true
  },
  children: vue_types_default.array,
  __propsSymbol__: vue_types_default.any
};
var default_props_default = defaultProps;

// node_modules/ant-design-vue/es/vc-slick/initial-state.js
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  swiping: false,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
var initial_state_default = initialState;

// node_modules/ant-design-vue/es/vc-slick/utils/innerSliderUtils.js
function clamp(number, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number, upperBound));
}
var safePreventDefault = (event) => {
  const passiveEvents = ["touchstart", "touchmove", "wheel"];
  if (!passiveEvents.includes(event.type)) {
    event.preventDefault();
  }
};
var getOnDemandLazySlides = (spec) => {
  const onDemandSlides = [];
  const startIndex = lazyStartIndex(spec);
  const endIndex = lazyEndIndex(spec);
  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
};
var lazyStartIndex = (spec) => spec.currentSlide - lazySlidesOnLeft(spec);
var lazyEndIndex = (spec) => spec.currentSlide + lazySlidesOnRight(spec);
var lazySlidesOnLeft = (spec) => spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
var lazySlidesOnRight = (spec) => spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
var getWidth = (elem) => elem && elem.offsetWidth || 0;
var getHeight = (elem) => elem && elem.offsetHeight || 0;
var getSwipeDirection = function(touchObject) {
  let verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let swipeAngle;
  const xDist = touchObject.startX - touchObject.curX;
  const yDist = touchObject.startY - touchObject.curY;
  const r = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
};
var canGoNext = (spec) => {
  let canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
};
var extractObject = (spec, keys) => {
  const newObject = {};
  keys.forEach((key) => newObject[key] = spec[key]);
  return newObject;
};
var initializedState = (spec) => {
  const slideCount = spec.children.length;
  const listNode = spec.listRef;
  const listWidth = Math.ceil(getWidth(listNode));
  const trackNode = spec.trackRef;
  const trackWidth = Math.ceil(getWidth(trackNode));
  let slideWidth;
  if (!spec.vertical) {
    let centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  const slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  const listHeight = slideHeight * spec.slidesToShow;
  let currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  let lazyLoadedList = spec.lazyLoadedList || [];
  const slidesToLoad = getOnDemandLazySlides(_extends(_extends({}, spec), {
    currentSlide,
    lazyLoadedList
  }), spec);
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  const state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
};
var slideHandler = (spec) => {
  const {
    waitForAnimate,
    animating,
    fade,
    infinite,
    index: index2,
    slideCount,
    lazyLoad,
    currentSlide,
    centerMode,
    slidesToScroll,
    slidesToShow,
    useCSS
  } = spec;
  let {
    lazyLoadedList
  } = spec;
  if (waitForAnimate && animating)
    return {};
  let animationSlide = index2;
  let finalSlide;
  let animationLeft;
  let finalLeft;
  let state = {};
  let nextState = {};
  const targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index2 < 0 || index2 >= slideCount))
      return {};
    if (index2 < 0) {
      animationSlide = index2 + slideCount;
    } else if (index2 >= slideCount) {
      animationSlide = index2 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = {
      animating: false,
      targetSlide: animationSlide
    };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite)
        finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0) {
        finalSlide = slideCount - slideCount % slidesToScroll;
      }
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite)
        finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft(_extends(_extends({}, spec), {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_extends(_extends({}, spec), {
      slideIndex: finalSlide
    }));
    if (!infinite) {
      if (animationLeft === finalLeft)
        animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_extends(_extends({}, spec), {
        currentSlide: animationSlide
      })));
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_extends(_extends({}, spec), {
          left: finalLeft
        })),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_extends(_extends({}, spec), {
          left: animationLeft
        })),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_extends(_extends({}, spec), {
          left: finalLeft
        })),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return {
    state,
    nextState
  };
};
var changeSlide = (spec, options) => {
  let previousInt, slideOffset, targetSlide;
  const {
    slidesToScroll,
    slidesToShow,
    slideCount,
    currentSlide,
    targetSlide: previousTargetSlide,
    lazyLoad,
    infinite
  } = spec;
  const unevenOffset = slideCount % slidesToScroll !== 0;
  const indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      const direction = siblingDirection(_extends(_extends({}, spec), {
        targetSlide
      }));
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
};
var keyHandler = (e, accessibility, rtl) => {
  if (e.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility) {
    return "";
  }
  if (e.keyCode === 37)
    return rtl ? "next" : "previous";
  if (e.keyCode === 39)
    return rtl ? "previous" : "next";
  return "";
};
var swipeStart = (e, swipe, draggable) => {
  e.target.tagName === "IMG" && safePreventDefault(e);
  if (!swipe || !draggable && e.type.indexOf("mouse") !== -1)
    return "";
  return {
    dragging: true,
    touchObject: {
      startX: e.touches ? e.touches[0].pageX : e.clientX,
      startY: e.touches ? e.touches[0].pageY : e.clientY,
      curX: e.touches ? e.touches[0].pageX : e.clientX,
      curY: e.touches ? e.touches[0].pageY : e.clientY
    }
  };
};
var swipeMove = (e, spec) => {
  const {
    scrolling,
    animating,
    vertical,
    swipeToSlide,
    verticalSwiping,
    rtl,
    currentSlide,
    edgeFriction,
    edgeDragged,
    onEdge,
    swiped,
    swiping,
    slideCount,
    slidesToScroll,
    infinite,
    touchObject,
    swipeEvent,
    listHeight,
    listWidth
  } = spec;
  if (scrolling)
    return;
  if (animating)
    return safePreventDefault(e);
  if (vertical && swipeToSlide && verticalSwiping)
    safePreventDefault(e);
  let swipeLeft;
  let state = {};
  const curLeft = getTrackLeft(spec);
  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;
  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  const verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }
  if (verticalSwiping)
    touchObject.swipeLength = verticalSwipeLength;
  let positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping) {
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  }
  const dotCount = Math.ceil(slideCount / slidesToScroll);
  const swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  let touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = _extends(_extends({}, state), {
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS(_extends(_extends({}, spec), {
      left: swipeLeft
    }))
  });
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e);
  }
  return state;
};
var swipeEnd = (e, spec) => {
  const {
    dragging,
    swipe,
    touchObject,
    listWidth,
    touchThreshold,
    verticalSwiping,
    listHeight,
    swipeToSlide,
    scrolling,
    onSwipe,
    targetSlide,
    currentSlide,
    infinite
  } = spec;
  if (!dragging) {
    if (swipe)
      safePreventDefault(e);
    return {};
  }
  const minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  const swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  const state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    let slideCount, newSlide;
    const activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    const currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS(_extends(_extends({}, spec), {
      left: currentLeft
    }));
  }
  return state;
};
var getNavigableIndexes = (spec) => {
  const max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  let breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  let counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  const indexes = [];
  while (breakpoint < max) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
};
var checkNavigable = (spec, index2) => {
  const navigables = getNavigableIndexes(spec);
  let prevNavigable = 0;
  if (index2 > navigables[navigables.length - 1]) {
    index2 = navigables[navigables.length - 1];
  } else {
    for (const n in navigables) {
      if (index2 < navigables[n]) {
        index2 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n];
    }
  }
  return index2;
};
var getSlideCount = (spec) => {
  const centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    let swipedSlide;
    const slickList = spec.listRef;
    const slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every((slide) => {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    const currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    const slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
};
var checkSpecKeys = (spec, keysArray) => keysArray.reduce((value, key) => value && spec.hasOwnProperty(key), true) ? null : console.error("Keys Missing:", spec);
var getTrackCSS = (spec) => {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  let trackWidth, trackHeight;
  const trackChildren = spec.slideCount + 2 * spec.slidesToShow;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    trackHeight = trackChildren * spec.slideHeight;
  }
  let style = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    const WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    const transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    const msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style = _extends(_extends({}, style), {
      WebkitTransform,
      transform,
      msTransform
    });
  } else {
    if (spec.vertical) {
      style["top"] = spec.left;
    } else {
      style["left"] = spec.left;
    }
  }
  if (spec.fade)
    style = {
      opacity: 1
    };
  if (trackWidth)
    style.width = trackWidth + "px";
  if (trackHeight)
    style.height = trackHeight + "px";
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style.marginLeft = spec.left + "px";
    } else {
      style.marginTop = spec.left + "px";
    }
  }
  return style;
};
var getTrackAnimateCSS = (spec) => {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  const style = getTrackCSS(spec);
  if (spec.useTransform) {
    style.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style;
};
var getTrackLeft = (spec) => {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  const {
    slideIndex,
    trackRef,
    infinite,
    centerMode,
    slideCount,
    slidesToShow,
    slidesToScroll,
    slideWidth,
    listWidth,
    variableWidth,
    slideHeight,
    fade,
    vertical
  } = spec;
  let slideOffset = 0;
  let targetLeft;
  let targetSlide;
  let verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  let slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    let targetSlideIndex;
    const trackElem = trackRef;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (let slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
};
var getPreClones = (spec) => {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = (spec) => {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  return spec.slideCount;
};
var getTotalSlides = (spec) => spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
var siblingDirection = (spec) => {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
};
var slidesOnRight = (_ref) => {
  let {
    slidesToShow,
    centerMode,
    rtl,
    centerPadding
  } = _ref;
  if (centerMode) {
    let right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      right += 1;
    if (rtl && slidesToShow % 2 === 0)
      right += 1;
    return right;
  }
  if (rtl) {
    return 0;
  }
  return slidesToShow - 1;
};
var slidesOnLeft = (_ref2) => {
  let {
    slidesToShow,
    centerMode,
    rtl,
    centerPadding
  } = _ref2;
  if (centerMode) {
    let left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      left += 1;
    if (!rtl && slidesToShow % 2 === 0)
      left += 1;
    return left;
  }
  if (rtl) {
    return slidesToShow - 1;
  }
  return 0;
};
var canUseDOM = () => !!(typeof window !== "undefined" && window.document && window.document.createElement);

// node_modules/ant-design-vue/es/vc-slick/track.js
var getSlideClasses = (spec) => {
  let slickActive, slickCenter;
  let centerOffset, index2;
  if (spec.rtl) {
    index2 = spec.slideCount - 1 - spec.index;
  } else {
    index2 = spec.index;
  }
  const slickCloned = index2 < 0 || index2 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;
    if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;
  }
  let focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  const slickCurrent = index2 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
    // dubious in case of RTL
  };
};
var getSlideStyle = function(spec) {
  const style = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style.width = spec.slideWidth + (typeof spec.slideWidth === "number" ? "px" : "");
  }
  if (spec.fade) {
    style.position = "relative";
    if (spec.vertical) {
      style.top = -spec.index * parseInt(spec.slideHeight) + "px";
    } else {
      style.left = -spec.index * parseInt(spec.slideWidth) + "px";
    }
    style.opacity = spec.currentSlide === spec.index ? 1 : 0;
    if (spec.useCSS) {
      style.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style;
};
var getKey = (child, fallbackKey) => child.key + "-" + fallbackKey;
var renderSlides = function(spec, children) {
  let key;
  const slides = [];
  const preCloneSlides = [];
  const postCloneSlides = [];
  const childrenCount = children.length;
  const startIndex = lazyStartIndex(spec);
  const endIndex = lazyEndIndex(spec);
  children.forEach((elem, index2) => {
    let child;
    const childOnClickOptions = {
      message: "children",
      index: index2,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {
      child = elem;
    } else {
      child = createVNode("div");
    }
    const childStyle = getSlideStyle(_extends(_extends({}, spec), {
      index: index2
    }));
    const slideClass = child.props.class || "";
    let slideClasses = getSlideClasses(_extends(_extends({}, spec), {
      index: index2
    }));
    slides.push(deepCloneElement(child, {
      key: "original" + getKey(child, index2),
      tabindex: "-1",
      "data-index": index2,
      "aria-hidden": !slideClasses["slick-active"],
      class: classNames_default(slideClasses, slideClass),
      style: _extends(_extends({
        outline: "none"
      }, child.props.style || {}), childStyle),
      onClick: () => {
        if (spec.focusOnSelect) {
          spec.focusOnSelect(childOnClickOptions);
        }
      }
    }));
    if (spec.infinite && spec.fade === false) {
      const preCloneNo = childrenCount - index2;
      if (preCloneNo <= getPreClones(spec) && childrenCount !== spec.slidesToShow) {
        key = -preCloneNo;
        if (key >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_extends(_extends({}, spec), {
          index: key
        }));
        preCloneSlides.push(deepCloneElement(child, {
          key: "precloned" + getKey(child, key),
          class: classNames_default(slideClasses, slideClass),
          tabindex: "-1",
          "data-index": key,
          "aria-hidden": !slideClasses["slick-active"],
          style: _extends(_extends({}, child.props.style || {}), childStyle),
          onClick: () => {
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
      if (childrenCount !== spec.slidesToShow) {
        key = childrenCount + index2;
        if (key < endIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_extends(_extends({}, spec), {
          index: key
        }));
        postCloneSlides.push(deepCloneElement(child, {
          key: "postcloned" + getKey(child, key),
          tabindex: "-1",
          "data-index": key,
          "aria-hidden": !slideClasses["slick-active"],
          class: classNames_default(slideClasses, slideClass),
          style: _extends(_extends({}, child.props.style || {}), childStyle),
          onClick: () => {
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
};
var Track = (_, _ref) => {
  let {
    attrs,
    slots
  } = _ref;
  const slides = renderSlides(attrs, flattenChildren(slots === null || slots === void 0 ? void 0 : slots.default()));
  const {
    onMouseenter,
    onMouseover,
    onMouseleave
  } = attrs;
  const mouseEvents = {
    onMouseenter,
    onMouseover,
    onMouseleave
  };
  const trackProps = _extends({
    class: "slick-track",
    style: attrs.trackStyle
  }, mouseEvents);
  return createVNode("div", trackProps, [slides]);
};
Track.inheritAttrs = false;
var track_default = Track;

// node_modules/ant-design-vue/es/vc-slick/dots.js
var getDotCount = function(spec) {
  let dots;
  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots;
};
var Dots = (_, _ref) => {
  let {
    attrs
  } = _ref;
  const {
    slideCount,
    slidesToScroll,
    slidesToShow,
    infinite,
    currentSlide,
    appendDots,
    customPaging,
    clickHandler,
    dotsClass,
    onMouseenter,
    onMouseover,
    onMouseleave
  } = attrs;
  const dotCount = getDotCount({
    slideCount,
    slidesToScroll,
    slidesToShow,
    infinite
  });
  const mouseEvents = {
    onMouseenter,
    onMouseover,
    onMouseleave
  };
  let dots = [];
  for (let i = 0; i < dotCount; i++) {
    let onClick = function(e) {
      if (e) {
        e.preventDefault();
      }
      clickHandler(dotOptions);
    };
    const _rightBound = (i + 1) * slidesToScroll - 1;
    const rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
    const _leftBound = rightBound - (slidesToScroll - 1);
    const leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
    const className = classNames_default({
      "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
    });
    const dotOptions = {
      message: "dots",
      index: i,
      slidesToScroll,
      currentSlide
    };
    dots = dots.concat(createVNode("li", {
      "key": i,
      "class": className
    }, [cloneElement(customPaging({
      i
    }), {
      onClick
    })]));
  }
  return cloneElement(appendDots({
    dots
  }), _extends({
    class: dotsClass
  }, mouseEvents));
};
Dots.inheritAttrs = false;
var dots_default = Dots;

// node_modules/ant-design-vue/es/vc-slick/arrows.js
function noop2() {
}
function handler(options, handle, e) {
  if (e) {
    e.preventDefault();
  }
  handle(options, e);
}
var PrevArrow = (_, _ref) => {
  let {
    attrs
  } = _ref;
  const {
    clickHandler,
    infinite,
    currentSlide,
    slideCount,
    slidesToShow
  } = attrs;
  const prevClasses = {
    "slick-arrow": true,
    "slick-prev": true
  };
  let prevHandler = function(e) {
    handler({
      message: "previous"
    }, clickHandler, e);
  };
  if (!infinite && (currentSlide === 0 || slideCount <= slidesToShow)) {
    prevClasses["slick-disabled"] = true;
    prevHandler = noop2;
  }
  const prevArrowProps = {
    key: "0",
    "data-role": "none",
    class: prevClasses,
    style: {
      display: "block"
    },
    onClick: prevHandler
  };
  const customProps = {
    currentSlide,
    slideCount
  };
  let prevArrow;
  if (attrs.prevArrow) {
    prevArrow = cloneElement(attrs.prevArrow(_extends(_extends({}, prevArrowProps), customProps)), {
      key: "0",
      class: prevClasses,
      style: {
        display: "block"
      },
      onClick: prevHandler
    }, false);
  } else {
    prevArrow = createVNode("button", _objectSpread2({
      "key": "0",
      "type": "button"
    }, prevArrowProps), [" ", createTextVNode("Previous")]);
  }
  return prevArrow;
};
PrevArrow.inheritAttrs = false;
var NextArrow = (_, _ref2) => {
  let {
    attrs
  } = _ref2;
  const {
    clickHandler,
    currentSlide,
    slideCount
  } = attrs;
  const nextClasses = {
    "slick-arrow": true,
    "slick-next": true
  };
  let nextHandler = function(e) {
    handler({
      message: "next"
    }, clickHandler, e);
  };
  if (!canGoNext(attrs)) {
    nextClasses["slick-disabled"] = true;
    nextHandler = noop2;
  }
  const nextArrowProps = {
    key: "1",
    "data-role": "none",
    class: classNames_default(nextClasses),
    style: {
      display: "block"
    },
    onClick: nextHandler
  };
  const customProps = {
    currentSlide,
    slideCount
  };
  let nextArrow;
  if (attrs.nextArrow) {
    nextArrow = cloneElement(attrs.nextArrow(_extends(_extends({}, nextArrowProps), customProps)), {
      key: "1",
      class: classNames_default(nextClasses),
      style: {
        display: "block"
      },
      onClick: nextHandler
    }, false);
  } else {
    nextArrow = createVNode("button", _objectSpread2({
      "key": "1",
      "type": "button"
    }, nextArrowProps), [" ", createTextVNode("Next")]);
  }
  return nextArrow;
};
NextArrow.inheritAttrs = false;

// node_modules/ant-design-vue/es/vc-slick/inner-slider.js
var __rest6 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function noop3() {
}
var inner_slider_default = {
  name: "InnerSlider",
  mixins: [BaseMixin_default],
  inheritAttrs: false,
  props: _extends({}, default_props_default),
  data() {
    this.preProps = _extends({}, this.$props);
    this.list = null;
    this.track = null;
    this.callbackTimers = [];
    this.clickable = true;
    this.debouncedResize = null;
    const ssrState = this.ssrInit();
    return _extends(_extends(_extends({}, initial_state_default), {
      currentSlide: this.initialSlide,
      slideCount: this.children.length
    }), ssrState);
  },
  watch: {
    autoplay(newValue, oldValue) {
      if (!oldValue && newValue) {
        this.handleAutoPlay("playing");
      } else if (newValue) {
        this.handleAutoPlay("update");
      } else {
        this.pause("paused");
      }
    },
    __propsSymbol__() {
      const nextProps = this.$props;
      const spec = _extends(_extends({
        listRef: this.list,
        trackRef: this.track
      }, nextProps), this.$data);
      let setTrackStyle = false;
      for (const key of Object.keys(this.preProps)) {
        if (!nextProps.hasOwnProperty(key)) {
          setTrackStyle = true;
          break;
        }
        if (typeof nextProps[key] === "object" || typeof nextProps[key] === "function" || typeof nextProps[key] === "symbol") {
          continue;
        }
        if (nextProps[key] !== this.preProps[key]) {
          setTrackStyle = true;
          break;
        }
      }
      this.updateState(spec, setTrackStyle, () => {
        if (this.currentSlide >= nextProps.children.length) {
          this.changeSlide({
            message: "index",
            index: nextProps.children.length - nextProps.slidesToShow,
            currentSlide: this.currentSlide
          });
        }
        if (!this.preProps.autoplay && nextProps.autoplay) {
          this.handleAutoPlay("playing");
        } else if (nextProps.autoplay) {
          this.handleAutoPlay("update");
        } else {
          this.pause("paused");
        }
      });
      this.preProps = _extends({}, nextProps);
    }
  },
  mounted() {
    this.__emit("init");
    if (this.lazyLoad) {
      const slidesToLoad = getOnDemandLazySlides(_extends(_extends({}, this.$props), this.$data));
      if (slidesToLoad.length > 0) {
        this.setState((prevState) => ({
          lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
        }));
        this.__emit("lazyLoad", slidesToLoad);
      }
    }
    this.$nextTick(() => {
      const spec = _extends({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props);
      this.updateState(spec, true, () => {
        this.adaptHeight();
        this.autoplay && this.handleAutoPlay("playing");
      });
      if (this.lazyLoad === "progressive") {
        this.lazyLoadTimer = setInterval(this.progressiveLazyLoad, 1e3);
      }
      this.ro = new ResizeObserver_es_default(() => {
        if (this.animating) {
          this.onWindowResized(false);
          this.callbackTimers.push(setTimeout(() => this.onWindowResized(), this.speed));
        } else {
          this.onWindowResized();
        }
      });
      this.ro.observe(this.list);
      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), (slide) => {
        slide.onfocus = this.$props.pauseOnFocus ? this.onSlideFocus : null;
        slide.onblur = this.$props.pauseOnFocus ? this.onSlideBlur : null;
      });
      if (window.addEventListener) {
        window.addEventListener("resize", this.onWindowResized);
      } else {
        window.attachEvent("onresize", this.onWindowResized);
      }
    });
  },
  beforeUnmount() {
    var _a2;
    if (this.animationEndCallback) {
      clearTimeout(this.animationEndCallback);
    }
    if (this.lazyLoadTimer) {
      clearInterval(this.lazyLoadTimer);
    }
    if (this.callbackTimers.length) {
      this.callbackTimers.forEach((timer) => clearTimeout(timer));
      this.callbackTimers = [];
    }
    if (window.addEventListener) {
      window.removeEventListener("resize", this.onWindowResized);
    } else {
      window.detachEvent("onresize", this.onWindowResized);
    }
    if (this.autoplayTimer) {
      clearInterval(this.autoplayTimer);
    }
    (_a2 = this.ro) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
  },
  updated() {
    this.checkImagesLoad();
    this.__emit("reInit");
    if (this.lazyLoad) {
      const slidesToLoad = getOnDemandLazySlides(_extends(_extends({}, this.$props), this.$data));
      if (slidesToLoad.length > 0) {
        this.setState((prevState) => ({
          lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
        }));
        this.__emit("lazyLoad");
      }
    }
    this.adaptHeight();
  },
  methods: {
    listRefHandler(ref2) {
      this.list = ref2;
    },
    trackRefHandler(ref2) {
      this.track = ref2;
    },
    adaptHeight() {
      if (this.adaptiveHeight && this.list) {
        const elem = this.list.querySelector(`[data-index="${this.currentSlide}"]`);
        this.list.style.height = getHeight(elem) + "px";
      }
    },
    onWindowResized(setTrackStyle) {
      if (this.debouncedResize)
        this.debouncedResize.cancel();
      this.debouncedResize = debounce_default(() => this.resizeWindow(setTrackStyle), 50);
      this.debouncedResize();
    },
    resizeWindow() {
      let setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const isTrackMounted = Boolean(this.track);
      if (!isTrackMounted)
        return;
      const spec = _extends(_extends({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props), this.$data);
      this.updateState(spec, setTrackStyle, () => {
        if (this.autoplay) {
          this.handleAutoPlay("update");
        } else {
          this.pause("paused");
        }
      });
      this.setState({
        animating: false
      });
      clearTimeout(this.animationEndCallback);
      delete this.animationEndCallback;
    },
    updateState(spec, setTrackStyle, callback) {
      const updatedState = initializedState(spec);
      spec = _extends(_extends(_extends({}, spec), updatedState), {
        slideIndex: updatedState.currentSlide
      });
      const targetLeft = getTrackLeft(spec);
      spec = _extends(_extends({}, spec), {
        left: targetLeft
      });
      const trackStyle = getTrackCSS(spec);
      if (setTrackStyle || this.children.length !== spec.children.length) {
        updatedState["trackStyle"] = trackStyle;
      }
      this.setState(updatedState, callback);
    },
    ssrInit() {
      const children = this.children;
      if (this.variableWidth) {
        let trackWidth2 = 0;
        let trackLeft2 = 0;
        const childrenWidths = [];
        const preClones = getPreClones(_extends(_extends(_extends({}, this.$props), this.$data), {
          slideCount: children.length
        }));
        const postClones = getPostClones(_extends(_extends(_extends({}, this.$props), this.$data), {
          slideCount: children.length
        }));
        children.forEach((child) => {
          var _a2, _b;
          const childWidth = ((_b = (_a2 = child.props.style) === null || _a2 === void 0 ? void 0 : _a2.width) === null || _b === void 0 ? void 0 : _b.split("px")[0]) || 0;
          childrenWidths.push(childWidth);
          trackWidth2 += childWidth;
        });
        for (let i = 0; i < preClones; i++) {
          trackLeft2 += childrenWidths[childrenWidths.length - 1 - i];
          trackWidth2 += childrenWidths[childrenWidths.length - 1 - i];
        }
        for (let i = 0; i < postClones; i++) {
          trackWidth2 += childrenWidths[i];
        }
        for (let i = 0; i < this.currentSlide; i++) {
          trackLeft2 += childrenWidths[i];
        }
        const trackStyle2 = {
          width: trackWidth2 + "px",
          left: -trackLeft2 + "px"
        };
        if (this.centerMode) {
          const currentWidth = `${childrenWidths[this.currentSlide]}px`;
          trackStyle2.left = `calc(${trackStyle2.left} + (100% - ${currentWidth}) / 2 ) `;
        }
        return {
          trackStyle: trackStyle2
        };
      }
      const childrenCount = children.length;
      const spec = _extends(_extends(_extends({}, this.$props), this.$data), {
        slideCount: childrenCount
      });
      const slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
      const trackWidth = 100 / this.slidesToShow * slideCount;
      const slideWidth = 100 / slideCount;
      let trackLeft = -slideWidth * (getPreClones(spec) + this.currentSlide) * trackWidth / 100;
      if (this.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }
      const trackStyle = {
        width: trackWidth + "%",
        left: trackLeft + "%"
      };
      return {
        slideWidth: slideWidth + "%",
        trackStyle
      };
    },
    checkImagesLoad() {
      const images = this.list && this.list.querySelectorAll && this.list.querySelectorAll(".slick-slide img") || [];
      const imagesCount = images.length;
      let loadedCount = 0;
      Array.prototype.forEach.call(images, (image) => {
        const handler2 = () => ++loadedCount && loadedCount >= imagesCount && this.onWindowResized();
        if (!image.onclick) {
          image.onclick = () => image.parentNode.focus();
        } else {
          const prevClickHandler = image.onclick;
          image.onclick = () => {
            prevClickHandler();
            image.parentNode.focus();
          };
        }
        if (!image.onload) {
          if (this.$props.lazyLoad) {
            image.onload = () => {
              this.adaptHeight();
              this.callbackTimers.push(setTimeout(this.onWindowResized, this.speed));
            };
          } else {
            image.onload = handler2;
            image.onerror = () => {
              handler2();
              this.__emit("lazyLoadError");
            };
          }
        }
      });
    },
    progressiveLazyLoad() {
      const slidesToLoad = [];
      const spec = _extends(_extends({}, this.$props), this.$data);
      for (let index2 = this.currentSlide; index2 < this.slideCount + getPostClones(spec); index2++) {
        if (this.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      for (let index2 = this.currentSlide - 1; index2 >= -getPreClones(spec); index2--) {
        if (this.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      if (slidesToLoad.length > 0) {
        this.setState((state) => ({
          lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
        }));
        this.__emit("lazyLoad", slidesToLoad);
      } else {
        if (this.lazyLoadTimer) {
          clearInterval(this.lazyLoadTimer);
          delete this.lazyLoadTimer;
        }
      }
    },
    slideHandler(index2) {
      let dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const {
        asNavFor,
        beforeChange,
        speed,
        afterChange
      } = this.$props;
      const {
        state,
        nextState
      } = slideHandler(_extends(_extends(_extends({
        index: index2
      }, this.$props), this.$data), {
        trackRef: this.track,
        useCSS: this.useCSS && !dontAnimate
      }));
      if (!state)
        return;
      beforeChange && beforeChange(this.currentSlide, state.currentSlide);
      const slidesToLoad = state.lazyLoadedList.filter((value) => this.lazyLoadedList.indexOf(value) < 0);
      if (this.$attrs.onLazyLoad && slidesToLoad.length > 0) {
        this.__emit("lazyLoad", slidesToLoad);
      }
      if (!this.$props.waitForAnimate && this.animationEndCallback) {
        clearTimeout(this.animationEndCallback);
        afterChange && afterChange(this.currentSlide);
        delete this.animationEndCallback;
      }
      this.setState(state, () => {
        if (asNavFor && this.asNavForIndex !== index2) {
          this.asNavForIndex = index2;
          asNavFor.innerSlider.slideHandler(index2);
        }
        if (!nextState)
          return;
        this.animationEndCallback = setTimeout(() => {
          const {
            animating
          } = nextState, firstBatch = __rest6(nextState, ["animating"]);
          this.setState(firstBatch, () => {
            this.callbackTimers.push(setTimeout(() => this.setState({
              animating
            }), 10));
            afterChange && afterChange(state.currentSlide);
            delete this.animationEndCallback;
          });
        }, speed);
      });
    },
    changeSlide(options) {
      let dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const spec = _extends(_extends({}, this.$props), this.$data);
      const targetSlide = changeSlide(spec, options);
      if (targetSlide !== 0 && !targetSlide)
        return;
      if (dontAnimate === true) {
        this.slideHandler(targetSlide, dontAnimate);
      } else {
        this.slideHandler(targetSlide);
      }
      this.$props.autoplay && this.handleAutoPlay("update");
      if (this.$props.focusOnSelect) {
        const nodes = this.list.querySelectorAll(".slick-current");
        nodes[0] && nodes[0].focus();
      }
    },
    clickHandler(e) {
      if (this.clickable === false) {
        e.stopPropagation();
        e.preventDefault();
      }
      this.clickable = true;
    },
    keyHandler(e) {
      const dir = keyHandler(e, this.accessibility, this.rtl);
      dir !== "" && this.changeSlide({
        message: dir
      });
    },
    selectHandler(options) {
      this.changeSlide(options);
    },
    disableBodyScroll() {
      const preventDefault = (e) => {
        e = e || window.event;
        if (e.preventDefault)
          e.preventDefault();
        e.returnValue = false;
      };
      window.ontouchmove = preventDefault;
    },
    enableBodyScroll() {
      window.ontouchmove = null;
    },
    swipeStart(e) {
      if (this.verticalSwiping) {
        this.disableBodyScroll();
      }
      const state = swipeStart(e, this.swipe, this.draggable);
      state !== "" && this.setState(state);
    },
    swipeMove(e) {
      const state = swipeMove(e, _extends(_extends(_extends({}, this.$props), this.$data), {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      if (!state)
        return;
      if (state["swiping"]) {
        this.clickable = false;
      }
      this.setState(state);
    },
    swipeEnd(e) {
      const state = swipeEnd(e, _extends(_extends(_extends({}, this.$props), this.$data), {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      if (!state)
        return;
      const triggerSlideHandler = state["triggerSlideHandler"];
      delete state["triggerSlideHandler"];
      this.setState(state);
      if (triggerSlideHandler === void 0)
        return;
      this.slideHandler(triggerSlideHandler);
      if (this.$props.verticalSwiping) {
        this.enableBodyScroll();
      }
    },
    touchEnd(e) {
      this.swipeEnd(e);
      this.clickable = true;
    },
    slickPrev() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "previous"
      }), 0));
    },
    slickNext() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "next"
      }), 0));
    },
    slickGoTo(slide) {
      let dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide))
        return "";
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "index",
        index: slide,
        currentSlide: this.currentSlide
      }, dontAnimate), 0));
    },
    play() {
      let nextIndex;
      if (this.rtl) {
        nextIndex = this.currentSlide - this.slidesToScroll;
      } else {
        if (canGoNext(_extends(_extends({}, this.$props), this.$data))) {
          nextIndex = this.currentSlide + this.slidesToScroll;
        } else {
          return false;
        }
      }
      this.slideHandler(nextIndex);
    },
    handleAutoPlay(playType) {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
      }
      const autoplaying = this.autoplaying;
      if (playType === "update") {
        if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
          return;
        }
      } else if (playType === "leave") {
        if (autoplaying === "paused" || autoplaying === "focused") {
          return;
        }
      } else if (playType === "blur") {
        if (autoplaying === "paused" || autoplaying === "hovered") {
          return;
        }
      }
      this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50);
      this.setState({
        autoplaying: "playing"
      });
    },
    pause(pauseType) {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
      const autoplaying = this.autoplaying;
      if (pauseType === "paused") {
        this.setState({
          autoplaying: "paused"
        });
      } else if (pauseType === "focused") {
        if (autoplaying === "hovered" || autoplaying === "playing") {
          this.setState({
            autoplaying: "focused"
          });
        }
      } else {
        if (autoplaying === "playing") {
          this.setState({
            autoplaying: "hovered"
          });
        }
      }
    },
    onDotsOver() {
      this.autoplay && this.pause("hovered");
    },
    onDotsLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onTrackOver() {
      this.autoplay && this.pause("hovered");
    },
    onTrackLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onSlideFocus() {
      this.autoplay && this.pause("focused");
    },
    onSlideBlur() {
      this.autoplay && this.autoplaying === "focused" && this.handleAutoPlay("blur");
    },
    customPaging(_ref) {
      let {
        i
      } = _ref;
      return createVNode("button", null, [i + 1]);
    },
    appendDots(_ref2) {
      let {
        dots
      } = _ref2;
      return createVNode("ul", {
        "style": {
          display: "block"
        }
      }, [dots]);
    }
  },
  render() {
    const className = classNames_default("slick-slider", this.$attrs.class, {
      "slick-vertical": this.vertical,
      "slick-initialized": true
    });
    const spec = _extends(_extends({}, this.$props), this.$data);
    let trackProps = extractObject(spec, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
    const {
      pauseOnHover
    } = this.$props;
    trackProps = _extends(_extends({}, trackProps), {
      focusOnSelect: this.focusOnSelect && this.clickable ? this.selectHandler : null,
      ref: this.trackRefHandler,
      onMouseleave: pauseOnHover ? this.onTrackLeave : noop3,
      onMouseover: pauseOnHover ? this.onTrackOver : noop3
    });
    let dots;
    if (this.dots === true && this.slideCount >= this.slidesToShow) {
      let dotProps = extractObject(spec, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "infinite", "appendDots"]);
      dotProps.customPaging = this.customPaging;
      dotProps.appendDots = this.appendDots;
      const {
        customPaging,
        appendDots
      } = this.$slots;
      if (customPaging) {
        dotProps.customPaging = customPaging;
      }
      if (appendDots) {
        dotProps.appendDots = appendDots;
      }
      const {
        pauseOnDotsHover
      } = this.$props;
      dotProps = _extends(_extends({}, dotProps), {
        clickHandler: this.changeSlide,
        onMouseover: pauseOnDotsHover ? this.onDotsOver : noop3,
        onMouseleave: pauseOnDotsHover ? this.onDotsLeave : noop3
      });
      dots = createVNode(dots_default, dotProps, null);
    }
    let prevArrow, nextArrow;
    const arrowProps = extractObject(spec, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow"]);
    arrowProps.clickHandler = this.changeSlide;
    const {
      prevArrow: prevArrowCustom,
      nextArrow: nextArrowCustom
    } = this.$slots;
    if (prevArrowCustom) {
      arrowProps.prevArrow = prevArrowCustom;
    }
    if (nextArrowCustom) {
      arrowProps.nextArrow = nextArrowCustom;
    }
    if (this.arrows) {
      prevArrow = createVNode(PrevArrow, arrowProps, null);
      nextArrow = createVNode(NextArrow, arrowProps, null);
    }
    let verticalHeightStyle = null;
    if (this.vertical) {
      verticalHeightStyle = {
        height: typeof this.listHeight === "number" ? `${this.listHeight}px` : this.listHeight
      };
    }
    let centerPaddingStyle = null;
    if (this.vertical === false) {
      if (this.centerMode === true) {
        centerPaddingStyle = {
          padding: "0px " + this.centerPadding
        };
      }
    } else {
      if (this.centerMode === true) {
        centerPaddingStyle = {
          padding: this.centerPadding + " 0px"
        };
      }
    }
    const listStyle = _extends(_extends({}, verticalHeightStyle), centerPaddingStyle);
    const touchMove = this.touchMove;
    let listProps2 = {
      ref: this.listRefHandler,
      class: "slick-list",
      style: listStyle,
      onClick: this.clickHandler,
      onMousedown: touchMove ? this.swipeStart : noop3,
      onMousemove: this.dragging && touchMove ? this.swipeMove : noop3,
      onMouseup: touchMove ? this.swipeEnd : noop3,
      onMouseleave: this.dragging && touchMove ? this.swipeEnd : noop3,
      [supportsPassive_default ? "onTouchstartPassive" : "onTouchstart"]: touchMove ? this.swipeStart : noop3,
      [supportsPassive_default ? "onTouchmovePassive" : "onTouchmove"]: this.dragging && touchMove ? this.swipeMove : noop3,
      onTouchend: touchMove ? this.touchEnd : noop3,
      onTouchcancel: this.dragging && touchMove ? this.swipeEnd : noop3,
      onKeydown: this.accessibility ? this.keyHandler : noop3
    };
    let innerSliderProps = {
      class: className,
      dir: "ltr",
      style: this.$attrs.style
    };
    if (this.unslick) {
      listProps2 = {
        class: "slick-list",
        ref: this.listRefHandler
      };
      innerSliderProps = {
        class: className
      };
    }
    return createVNode("div", innerSliderProps, [!this.unslick ? prevArrow : "", createVNode("div", listProps2, [createVNode(track_default, trackProps, {
      default: () => [this.children]
    })]), !this.unslick ? nextArrow : "", !this.unslick ? dots : ""]);
  }
};

// node_modules/ant-design-vue/es/vc-slick/slider.js
var slider_default = defineComponent({
  name: "Slider",
  mixins: [BaseMixin_default],
  inheritAttrs: false,
  props: _extends({}, default_props_default),
  data() {
    this._responsiveMediaHandlers = [];
    return {
      breakpoint: null
    };
  },
  // handles responsive breakpoints
  mounted() {
    if (this.responsive) {
      const breakpoints = this.responsive.map((breakpt) => breakpt.breakpoint);
      breakpoints.sort((x, y) => x - y);
      breakpoints.forEach((breakpoint, index2) => {
        let bQuery;
        if (index2 === 0) {
          bQuery = json2mq_default({
            minWidth: 0,
            maxWidth: breakpoint
          });
        } else {
          bQuery = json2mq_default({
            minWidth: breakpoints[index2 - 1] + 1,
            maxWidth: breakpoint
          });
        }
        canUseDOM() && this.media(bQuery, () => {
          this.setState({
            breakpoint
          });
        });
      });
      const query = json2mq_default({
        minWidth: breakpoints.slice(-1)[0]
      });
      canUseDOM() && this.media(query, () => {
        this.setState({
          breakpoint: null
        });
      });
    }
  },
  beforeUnmount() {
    this._responsiveMediaHandlers.forEach(function(obj) {
      obj.mql.removeListener(obj.listener);
    });
  },
  methods: {
    innerSliderRefHandler(ref2) {
      this.innerSlider = ref2;
    },
    media(query, handler2) {
      const mql = window.matchMedia(query);
      const listener = (_ref) => {
        let {
          matches
        } = _ref;
        if (matches) {
          handler2();
        }
      };
      mql.addListener(listener);
      listener(mql);
      this._responsiveMediaHandlers.push({
        mql,
        query,
        listener
      });
    },
    slickPrev() {
      var _a2;
      (_a2 = this.innerSlider) === null || _a2 === void 0 ? void 0 : _a2.slickPrev();
    },
    slickNext() {
      var _a2;
      (_a2 = this.innerSlider) === null || _a2 === void 0 ? void 0 : _a2.slickNext();
    },
    slickGoTo(slide) {
      let dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _a2;
      (_a2 = this.innerSlider) === null || _a2 === void 0 ? void 0 : _a2.slickGoTo(slide, dontAnimate);
    },
    slickPause() {
      var _a2;
      (_a2 = this.innerSlider) === null || _a2 === void 0 ? void 0 : _a2.pause("paused");
    },
    slickPlay() {
      var _a2;
      (_a2 = this.innerSlider) === null || _a2 === void 0 ? void 0 : _a2.handleAutoPlay("play");
    }
  },
  render() {
    var _a2;
    let settings;
    let newProps;
    if (this.breakpoint) {
      newProps = this.responsive.filter((resp) => resp.breakpoint === this.breakpoint);
      settings = newProps[0].settings === "unslick" ? "unslick" : _extends(_extends({}, this.$props), newProps[0].settings);
    } else {
      settings = _extends({}, this.$props);
    }
    if (settings.centerMode) {
      if (settings.slidesToScroll > 1 && true) {
        console.warn(`slidesToScroll should be equal to 1 in centerMode, you are using ${settings.slidesToScroll}`);
      }
      settings.slidesToScroll = 1;
    }
    if (settings.fade) {
      if (settings.slidesToShow > 1 && true) {
        console.warn(`slidesToShow should be equal to 1 when fade is true, you're using ${settings.slidesToShow}`);
      }
      if (settings.slidesToScroll > 1 && true) {
        console.warn(`slidesToScroll should be equal to 1 when fade is true, you're using ${settings.slidesToScroll}`);
      }
      settings.slidesToShow = 1;
      settings.slidesToScroll = 1;
    }
    let children = getSlot(this) || [];
    children = children.filter((child) => {
      if (typeof child === "string") {
        return !!child.trim();
      }
      return !!child;
    });
    if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
      console.warn(`variableWidth is not supported in case of rows > 1 or slidesPerRow > 1`);
      settings.variableWidth = false;
    }
    const newChildren = [];
    let currentWidth = null;
    for (let i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
      const newSlide = [];
      for (let j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
        const row = [];
        for (let k = j; k < j + settings.slidesPerRow; k += 1) {
          if (settings.variableWidth && ((_a2 = children[k].props) === null || _a2 === void 0 ? void 0 : _a2.style)) {
            currentWidth = children[k].props.style.width;
          }
          if (k >= children.length)
            break;
          row.push(cloneElement(children[k], {
            key: 100 * i + 10 * j + k,
            tabindex: -1,
            style: {
              width: `${100 / settings.slidesPerRow}%`,
              display: "inline-block"
            }
          }));
        }
        newSlide.push(createVNode("div", {
          "key": 10 * i + j
        }, [row]));
      }
      if (settings.variableWidth) {
        newChildren.push(createVNode("div", {
          "key": i,
          "style": {
            width: currentWidth
          }
        }, [newSlide]));
      } else {
        newChildren.push(createVNode("div", {
          "key": i
        }, [newSlide]));
      }
    }
    if (settings === "unslick") {
      const className = "regular slider " + (this.className || "");
      return createVNode("div", {
        "class": className
      }, [children]);
    } else if (newChildren.length <= settings.slidesToShow) {
      settings.unslick = true;
    }
    const sliderProps2 = _extends(_extends(_extends({}, this.$attrs), settings), {
      children: newChildren,
      ref: this.innerSliderRefHandler
    });
    return createVNode(inner_slider_default, _objectSpread2(_objectSpread2({}, sliderProps2), {}, {
      "__propsSymbol__": []
    }), this.$slots);
  }
});

// node_modules/ant-design-vue/es/vc-slick/index.js
var vc_slick_default = slider_default;

// node_modules/ant-design-vue/es/carousel/style/index.js
var genCarouselStyle = (token) => {
  const {
    componentCls,
    antCls,
    carouselArrowSize,
    carouselDotOffset,
    marginXXS
  } = token;
  const arrowOffset = -carouselArrowSize * 1.25;
  const carouselDotMargin = marginXXS;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          // https://github.com/ant-design/ant-design/issues/23294
          [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          // fix Carousel content height not match parent node
          // when children is empty node
          // https://github.com/ant-design/ant-design/issues/25878
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      },
      ".slick-arrow.slick-hidden": {
        display: "none"
      },
      // Arrows
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        display: "block",
        width: carouselArrowSize,
        height: carouselArrowSize,
        marginTop: -carouselArrowSize / 2,
        padding: 0,
        color: "transparent",
        fontSize: 0,
        lineHeight: 0,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        "&:hover, &:focus": {
          color: "transparent",
          background: "transparent",
          outline: "none",
          "&::before": {
            opacity: 1
          }
        },
        "&.slick-disabled::before": {
          opacity: 0.25
        }
      },
      ".slick-prev": {
        insetInlineStart: arrowOffset,
        "&::before": {
          content: '"←"'
        }
      },
      ".slick-next": {
        insetInlineEnd: arrowOffset,
        "&::before": {
          content: '"→"'
        }
      },
      // Dots
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: carouselDotOffset
        },
        "&-top": {
          top: carouselDotOffset,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: token.dotWidth,
          height: token.dotHeight,
          marginInline: carouselDotMargin,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${token.motionDurationSlow}`,
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: token.dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: token.colorBgContainer,
            border: 0,
            borderRadius: 1,
            outline: "none",
            cursor: "pointer",
            opacity: 0.3,
            transition: `all ${token.motionDurationSlow}`,
            "&: hover, &:focus": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: -carouselDotMargin,
              content: '""'
            }
          },
          "&.slick-active": {
            width: token.dotWidthActive,
            "& button": {
              background: token.colorBgContainer,
              opacity: 1
            },
            "&: hover, &:focus": {
              opacity: 1
            }
          }
        }
      }
    })
  };
};
var genCarouselVerticalStyle = (token) => {
  const {
    componentCls,
    carouselDotOffset,
    marginXXS
  } = token;
  const reverseSizeOfDot = {
    width: token.dotHeight,
    height: token.dotWidth
  };
  return {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: token.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-left": {
          insetInlineEnd: "auto",
          insetInlineStart: carouselDotOffset
        },
        "&-right": {
          insetInlineEnd: carouselDotOffset,
          insetInlineStart: "auto"
        },
        li: _extends(_extends({}, reverseSizeOfDot), {
          margin: `${marginXXS}px 0`,
          verticalAlign: "baseline",
          button: reverseSizeOfDot,
          "&.slick-active": _extends(_extends({}, reverseSizeOfDot), {
            button: reverseSizeOfDot
          })
        })
      }
    }
  };
};
var genCarouselRtlStyle = (token) => {
  const {
    componentCls
  } = token;
  return [{
    [`${componentCls}-rtl`]: {
      direction: "rtl",
      // Dots
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "row-reverse"
        }
      }
    }
  }, {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "column"
        }
      }
    }
  }];
};
var style_default14 = genComponentStyleHook("Carousel", (token) => {
  const {
    controlHeightLG,
    controlHeightSM
  } = token;
  const carouselToken = merge(token, {
    carouselArrowSize: controlHeightLG / 2,
    carouselDotOffset: controlHeightSM / 2
  });
  return [genCarouselStyle(carouselToken), genCarouselVerticalStyle(carouselToken), genCarouselRtlStyle(carouselToken)];
}, {
  dotWidth: 16,
  dotHeight: 3,
  dotWidthActive: 24
});

// node_modules/ant-design-vue/es/carousel/index.js
var __rest7 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var carouselProps = () => ({
  effect: stringType(),
  dots: booleanType(true),
  vertical: booleanType(),
  autoplay: booleanType(),
  easing: String,
  beforeChange: functionType(),
  afterChange: functionType(),
  // style: PropTypes.React.CSSProperties,
  prefixCls: String,
  accessibility: booleanType(),
  nextArrow: vue_types_default.any,
  prevArrow: vue_types_default.any,
  pauseOnHover: booleanType(),
  // className: String,
  adaptiveHeight: booleanType(),
  arrows: booleanType(false),
  autoplaySpeed: Number,
  centerMode: booleanType(),
  centerPadding: String,
  cssEase: String,
  dotsClass: String,
  draggable: booleanType(false),
  fade: booleanType(),
  focusOnSelect: booleanType(),
  infinite: booleanType(),
  initialSlide: Number,
  lazyLoad: stringType(),
  rtl: booleanType(),
  slide: String,
  slidesToShow: Number,
  slidesToScroll: Number,
  speed: Number,
  swipe: booleanType(),
  swipeToSlide: booleanType(),
  swipeEvent: functionType(),
  touchMove: booleanType(),
  touchThreshold: Number,
  variableWidth: booleanType(),
  useCSS: booleanType(),
  slickGoTo: Number,
  responsive: Array,
  dotPosition: stringType(),
  verticalSwiping: booleanType(false)
});
var Carousel = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACarousel",
  inheritAttrs: false,
  props: carouselProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const slickRef = ref();
    const goTo = function(slide) {
      let dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _a2;
      (_a2 = slickRef.value) === null || _a2 === void 0 ? void 0 : _a2.slickGoTo(slide, dontAnimate);
    };
    expose({
      goTo,
      autoplay: (palyType) => {
        var _a2, _b;
        (_b = (_a2 = slickRef.value) === null || _a2 === void 0 ? void 0 : _a2.innerSlider) === null || _b === void 0 ? void 0 : _b.handleAutoPlay(palyType);
      },
      prev: () => {
        var _a2;
        (_a2 = slickRef.value) === null || _a2 === void 0 ? void 0 : _a2.slickPrev();
      },
      next: () => {
        var _a2;
        (_a2 = slickRef.value) === null || _a2 === void 0 ? void 0 : _a2.slickNext();
      },
      innerSlider: computed(() => {
        var _a2;
        return (_a2 = slickRef.value) === null || _a2 === void 0 ? void 0 : _a2.innerSlider;
      })
    });
    watchEffect(() => {
      warning_default2(props2.vertical === void 0, "Carousel", "`vertical` is deprecated, please use `dotPosition` instead.");
    });
    const {
      prefixCls,
      direction
    } = useConfigInject_default("carousel", props2);
    const [wrapSSR, hashId] = style_default14(prefixCls);
    const dotPosition = computed(() => {
      if (props2.dotPosition)
        return props2.dotPosition;
      if (props2.vertical !== void 0)
        return props2.vertical ? "right" : "bottom";
      return "bottom";
    });
    const vertical = computed(() => dotPosition.value === "left" || dotPosition.value === "right");
    const dsClass = computed(() => {
      const dotsClass = "slick-dots";
      return classNames_default({
        [dotsClass]: true,
        [`${dotsClass}-${dotPosition.value}`]: true,
        [`${props2.dotsClass}`]: !!props2.dotsClass
      });
    });
    return () => {
      const {
        dots,
        arrows,
        draggable,
        effect
      } = props2;
      const {
        class: cls,
        style
      } = attrs, restAttrs = __rest7(attrs, ["class", "style"]);
      const fade = effect === "fade" ? true : props2.fade;
      const className = classNames_default(prefixCls.value, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-vertical`]: vertical.value,
        [`${cls}`]: !!cls
      }, hashId.value);
      return wrapSSR(createVNode("div", {
        "class": className,
        "style": style
      }, [createVNode(vc_slick_default, _objectSpread2(_objectSpread2(_objectSpread2({
        "ref": slickRef
      }, props2), restAttrs), {}, {
        "dots": !!dots,
        "dotsClass": dsClass.value,
        "arrows": arrows,
        "draggable": draggable,
        "fade": fade,
        "vertical": vertical.value
      }), slots)]));
    };
  }
});
var carousel_default = withInstall(Carousel);

// node_modules/ant-design-vue/es/vc-cascader/utils/commonUtil.js
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
var SHOW_PARENT = "SHOW_PARENT";
var SHOW_CHILD = "SHOW_CHILD";
function toPathKey(value) {
  return value.join(VALUE_SPLIT);
}
function toPathKeys(value) {
  return value.map(toPathKey);
}
function toPathValueStr(pathKey) {
  return pathKey.split(VALUE_SPLIT);
}
function fillFieldNames(fieldNames) {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  const val = value || "value";
  return {
    label: label || "label",
    value: val,
    key: val,
    children: children || "children"
  };
}
function isLeaf(option, fieldNames) {
  var _a2, _b;
  return (_a2 = option.isLeaf) !== null && _a2 !== void 0 ? _a2 : !((_b = option[fieldNames.children]) === null || _b === void 0 ? void 0 : _b.length);
}
function scrollIntoParentView(element) {
  const parent = element.parentElement;
  if (!parent) {
    return;
  }
  const elementToParent = element.offsetTop - parent.offsetTop;
  if (elementToParent - parent.scrollTop < 0) {
    parent.scrollTo({
      top: elementToParent
    });
  } else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) {
    parent.scrollTo({
      top: elementToParent + element.offsetHeight - parent.offsetHeight
    });
  }
}

// node_modules/ant-design-vue/es/vc-cascader/hooks/useEntities.js
var useEntities_default = (options, fieldNames) => {
  const entities = computed(() => {
    return convertDataToEntities(options.value, {
      fieldNames: fieldNames.value,
      initWrapper: (wrapper) => _extends(_extends({}, wrapper), {
        pathKeyEntities: {}
      }),
      processEntity: (entity, wrapper) => {
        const pathKey = entity.nodes.map((node) => node[fieldNames.value.value]).join(VALUE_SPLIT);
        wrapper.pathKeyEntities[pathKey] = entity;
        entity.key = pathKey;
      }
    }).pathKeyEntities;
  });
  return entities;
};

// node_modules/ant-design-vue/es/vc-cascader/hooks/useSearchConfig.js
function useSearchConfig(showSearch) {
  const mergedShowSearch = shallowRef(false);
  const mergedSearchConfig = ref({});
  watchEffect(() => {
    if (!showSearch.value) {
      mergedShowSearch.value = false;
      mergedSearchConfig.value = {};
      return;
    }
    let searchConfig = {
      matchInputWidth: true,
      limit: 50
    };
    if (showSearch.value && typeof showSearch.value === "object") {
      searchConfig = _extends(_extends({}, searchConfig), showSearch.value);
    }
    if (searchConfig.limit <= 0) {
      delete searchConfig.limit;
      if (true) {
        warning(false, "'limit' of showSearch should be positive number or false.");
      }
    }
    mergedShowSearch.value = true;
    mergedSearchConfig.value = searchConfig;
    return;
  });
  return {
    showSearch: mergedShowSearch,
    searchConfig: mergedSearchConfig
  };
}

// node_modules/ant-design-vue/es/vc-cascader/hooks/useSearchOptions.js
var SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = (search, options, _ref) => {
  let {
    label
  } = _ref;
  return options.some((opt) => String(opt[label]).toLowerCase().includes(search.toLowerCase()));
};
var defaultRender = (_ref2) => {
  let {
    path: path2,
    fieldNames
  } = _ref2;
  return path2.map((opt) => opt[fieldNames.label]).join(" / ");
};
var useSearchOptions_default = (search, options, fieldNames, prefixCls, config, changeOnSelect) => {
  return computed(() => {
    const {
      filter = defaultFilter,
      render = defaultRender,
      limit = 50,
      sort
    } = config.value;
    const filteredOptions = [];
    if (!search.value) {
      return [];
    }
    function dig(list, pathOptions) {
      list.forEach((option) => {
        if (!sort && limit > 0 && filteredOptions.length >= limit) {
          return;
        }
        const connectedPathOptions = [...pathOptions, option];
        const children = option[fieldNames.value.children];
        if (
          // If is leaf option
          !children || children.length === 0 || // If is changeOnSelect
          changeOnSelect.value
        ) {
          if (filter(search.value, connectedPathOptions, {
            label: fieldNames.value.label
          })) {
            filteredOptions.push(_extends(_extends({}, option), {
              [fieldNames.value.label]: render({
                inputValue: search.value,
                path: connectedPathOptions,
                prefixCls: prefixCls.value,
                fieldNames: fieldNames.value
              }),
              [SEARCH_MARK]: connectedPathOptions
            }));
          }
        }
        if (children) {
          dig(option[fieldNames.value.children], connectedPathOptions);
        }
      });
    }
    dig(options.value, []);
    if (sort) {
      filteredOptions.sort((a, b) => {
        return sort(a[SEARCH_MARK], b[SEARCH_MARK], search.value, fieldNames.value);
      });
    }
    return limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
  });
};

// node_modules/ant-design-vue/es/vc-cascader/utils/treeUtil.js
function formatStrategyValues(pathKeys, keyPathEntities, showCheckedStrategy) {
  const valueSet = new Set(pathKeys);
  return pathKeys.filter((key) => {
    const entity = keyPathEntities[key];
    const parent = entity ? entity.parent : null;
    const children = entity ? entity.children : null;
    return showCheckedStrategy === SHOW_CHILD ? !(children && children.some((child) => child.key && valueSet.has(child.key))) : !(parent && !parent.node.disabled && valueSet.has(parent.key));
  });
}
function toPathOptions(valueCells, options, fieldNames) {
  let stringMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var _a2;
  let currentList = options;
  const valueOptions = [];
  for (let i = 0; i < valueCells.length; i += 1) {
    const valueCell = valueCells[i];
    const foundIndex = currentList === null || currentList === void 0 ? void 0 : currentList.findIndex((option) => {
      const val = option[fieldNames.value];
      return stringMode ? String(val) === String(valueCell) : val === valueCell;
    });
    const foundOption = foundIndex !== -1 ? currentList === null || currentList === void 0 ? void 0 : currentList[foundIndex] : null;
    valueOptions.push({
      value: (_a2 = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.value]) !== null && _a2 !== void 0 ? _a2 : valueCell,
      index: foundIndex,
      option: foundOption
    });
    currentList = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.children];
  }
  return valueOptions;
}

// node_modules/ant-design-vue/es/vc-cascader/hooks/useMissingValues.js
var useMissingValues_default = (options, fieldNames, rawValues) => {
  return computed(() => {
    const missingValues = [];
    const existsValues = [];
    rawValues.value.forEach((valueCell) => {
      const pathOptions = toPathOptions(valueCell, options.value, fieldNames.value);
      if (pathOptions.every((opt) => opt.option)) {
        existsValues.push(valueCell);
      } else {
        missingValues.push(valueCell);
      }
    });
    return [existsValues, missingValues];
  });
};

// node_modules/ant-design-vue/es/vc-cascader/hooks/useDisplayValues.js
var useDisplayValues_default = (rawValues, options, fieldNames, multiple, displayRender) => {
  return computed(() => {
    const mergedDisplayRender = displayRender.value || // Default displayRender
    ((_ref) => {
      let {
        labels
      } = _ref;
      const mergedLabels = multiple.value ? labels.slice(-1) : labels;
      const SPLIT = " / ";
      if (mergedLabels.every((label) => ["string", "number"].includes(typeof label))) {
        return mergedLabels.join(SPLIT);
      }
      return mergedLabels.reduce((list, label, index2) => {
        const keyedLabel = isValidElement(label) ? cloneElement(label, {
          key: index2
        }) : label;
        if (index2 === 0) {
          return [keyedLabel];
        }
        return [...list, SPLIT, keyedLabel];
      }, []);
    });
    return rawValues.value.map((valueCells) => {
      const valueOptions = toPathOptions(valueCells, options.value, fieldNames.value);
      const label = mergedDisplayRender({
        labels: valueOptions.map((_ref2) => {
          let {
            option,
            value: value2
          } = _ref2;
          var _a2;
          return (_a2 = option === null || option === void 0 ? void 0 : option[fieldNames.value.label]) !== null && _a2 !== void 0 ? _a2 : value2;
        }),
        selectedOptions: valueOptions.map((_ref3) => {
          let {
            option
          } = _ref3;
          return option;
        })
      });
      const value = toPathKey(valueCells);
      return {
        label,
        value,
        key: value,
        valueCells
      };
    });
  });
};

// node_modules/ant-design-vue/es/vc-cascader/context.js
var CascaderContextKey = Symbol("CascaderContextKey");
var useProvideCascader = (props2) => {
  provide(CascaderContextKey, props2);
};
var useInjectCascader = () => {
  return inject(CascaderContextKey);
};

// node_modules/ant-design-vue/es/vc-cascader/OptionList/useActive.js
var useActive_default = () => {
  const baseProps3 = useBaseProps();
  const {
    values
  } = useInjectCascader();
  const [activeValueCells, setActiveValueCells] = useState([]);
  watch(() => baseProps3.open, () => {
    if (baseProps3.open && !baseProps3.multiple) {
      const firstValueCells = values.value[0];
      setActiveValueCells(firstValueCells || []);
    }
  }, {
    immediate: true
  });
  return [activeValueCells, setActiveValueCells];
};

// node_modules/ant-design-vue/es/vc-cascader/OptionList/useKeyboard.js
var useKeyboard_default = (context2, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect) => {
  const baseProps3 = useBaseProps();
  const rtl = computed(() => baseProps3.direction === "rtl");
  const [validActiveValueCells, lastActiveIndex, lastActiveOptions] = [ref([]), ref(), ref([])];
  watchEffect(() => {
    let activeIndex = -1;
    let currentOptions = options.value;
    const mergedActiveIndexes = [];
    const mergedActiveValueCells = [];
    const len = activeValueCells.value.length;
    for (let i = 0; i < len && currentOptions; i += 1) {
      const nextActiveIndex = currentOptions.findIndex((option) => option[fieldNames.value.value] === activeValueCells.value[i]);
      if (nextActiveIndex === -1) {
        break;
      }
      activeIndex = nextActiveIndex;
      mergedActiveIndexes.push(activeIndex);
      mergedActiveValueCells.push(activeValueCells.value[i]);
      currentOptions = currentOptions[activeIndex][fieldNames.value.children];
    }
    let activeOptions = options.value;
    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {
      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.value.children];
    }
    [validActiveValueCells.value, lastActiveIndex.value, lastActiveOptions.value] = [mergedActiveValueCells, activeIndex, activeOptions];
  });
  const internalSetActiveValueCells = (next) => {
    setActiveValueCells(next);
  };
  const offsetActiveOption = (offset) => {
    const len = lastActiveOptions.value.length;
    let currentIndex = lastActiveIndex.value;
    if (currentIndex === -1 && offset < 0) {
      currentIndex = len;
    }
    for (let i = 0; i < len; i += 1) {
      currentIndex = (currentIndex + offset + len) % len;
      const option = lastActiveOptions.value[currentIndex];
      if (option && !option.disabled) {
        const value = option[fieldNames.value.value];
        const nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);
        internalSetActiveValueCells(nextActiveCells);
        return;
      }
    }
  };
  const prevColumn = () => {
    if (validActiveValueCells.value.length > 1) {
      const nextActiveCells = validActiveValueCells.value.slice(0, -1);
      internalSetActiveValueCells(nextActiveCells);
    } else {
      baseProps3.toggleOpen(false);
    }
  };
  const nextColumn = () => {
    var _a2;
    const nextOptions = ((_a2 = lastActiveOptions.value[lastActiveIndex.value]) === null || _a2 === void 0 ? void 0 : _a2[fieldNames.value.children]) || [];
    const nextOption = nextOptions.find((option) => !option.disabled);
    if (nextOption) {
      const nextActiveCells = [...validActiveValueCells.value, nextOption[fieldNames.value.value]];
      internalSetActiveValueCells(nextActiveCells);
    }
  };
  context2.expose({
    // scrollTo: treeRef.current?.scrollTo,
    onKeydown: (event) => {
      const {
        which
      } = event;
      switch (which) {
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset = 0;
          if (which === KeyCode_default.UP) {
            offset = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset = 1;
          }
          if (offset !== 0) {
            offsetActiveOption(offset);
          }
          break;
        }
        case KeyCode_default.LEFT: {
          if (rtl.value) {
            nextColumn();
          } else {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.RIGHT: {
          if (rtl.value) {
            prevColumn();
          } else {
            nextColumn();
          }
          break;
        }
        case KeyCode_default.BACKSPACE: {
          if (!baseProps3.searchValue) {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.ENTER: {
          if (validActiveValueCells.value.length) {
            const option = lastActiveOptions.value[lastActiveIndex.value];
            const originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];
            if (originOptions.length) {
              onKeyBoardSelect(originOptions.map((opt) => opt[fieldNames.value.value]), originOptions[originOptions.length - 1]);
            } else {
              onKeyBoardSelect(validActiveValueCells.value, option);
            }
          }
          break;
        }
        case KeyCode_default.ESC: {
          baseProps3.toggleOpen(false);
          if (open) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyup: () => {
    }
  });
};

// node_modules/ant-design-vue/es/vc-cascader/OptionList/Checkbox.js
function Checkbox(_ref) {
  let {
    prefixCls,
    checked,
    halfChecked,
    disabled,
    onClick
  } = _ref;
  const {
    customSlots,
    checkable
  } = useInjectCascader();
  const mergedCheckable = checkable.value !== false ? customSlots.value.checkable : checkable.value;
  const customCheckbox = typeof mergedCheckable === "function" ? mergedCheckable() : typeof mergedCheckable === "boolean" ? null : mergedCheckable;
  return createVNode("span", {
    "class": {
      [prefixCls]: true,
      [`${prefixCls}-checked`]: checked,
      [`${prefixCls}-indeterminate`]: !checked && halfChecked,
      [`${prefixCls}-disabled`]: disabled
    },
    "onClick": onClick
  }, [customCheckbox]);
}
Checkbox.props = ["prefixCls", "checked", "halfChecked", "disabled", "onClick"];
Checkbox.displayName = "Checkbox";
Checkbox.inheritAttrs = false;

// node_modules/ant-design-vue/es/vc-cascader/OptionList/Column.js
var FIX_LABEL = "__cascader_fix_label__";
function Column(_ref) {
  let {
    prefixCls,
    multiple,
    options,
    activeValue,
    prevValuePath,
    onToggleOpen,
    onSelect,
    onActive,
    checkedSet,
    halfCheckedSet,
    loadingKeys,
    isSelectable
  } = _ref;
  var _a2, _b, _c, _d, _e, _f;
  const menuPrefixCls = `${prefixCls}-menu`;
  const menuItemPrefixCls = `${prefixCls}-menu-item`;
  const {
    fieldNames,
    changeOnSelect,
    expandTrigger,
    expandIcon: expandIconRef,
    loadingIcon: loadingIconRef,
    dropdownMenuColumnStyle,
    customSlots
  } = useInjectCascader();
  const expandIcon = (_a2 = expandIconRef.value) !== null && _a2 !== void 0 ? _a2 : (_c = (_b = customSlots.value).expandIcon) === null || _c === void 0 ? void 0 : _c.call(_b);
  const loadingIcon = (_d = loadingIconRef.value) !== null && _d !== void 0 ? _d : (_f = (_e = customSlots.value).loadingIcon) === null || _f === void 0 ? void 0 : _f.call(_e);
  const hoverOpen = expandTrigger.value === "hover";
  return createVNode("ul", {
    "class": menuPrefixCls,
    "role": "menu"
  }, [options.map((option) => {
    var _a3;
    const {
      disabled
    } = option;
    const searchOptions = option[SEARCH_MARK];
    const label = (_a3 = option[FIX_LABEL]) !== null && _a3 !== void 0 ? _a3 : option[fieldNames.value.label];
    const value = option[fieldNames.value.value];
    const isMergedLeaf = isLeaf(option, fieldNames.value);
    const fullPath = searchOptions ? searchOptions.map((opt) => opt[fieldNames.value.value]) : [...prevValuePath, value];
    const fullPathKey = toPathKey(fullPath);
    const isLoading = loadingKeys.includes(fullPathKey);
    const checked = checkedSet.has(fullPathKey);
    const halfChecked = halfCheckedSet.has(fullPathKey);
    const triggerOpenPath = () => {
      if (!disabled && (!hoverOpen || !isMergedLeaf)) {
        onActive(fullPath);
      }
    };
    const triggerSelect = () => {
      if (isSelectable(option)) {
        onSelect(fullPath, isMergedLeaf);
      }
    };
    let title;
    if (typeof option.title === "string") {
      title = option.title;
    } else if (typeof label === "string") {
      title = label;
    }
    return createVNode("li", {
      "key": fullPathKey,
      "class": [menuItemPrefixCls, {
        [`${menuItemPrefixCls}-expand`]: !isMergedLeaf,
        [`${menuItemPrefixCls}-active`]: activeValue === value,
        [`${menuItemPrefixCls}-disabled`]: disabled,
        [`${menuItemPrefixCls}-loading`]: isLoading
      }],
      "style": dropdownMenuColumnStyle.value,
      "role": "menuitemcheckbox",
      "title": title,
      "aria-checked": checked,
      "data-path-key": fullPathKey,
      "onClick": () => {
        triggerOpenPath();
        if (!multiple || isMergedLeaf) {
          triggerSelect();
        }
      },
      "onDblclick": () => {
        if (changeOnSelect.value) {
          onToggleOpen(false);
        }
      },
      "onMouseenter": () => {
        if (hoverOpen) {
          triggerOpenPath();
        }
      },
      "onMousedown": (e) => {
        e.preventDefault();
      }
    }, [multiple && createVNode(Checkbox, {
      "prefixCls": `${prefixCls}-checkbox`,
      "checked": checked,
      "halfChecked": halfChecked,
      "disabled": disabled,
      "onClick": (e) => {
        e.stopPropagation();
        triggerSelect();
      }
    }, null), createVNode("div", {
      "class": `${menuItemPrefixCls}-content`
    }, [label]), !isLoading && expandIcon && !isMergedLeaf && createVNode("div", {
      "class": `${menuItemPrefixCls}-expand-icon`
    }, [cloneElement(expandIcon)]), isLoading && loadingIcon && createVNode("div", {
      "class": `${menuItemPrefixCls}-loading-icon`
    }, [cloneElement(loadingIcon)])]);
  })]);
}
Column.props = ["prefixCls", "multiple", "options", "activeValue", "prevValuePath", "onToggleOpen", "onSelect", "onActive", "checkedSet", "halfCheckedSet", "loadingKeys", "isSelectable"];
Column.displayName = "Column";
Column.inheritAttrs = false;

// node_modules/ant-design-vue/es/vc-cascader/OptionList/index.js
var OptionList_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  setup(_props, context2) {
    const {
      attrs,
      slots
    } = context2;
    const baseProps3 = useBaseProps();
    const containerRef = ref();
    const rtl = computed(() => baseProps3.direction === "rtl");
    const {
      options,
      values,
      halfValues,
      fieldNames,
      changeOnSelect,
      onSelect,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      customSlots
    } = useInjectCascader();
    const mergedPrefixCls = computed(() => dropdownPrefixCls.value || baseProps3.prefixCls);
    const loadingKeys = shallowRef([]);
    const internalLoadData = (valueCells) => {
      if (!loadData.value || baseProps3.searchValue) {
        return;
      }
      const optionList = toPathOptions(valueCells, options.value, fieldNames.value);
      const rawOptions = optionList.map((_ref) => {
        let {
          option
        } = _ref;
        return option;
      });
      const lastOption = rawOptions[rawOptions.length - 1];
      if (lastOption && !isLeaf(lastOption, fieldNames.value)) {
        const pathKey = toPathKey(valueCells);
        loadingKeys.value = [...loadingKeys.value, pathKey];
        loadData.value(rawOptions);
      }
    };
    watchEffect(() => {
      if (loadingKeys.value.length) {
        loadingKeys.value.forEach((loadingKey) => {
          const valueStrCells = toPathValueStr(loadingKey);
          const optionList = toPathOptions(valueStrCells, options.value, fieldNames.value, true).map((_ref2) => {
            let {
              option
            } = _ref2;
            return option;
          });
          const lastOption = optionList[optionList.length - 1];
          if (!lastOption || lastOption[fieldNames.value.children] || isLeaf(lastOption, fieldNames.value)) {
            loadingKeys.value = loadingKeys.value.filter((key) => key !== loadingKey);
          }
        });
      }
    });
    const checkedSet = computed(() => new Set(toPathKeys(values.value)));
    const halfCheckedSet = computed(() => new Set(toPathKeys(halfValues.value)));
    const [activeValueCells, setActiveValueCells] = useActive_default();
    const onPathOpen = (nextValueCells) => {
      setActiveValueCells(nextValueCells);
      internalLoadData(nextValueCells);
    };
    const isSelectable = (option) => {
      const {
        disabled
      } = option;
      const isMergedLeaf = isLeaf(option, fieldNames.value);
      return !disabled && (isMergedLeaf || changeOnSelect.value || baseProps3.multiple);
    };
    const onPathSelect = function(valuePath, leaf) {
      let fromKeyboard = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      onSelect(valuePath);
      if (!baseProps3.multiple && (leaf || changeOnSelect.value && (expandTrigger.value === "hover" || fromKeyboard))) {
        baseProps3.toggleOpen(false);
      }
    };
    const mergedOptions = computed(() => {
      if (baseProps3.searchValue) {
        return searchOptions.value;
      }
      return options.value;
    });
    const optionColumns = computed(() => {
      const optionList = [{
        options: mergedOptions.value
      }];
      let currentList = mergedOptions.value;
      for (let i = 0; i < activeValueCells.value.length; i += 1) {
        const activeValueCell = activeValueCells.value[i];
        const currentOption = currentList.find((option) => option[fieldNames.value.value] === activeValueCell);
        const subOptions = currentOption === null || currentOption === void 0 ? void 0 : currentOption[fieldNames.value.children];
        if (!(subOptions === null || subOptions === void 0 ? void 0 : subOptions.length)) {
          break;
        }
        currentList = subOptions;
        optionList.push({
          options: subOptions
        });
      }
      return optionList;
    });
    const onKeyboardSelect = (selectValueCells, option) => {
      if (isSelectable(option)) {
        onPathSelect(selectValueCells, isLeaf(option, fieldNames.value), true);
      }
    };
    useKeyboard_default(context2, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect);
    const onListMouseDown = (event) => {
      event.preventDefault();
    };
    onMounted(() => {
      watch(activeValueCells, (cells) => {
        var _a2;
        for (let i = 0; i < cells.length; i += 1) {
          const cellPath = cells.slice(0, i + 1);
          const cellKeyPath = toPathKey(cellPath);
          const ele = (_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`li[data-path-key="${cellKeyPath.replace(/\\{0,2}"/g, '\\"')}"]`);
          if (ele) {
            scrollIntoParentView(ele);
          }
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    return () => {
      var _a2, _b, _c, _d, _e;
      const {
        notFoundContent = ((_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || ((_c = (_b = customSlots.value).notFoundContent) === null || _c === void 0 ? void 0 : _c.call(_b)),
        multiple,
        toggleOpen
      } = baseProps3;
      const isEmpty2 = !((_e = (_d = optionColumns.value[0]) === null || _d === void 0 ? void 0 : _d.options) === null || _e === void 0 ? void 0 : _e.length);
      const emptyList = [{
        [fieldNames.value.value]: "__EMPTY__",
        [FIX_LABEL]: notFoundContent,
        disabled: true
      }];
      const columnProps = _extends(_extends({}, attrs), {
        multiple: !isEmpty2 && multiple,
        onSelect: onPathSelect,
        onActive: onPathOpen,
        onToggleOpen: toggleOpen,
        checkedSet: checkedSet.value,
        halfCheckedSet: halfCheckedSet.value,
        loadingKeys: loadingKeys.value,
        isSelectable
      });
      const mergedOptionColumns = isEmpty2 ? [{
        options: emptyList
      }] : optionColumns.value;
      const columnNodes = mergedOptionColumns.map((col, index2) => {
        const prevValuePath = activeValueCells.value.slice(0, index2);
        const activeValue = activeValueCells.value[index2];
        return createVNode(Column, _objectSpread2(_objectSpread2({
          "key": index2
        }, columnProps), {}, {
          "prefixCls": mergedPrefixCls.value,
          "options": col.options,
          "prevValuePath": prevValuePath,
          "activeValue": activeValue
        }), null);
      });
      return createVNode("div", {
        "class": [`${mergedPrefixCls.value}-menus`, {
          [`${mergedPrefixCls.value}-menu-empty`]: isEmpty2,
          [`${mergedPrefixCls.value}-rtl`]: rtl.value
        }],
        "onMousedown": onListMouseDown,
        "ref": containerRef
      }, [columnNodes]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-cascader/Cascader.js
function baseCascaderProps() {
  return _extends(_extends({}, omit_default(baseSelectPropsWithoutPrivate(), ["tokenSeparators", "mode", "showSearch"])), {
    // MISC
    id: String,
    prefixCls: String,
    fieldNames: objectType(),
    children: Array,
    // Value
    value: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array]
    },
    changeOnSelect: {
      type: Boolean,
      default: void 0
    },
    displayRender: Function,
    checkable: {
      type: Boolean,
      default: void 0
    },
    showCheckedStrategy: {
      type: String,
      default: SHOW_PARENT
    },
    // Search
    showSearch: {
      type: [Boolean, Object],
      default: void 0
    },
    searchValue: String,
    onSearch: Function,
    // Trigger
    expandTrigger: String,
    // Options
    options: Array,
    /** @private Internal usage. Do not use in your production. */
    dropdownPrefixCls: String,
    loadData: Function,
    // Open
    /** @deprecated Use `open` instead */
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownMenuColumnStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `dropdownStyle` instead */
    popupStyle: {
      type: Object,
      default: void 0
    },
    dropdownStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `placement` instead */
    popupPlacement: String,
    placement: String,
    /** @deprecated Use `onDropdownVisibleChange` instead */
    onPopupVisibleChange: Function,
    onDropdownVisibleChange: Function,
    // Icon
    expandIcon: vue_types_default.any,
    loadingIcon: vue_types_default.any
  });
}
function internalCascaderProps() {
  return _extends(_extends({}, baseCascaderProps()), {
    onChange: Function,
    customSlots: Object
  });
}
function isMultipleValue(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
  if (!value) {
    return [];
  }
  if (isMultipleValue(value)) {
    return value;
  }
  return (value.length === 0 ? [] : [value]).map((val) => Array.isArray(val) ? val : [val]);
}
var Cascader_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Cascader",
  inheritAttrs: false,
  props: initDefaultProps_default(internalCascaderProps(), {}),
  setup(props2, _ref) {
    let {
      attrs,
      expose,
      slots
    } = _ref;
    const mergedId = useId(toRef(props2, "id"));
    const multiple = computed(() => !!props2.checkable);
    const [rawValues, setRawValues] = useMergedState(props2.defaultValue, {
      value: computed(() => props2.value),
      postState: toRawValues
    });
    const mergedFieldNames = computed(() => fillFieldNames(props2.fieldNames));
    const mergedOptions = computed(() => props2.options || []);
    const pathKeyEntities = useEntities_default(mergedOptions, mergedFieldNames);
    const getValueByKeyPath = (pathKeys) => {
      const keyPathEntities = pathKeyEntities.value;
      return pathKeys.map((pathKey) => {
        const {
          nodes
        } = keyPathEntities[pathKey];
        return nodes.map((node) => node[mergedFieldNames.value.value]);
      });
    };
    const [mergedSearchValue, setSearchValue] = useMergedState("", {
      value: computed(() => props2.searchValue),
      postState: (search) => search || ""
    });
    const onInternalSearch = (searchText, info) => {
      setSearchValue(searchText);
      if (info.source !== "blur" && props2.onSearch) {
        props2.onSearch(searchText);
      }
    };
    const {
      showSearch: mergedShowSearch,
      searchConfig: mergedSearchConfig
    } = useSearchConfig(toRef(props2, "showSearch"));
    const searchOptions = useSearchOptions_default(mergedSearchValue, mergedOptions, mergedFieldNames, computed(() => props2.dropdownPrefixCls || props2.prefixCls), mergedSearchConfig, toRef(props2, "changeOnSelect"));
    const missingValuesInfo = useMissingValues_default(mergedOptions, mergedFieldNames, rawValues);
    const [checkedValues, halfCheckedValues, missingCheckedValues] = [ref([]), ref([]), ref([])];
    const {
      maxLevel,
      levelEntities
    } = useMaxLevel(pathKeyEntities);
    watchEffect(() => {
      const [existValues, missingValues] = missingValuesInfo.value;
      if (!multiple.value || !rawValues.value.length) {
        [checkedValues.value, halfCheckedValues.value, missingCheckedValues.value] = [existValues, [], missingValues];
        return;
      }
      const keyPathValues = toPathKeys(existValues);
      const keyPathEntities = pathKeyEntities.value;
      const {
        checkedKeys,
        halfCheckedKeys
      } = conductCheck(keyPathValues, true, keyPathEntities, maxLevel.value, levelEntities.value);
      [checkedValues.value, halfCheckedValues.value, missingCheckedValues.value] = [getValueByKeyPath(checkedKeys), getValueByKeyPath(halfCheckedKeys), missingValues];
    });
    const deDuplicatedValues = computed(() => {
      const checkedKeys = toPathKeys(checkedValues.value);
      const deduplicateKeys = formatStrategyValues(checkedKeys, pathKeyEntities.value, props2.showCheckedStrategy);
      return [...missingCheckedValues.value, ...getValueByKeyPath(deduplicateKeys)];
    });
    const displayValues = useDisplayValues_default(deDuplicatedValues, mergedOptions, mergedFieldNames, multiple, toRef(props2, "displayRender"));
    const triggerChange = (nextValues) => {
      setRawValues(nextValues);
      if (props2.onChange) {
        const nextRawValues = toRawValues(nextValues);
        const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions.value, mergedFieldNames.value).map((valueOpt) => valueOpt.option));
        const triggerValues = multiple.value ? nextRawValues : nextRawValues[0];
        const triggerOptions = multiple.value ? valueOptions : valueOptions[0];
        props2.onChange(triggerValues, triggerOptions);
      }
    };
    const onInternalSelect = (valuePath) => {
      setSearchValue("");
      if (!multiple.value) {
        triggerChange(valuePath);
      } else {
        const pathKey = toPathKey(valuePath);
        const checkedPathKeys = toPathKeys(checkedValues.value);
        const halfCheckedPathKeys = toPathKeys(halfCheckedValues.value);
        const existInChecked = checkedPathKeys.includes(pathKey);
        const existInMissing = missingCheckedValues.value.some((valueCells) => toPathKey(valueCells) === pathKey);
        let nextCheckedValues = checkedValues.value;
        let nextMissingValues = missingCheckedValues.value;
        if (existInMissing && !existInChecked) {
          nextMissingValues = missingCheckedValues.value.filter((valueCells) => toPathKey(valueCells) !== pathKey);
        } else {
          const nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter((key) => key !== pathKey) : [...checkedPathKeys, pathKey];
          let checkedKeys;
          if (existInChecked) {
            ({
              checkedKeys
            } = conductCheck(nextRawCheckedKeys, {
              checked: false,
              halfCheckedKeys: halfCheckedPathKeys
            }, pathKeyEntities.value, maxLevel.value, levelEntities.value));
          } else {
            ({
              checkedKeys
            } = conductCheck(nextRawCheckedKeys, true, pathKeyEntities.value, maxLevel.value, levelEntities.value));
          }
          const deDuplicatedKeys = formatStrategyValues(checkedKeys, pathKeyEntities.value, props2.showCheckedStrategy);
          nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
        }
        triggerChange([...nextMissingValues, ...nextCheckedValues]);
      }
    };
    const onDisplayValuesChange = (_, info) => {
      if (info.type === "clear") {
        triggerChange([]);
        return;
      }
      const {
        valueCells
      } = info.values[0];
      onInternalSelect(valueCells);
    };
    if (true) {
      watchEffect(() => {
        devWarning_default(!props2.onPopupVisibleChange, "Cascader", "`popupVisibleChange` is deprecated. Please use `dropdownVisibleChange` instead.");
        devWarning_default(props2.popupVisible === void 0, "Cascader", "`popupVisible` is deprecated. Please use `open` instead.");
        devWarning_default(props2.popupPlacement === void 0, "Cascader", "`popupPlacement` is deprecated. Please use `placement` instead.");
        devWarning_default(props2.popupStyle === void 0, "Cascader", "`popupStyle` is deprecated. Please use `dropdownStyle` instead.");
      });
    }
    const mergedOpen = computed(() => props2.open !== void 0 ? props2.open : props2.popupVisible);
    const mergedDropdownStyle = computed(() => props2.dropdownStyle || props2.popupStyle || {});
    const mergedPlacement = computed(() => props2.placement || props2.popupPlacement);
    const onInternalDropdownVisibleChange = (nextVisible) => {
      var _a2, _b;
      (_a2 = props2.onDropdownVisibleChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, nextVisible);
      (_b = props2.onPopupVisibleChange) === null || _b === void 0 ? void 0 : _b.call(props2, nextVisible);
    };
    const {
      changeOnSelect,
      checkable,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      customSlots,
      dropdownClassName
    } = toRefs(props2);
    useProvideCascader({
      options: mergedOptions,
      fieldNames: mergedFieldNames,
      values: checkedValues,
      halfValues: halfCheckedValues,
      changeOnSelect,
      onSelect: onInternalSelect,
      checkable,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      customSlots
    });
    const selectRef = ref();
    expose({
      focus() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      },
      scrollTo(arg) {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
      }
    });
    const pickProps = computed(() => {
      return omit_default(props2, [
        "id",
        "prefixCls",
        "fieldNames",
        // Value
        "defaultValue",
        "value",
        "changeOnSelect",
        "onChange",
        "displayRender",
        "checkable",
        // Search
        "searchValue",
        "onSearch",
        "showSearch",
        // Trigger
        "expandTrigger",
        // Options
        "options",
        "dropdownPrefixCls",
        "loadData",
        // Open
        "popupVisible",
        "open",
        "dropdownClassName",
        "dropdownMenuColumnStyle",
        "popupPlacement",
        "placement",
        "onDropdownVisibleChange",
        "onPopupVisibleChange",
        // Icon
        "expandIcon",
        "loadingIcon",
        "customSlots",
        "showCheckedStrategy",
        // Children
        "children"
      ]);
    });
    return () => {
      const emptyOptions = !(mergedSearchValue.value ? searchOptions.value : mergedOptions.value).length;
      const {
        dropdownMatchSelectWidth = false
      } = props2;
      const dropdownStyle = (
        // Search to match width
        mergedSearchValue.value && mergedSearchConfig.value.matchInputWidth || // Empty keep the width
        emptyOptions ? {} : {
          minWidth: "auto"
        }
      );
      return createVNode(BaseSelect_default, _objectSpread2(_objectSpread2(_objectSpread2({}, pickProps.value), attrs), {}, {
        "ref": selectRef,
        "id": mergedId,
        "prefixCls": props2.prefixCls,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
        "dropdownStyle": _extends(_extends({}, mergedDropdownStyle.value), dropdownStyle),
        "displayValues": displayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "mode": multiple.value ? "multiple" : void 0,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "showSearch": mergedShowSearch.value,
        "OptionList": OptionList_default,
        "emptyOptions": emptyOptions,
        "open": mergedOpen.value,
        "dropdownClassName": dropdownClassName.value,
        "placement": mergedPlacement.value,
        "onDropdownVisibleChange": onInternalDropdownVisibleChange,
        "getRawInputElement": () => {
          var _a2;
          return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        }
      }), slots);
    };
  }
});

// node_modules/ant-design-vue/es/vc-cascader/index.js
var vc_cascader_default = Cascader_default;

// node_modules/ant-design-vue/es/cascader/style/index.js
var genBaseStyle5 = (token) => {
  const {
    prefixCls,
    componentCls,
    antCls
  } = token;
  const cascaderMenuItemCls = `${componentCls}-menu-item`;
  const iconCls = `
    &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
    ${cascaderMenuItemCls}-loading-icon
  `;
  const itemPaddingVertical = Math.round((token.controlHeight - token.fontSize * token.lineHeight) / 2);
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [componentCls]: {
        width: token.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${componentCls}-dropdown`]: [
        // ==================== Checkbox ====================
        getStyle2(`${prefixCls}-checkbox`, token),
        {
          [`&${antCls}-select-dropdown`]: {
            padding: 0
          }
        },
        {
          [componentCls]: {
            // ================== Checkbox ==================
            "&-checkbox": {
              top: 0,
              marginInlineEnd: token.paddingXS
            },
            // ==================== Menu ====================
            // >>> Menus
            "&-menus": {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "flex-start",
              [`&${componentCls}-menu-empty`]: {
                [`${componentCls}-menu`]: {
                  width: "100%",
                  height: "auto",
                  [cascaderMenuItemCls]: {
                    color: token.colorTextDisabled
                  }
                }
              }
            },
            // >>> Menu
            "&-menu": {
              flexGrow: 1,
              minWidth: token.controlItemWidth,
              height: token.dropdownHeight,
              margin: 0,
              padding: token.paddingXXS,
              overflow: "auto",
              verticalAlign: "top",
              listStyle: "none",
              "-ms-overflow-style": "-ms-autohiding-scrollbar",
              "&:not(:last-child)": {
                borderInlineEnd: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`
              },
              "&-item": _extends(_extends({}, textEllipsis), {
                display: "flex",
                flexWrap: "nowrap",
                alignItems: "center",
                padding: `${itemPaddingVertical}px ${token.paddingSM}px`,
                lineHeight: token.lineHeight,
                cursor: "pointer",
                transition: `all ${token.motionDurationMid}`,
                borderRadius: token.borderRadiusSM,
                "&:hover": {
                  background: token.controlItemBgHover
                },
                "&-disabled": {
                  color: token.colorTextDisabled,
                  cursor: "not-allowed",
                  "&:hover": {
                    background: "transparent"
                  },
                  [iconCls]: {
                    color: token.colorTextDisabled
                  }
                },
                [`&-active:not(${cascaderMenuItemCls}-disabled)`]: {
                  [`&, &:hover`]: {
                    fontWeight: token.fontWeightStrong,
                    backgroundColor: token.controlItemBgActive
                  }
                },
                "&-content": {
                  flex: "auto"
                },
                [iconCls]: {
                  marginInlineStart: token.paddingXXS,
                  color: token.colorTextDescription,
                  fontSize: token.fontSizeIcon
                },
                "&-keyword": {
                  color: token.colorHighlight
                }
              })
            }
          }
        }
      ]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token)
  ];
};
var style_default15 = genComponentStyleHook("Cascader", (token) => [genBaseStyle5(token)], {
  controlWidth: 184,
  controlItemWidth: 111,
  dropdownHeight: 180
});

// node_modules/ant-design-vue/es/cascader/index.js
var __rest8 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function highlightKeyword(str, lowerKeyword, prefixCls) {
  const cells = str.toLowerCase().split(lowerKeyword).reduce((list, cur, index2) => index2 === 0 ? [cur] : [...list, lowerKeyword, cur], []);
  const fillCells = [];
  let start = 0;
  cells.forEach((cell, index2) => {
    const end = start + cell.length;
    let originWorld = str.slice(start, end);
    start = end;
    if (index2 % 2 === 1) {
      const _originWorld = function() {
        return originWorld;
      }();
      originWorld = createVNode("span", {
        "class": `${prefixCls}-menu-item-keyword`,
        "key": "seperator"
      }, [originWorld]);
    }
    fillCells.push(originWorld);
  });
  return fillCells;
}
var defaultSearchRender = (_ref) => {
  let {
    inputValue,
    path: path2,
    prefixCls,
    fieldNames
  } = _ref;
  const optionList = [];
  const lower2 = inputValue.toLowerCase();
  path2.forEach((node, index2) => {
    if (index2 !== 0) {
      optionList.push(" / ");
    }
    let label = node[fieldNames.label];
    const type = typeof label;
    if (type === "string" || type === "number") {
      label = highlightKeyword(String(label), lower2, prefixCls);
    }
    optionList.push(label);
  });
  return optionList;
};
function cascaderProps() {
  return _extends(_extends({}, omit_default(internalCascaderProps(), ["customSlots", "checkable", "options"])), {
    multiple: {
      type: Boolean,
      default: void 0
    },
    size: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String
    },
    suffixIcon: vue_types_default.any,
    status: String,
    options: Array,
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": Function
  });
}
var Cascader = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACascader",
  inheritAttrs: false,
  props: initDefaultProps_default(cascaderProps(), {
    bordered: true,
    choiceTransitionName: "",
    allowClear: true
  }),
  setup(props2, _ref2) {
    let {
      attrs,
      expose,
      slots,
      emit
    } = _ref2;
    if (true) {
      devWarning_default(!props2.dropdownClassName, "Cascader", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    }
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const {
      prefixCls: cascaderPrefixCls,
      rootPrefixCls,
      getPrefixCls,
      direction,
      getPopupContainer,
      renderEmpty,
      size: contextSize,
      disabled
    } = useConfigInject_default("cascader", props2);
    const prefixCls = computed(() => getPrefixCls("select", props2.prefixCls));
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = computed(() => compactSize.value || contextSize.value);
    const contextDisabled = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : contextDisabled.value;
    });
    const [wrapSelectSSR, hashId] = style_default(prefixCls);
    const [wrapCascaderSSR] = style_default15(cascaderPrefixCls);
    const isRtl = computed(() => direction.value === "rtl");
    if (true) {
      watchEffect(() => {
        devWarning_default(!props2.multiple || !props2.displayRender || !slots.displayRender, "Cascader", "`displayRender` not work on `multiple`. Please use `tagRender` instead.");
      });
    }
    const mergedShowSearch = computed(() => {
      if (!props2.showSearch) {
        return props2.showSearch;
      }
      let searchConfig = {
        render: defaultSearchRender
      };
      if (typeof props2.showSearch === "object") {
        searchConfig = _extends(_extends({}, searchConfig), props2.showSearch);
      }
      return searchConfig;
    });
    const mergedDropdownClassName = computed(() => classNames_default(props2.popupClassName || props2.dropdownClassName, `${cascaderPrefixCls.value}-dropdown`, {
      [`${cascaderPrefixCls.value}-dropdown-rtl`]: isRtl.value
    }, hashId.value));
    const selectRef = ref();
    expose({
      focus() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      }
    });
    const handleChange = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      emit("update:value", args[0]);
      emit("change", ...args);
      formItemContext.onFieldChange();
    };
    const handleBlur = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      emit("blur", ...args);
      formItemContext.onFieldBlur();
    };
    const mergedShowArrow = computed(() => props2.showArrow !== void 0 ? props2.showArrow : props2.loading || !props2.multiple);
    const placement = computed(() => {
      if (props2.placement !== void 0) {
        return props2.placement;
      }
      return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
    });
    return () => {
      var _a2, _b;
      const {
        notFoundContent = (_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        expandIcon = (_b = slots.expandIcon) === null || _b === void 0 ? void 0 : _b.call(slots),
        multiple,
        bordered,
        allowClear,
        choiceTransitionName,
        transitionName,
        id = formItemContext.id.value
      } = props2, restProps = __rest8(props2, ["notFoundContent", "expandIcon", "multiple", "bordered", "allowClear", "choiceTransitionName", "transitionName", "id"]);
      const mergedNotFoundContent = notFoundContent || renderEmpty("Cascader");
      let mergedExpandIcon = expandIcon;
      if (!expandIcon) {
        mergedExpandIcon = isRtl.value ? createVNode(LeftOutlined_default, null, null) : createVNode(RightOutlined_default, null, null);
      }
      const loadingIcon = createVNode("span", {
        "class": `${prefixCls.value}-menu-item-loading-icon`
      }, [createVNode(LoadingOutlined_default, {
        "spin": true
      }, null)]);
      const {
        suffixIcon,
        removeIcon,
        clearIcon
      } = getIcons(_extends(_extends({}, props2), {
        hasFeedback: formItemInputContext.hasFeedback,
        feedbackIcon: formItemInputContext.feedbackIcon,
        multiple,
        prefixCls: prefixCls.value,
        showArrow: mergedShowArrow.value
      }), slots);
      return wrapCascaderSSR(wrapSelectSSR(createVNode(vc_cascader_default, _objectSpread2(_objectSpread2(_objectSpread2({}, restProps), attrs), {}, {
        "id": id,
        "prefixCls": prefixCls.value,
        "class": [cascaderPrefixCls.value, {
          [`${prefixCls.value}-lg`]: mergedSize.value === "large",
          [`${prefixCls.value}-sm`]: mergedSize.value === "small",
          [`${prefixCls.value}-rtl`]: isRtl.value,
          [`${prefixCls.value}-borderless`]: !bordered,
          [`${prefixCls.value}-in-form-item`]: formItemInputContext.isFormItemInput
        }, getStatusClassNames(prefixCls.value, mergedStatus.value, formItemInputContext.hasFeedback), compactItemClassnames.value, attrs.class, hashId.value],
        "disabled": mergedDisabled.value,
        "direction": direction.value,
        "placement": placement.value,
        "notFoundContent": mergedNotFoundContent,
        "allowClear": allowClear,
        "showSearch": mergedShowSearch.value,
        "expandIcon": mergedExpandIcon,
        "inputIcon": suffixIcon,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "loadingIcon": loadingIcon,
        "checkable": !!multiple,
        "dropdownClassName": mergedDropdownClassName.value,
        "dropdownPrefixCls": cascaderPrefixCls.value,
        "choiceTransitionName": getTransitionName(rootPrefixCls.value, "", choiceTransitionName),
        "transitionName": getTransitionName(rootPrefixCls.value, getTransitionDirection(placement.value), transitionName),
        "getPopupContainer": getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        "customSlots": _extends(_extends({}, slots), {
          checkable: () => createVNode("span", {
            "class": `${cascaderPrefixCls.value}-checkbox-inner`
          }, null)
        }),
        "tagRender": props2.tagRender || slots.tagRender,
        "displayRender": props2.displayRender || slots.displayRender,
        "maxTagPlaceholder": props2.maxTagPlaceholder || slots.maxTagPlaceholder,
        "showArrow": formItemInputContext.hasFeedback || props2.showArrow,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "ref": selectRef
      }), slots)));
    };
  }
});
var cascader_default = withInstall(_extends(Cascader, {
  SHOW_CHILD,
  SHOW_PARENT
}));

// node_modules/ant-design-vue/es/grid/index.js
var grid_default = {
  useBreakpoint: useBreakpoint_default
};

// node_modules/ant-design-vue/es/col/index.js
var col_default = withInstall(Col_default);

// node_modules/ant-design-vue/es/comment/style/index.js
var genBaseStyle6 = (token) => {
  const {
    componentCls,
    commentBg,
    commentPaddingBase,
    commentNestIndent,
    commentFontSizeBase,
    commentFontSizeSm,
    commentAuthorNameColor,
    commentAuthorTimeColor,
    commentActionColor,
    commentActionHoverColor,
    commentActionsMarginBottom,
    commentActionsMarginTop,
    commentContentDetailPMarginBottom
  } = token;
  return {
    [componentCls]: {
      position: "relative",
      backgroundColor: commentBg,
      [`${componentCls}-inner`]: {
        display: "flex",
        padding: commentPaddingBase
      },
      [`${componentCls}-avatar`]: {
        position: "relative",
        flexShrink: 0,
        marginRight: token.marginSM,
        cursor: "pointer",
        [`img`]: {
          width: "32px",
          height: "32px",
          borderRadius: "50%"
        }
      },
      [`${componentCls}-content`]: {
        position: "relative",
        flex: `1 1 auto`,
        minWidth: `1px`,
        fontSize: commentFontSizeBase,
        wordWrap: "break-word",
        [`&-author`]: {
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "flex-start",
          marginBottom: token.marginXXS,
          fontSize: commentFontSizeBase,
          [`& > a,& > span`]: {
            paddingRight: token.paddingXS,
            fontSize: commentFontSizeSm,
            lineHeight: `18px`
          },
          [`&-name`]: {
            color: commentAuthorNameColor,
            fontSize: commentFontSizeBase,
            transition: `color ${token.motionDurationSlow}`,
            [`> *`]: {
              color: commentAuthorNameColor,
              [`&:hover`]: {
                color: commentAuthorNameColor
              }
            }
          },
          [`&-time`]: {
            color: commentAuthorTimeColor,
            whiteSpace: "nowrap",
            cursor: "auto"
          }
        },
        [`&-detail p`]: {
          marginBottom: commentContentDetailPMarginBottom,
          whiteSpace: "pre-wrap"
        }
      },
      [`${componentCls}-actions`]: {
        marginTop: commentActionsMarginTop,
        marginBottom: commentActionsMarginBottom,
        paddingLeft: 0,
        [`> li`]: {
          display: "inline-block",
          color: commentActionColor,
          [`> span`]: {
            marginRight: "10px",
            color: commentActionColor,
            fontSize: commentFontSizeSm,
            cursor: "pointer",
            transition: `color ${token.motionDurationSlow}`,
            userSelect: "none",
            [`&:hover`]: {
              color: commentActionHoverColor
            }
          }
        }
      },
      [`${componentCls}-nested`]: {
        marginLeft: commentNestIndent
      },
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var style_default16 = genComponentStyleHook("Comment", (token) => {
  const commentToken = merge(token, {
    commentBg: "inherit",
    commentPaddingBase: `${token.paddingMD}px 0`,
    commentNestIndent: `44px`,
    commentFontSizeBase: token.fontSize,
    commentFontSizeSm: token.fontSizeSM,
    commentAuthorNameColor: token.colorTextTertiary,
    commentAuthorTimeColor: token.colorTextPlaceholder,
    commentActionColor: token.colorTextTertiary,
    commentActionHoverColor: token.colorTextSecondary,
    commentActionsMarginBottom: "inherit",
    commentActionsMarginTop: token.marginSM,
    commentContentDetailPMarginBottom: "inherit"
  });
  return [genBaseStyle6(commentToken)];
});

// node_modules/ant-design-vue/es/comment/index.js
var commentProps = () => ({
  actions: Array,
  /** The element to display as the comment author. */
  author: vue_types_default.any,
  /** The element to display as the comment avatar - generally an antd Avatar */
  avatar: vue_types_default.any,
  /** The main content of the comment */
  content: vue_types_default.any,
  /** Comment prefix defaults to '.ant-comment' */
  prefixCls: String,
  /** A datetime element containing the time to be displayed */
  datetime: vue_types_default.any
});
var Comment = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AComment",
  inheritAttrs: false,
  props: commentProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("comment", props2);
    const [wrapSSR, hashId] = style_default16(prefixCls);
    const renderNested = (prefixCls2, children) => {
      return createVNode("div", {
        "class": `${prefixCls2}-nested`
      }, [children]);
    };
    const getAction = (actions) => {
      if (!actions || !actions.length) {
        return null;
      }
      const actionList = actions.map((action, index2) => createVNode("li", {
        "key": `action-${index2}`
      }, [action]));
      return actionList;
    };
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const pre = prefixCls.value;
      const actions = (_a2 = props2.actions) !== null && _a2 !== void 0 ? _a2 : (_b = slots.actions) === null || _b === void 0 ? void 0 : _b.call(slots);
      const author = (_c = props2.author) !== null && _c !== void 0 ? _c : (_d = slots.author) === null || _d === void 0 ? void 0 : _d.call(slots);
      const avatar = (_e = props2.avatar) !== null && _e !== void 0 ? _e : (_f = slots.avatar) === null || _f === void 0 ? void 0 : _f.call(slots);
      const content = (_g = props2.content) !== null && _g !== void 0 ? _g : (_h = slots.content) === null || _h === void 0 ? void 0 : _h.call(slots);
      const datetime = (_j = props2.datetime) !== null && _j !== void 0 ? _j : (_k = slots.datetime) === null || _k === void 0 ? void 0 : _k.call(slots);
      const avatarDom = createVNode("div", {
        "class": `${pre}-avatar`
      }, [typeof avatar === "string" ? createVNode("img", {
        "src": avatar,
        "alt": "comment-avatar"
      }, null) : avatar]);
      const actionDom = actions ? createVNode("ul", {
        "class": `${pre}-actions`
      }, [getAction(Array.isArray(actions) ? actions : [actions])]) : null;
      const authorContent = createVNode("div", {
        "class": `${pre}-content-author`
      }, [author && createVNode("span", {
        "class": `${pre}-content-author-name`
      }, [author]), datetime && createVNode("span", {
        "class": `${pre}-content-author-time`
      }, [datetime])]);
      const contentDom = createVNode("div", {
        "class": `${pre}-content`
      }, [authorContent, createVNode("div", {
        "class": `${pre}-content-detail`
      }, [content]), actionDom]);
      const comment = createVNode("div", {
        "class": `${pre}-inner`
      }, [avatarDom, contentDom]);
      const children = flattenChildren((_l = slots.default) === null || _l === void 0 ? void 0 : _l.call(slots));
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": [pre, {
          [`${pre}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value]
      }), [comment, children && children.length ? renderNested(pre, children) : null]));
    };
  }
});
var comment_default = withInstall(Comment);

// node_modules/ant-design-vue/es/date-picker/PickerButton.js
var PickerButton = (props2, _ref) => {
  let {
    attrs,
    slots
  } = _ref;
  return createVNode(button_default, _objectSpread2(_objectSpread2({
    "size": "small",
    "type": "primary"
  }, props2), attrs), slots);
};
var PickerButton_default = PickerButton;

// node_modules/ant-design-vue/es/date-picker/PickerTag.js
function PickerTag(props2, _ref) {
  let {
    slots,
    attrs
  } = _ref;
  return createVNode(tag_default, _objectSpread2(_objectSpread2({
    "color": "blue"
  }, props2), attrs), slots);
}

// node_modules/ant-design-vue/es/date-picker/util.js
function getPlaceholder(locale, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale.lang.yearPlaceholder) {
    return locale.lang.yearPlaceholder;
  }
  if (picker === "quarter" && locale.lang.quarterPlaceholder) {
    return locale.lang.quarterPlaceholder;
  }
  if (picker === "month" && locale.lang.monthPlaceholder) {
    return locale.lang.monthPlaceholder;
  }
  if (picker === "week" && locale.lang.weekPlaceholder) {
    return locale.lang.weekPlaceholder;
  }
  if (picker === "time" && locale.timePickerLocale.placeholder) {
    return locale.timePickerLocale.placeholder;
  }
  return locale.lang.placeholder;
}
function getRangePlaceholder(locale, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale.lang.yearPlaceholder) {
    return locale.lang.rangeYearPlaceholder;
  }
  if (picker === "month" && locale.lang.monthPlaceholder) {
    return locale.lang.rangeMonthPlaceholder;
  }
  if (picker === "week" && locale.lang.weekPlaceholder) {
    return locale.lang.rangeWeekPlaceholder;
  }
  if (picker === "time" && locale.timePickerLocale.placeholder) {
    return locale.timePickerLocale.rangePlaceholder;
  }
  return locale.lang.rangePlaceholder;
}
function transPlacement2DropdownAlign(direction, placement) {
  const overflow = {
    adjustX: 1,
    adjustY: 1
  };
  switch (placement) {
    case "bottomLeft": {
      return {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow
      };
    }
    case "bottomRight": {
      return {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow
      };
    }
    case "topLeft": {
      return {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow
      };
    }
    case "topRight": {
      return {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow
      };
    }
    default: {
      return {
        points: direction === "rtl" ? ["tr", "br"] : ["tl", "bl"],
        offset: [0, 4],
        overflow
      };
    }
  }
}

// node_modules/ant-design-vue/es/date-picker/generatePicker/props.js
function commonProps() {
  return {
    id: String,
    /**
     * @deprecated `dropdownClassName` is deprecated which will be removed in next major
     *   version.Please use `popupClassName` instead.
     */
    dropdownClassName: String,
    popupClassName: String,
    popupStyle: objectType(),
    transitionName: String,
    placeholder: String,
    allowClear: booleanType(),
    autofocus: booleanType(),
    disabled: booleanType(),
    tabindex: Number,
    open: booleanType(),
    defaultOpen: booleanType(),
    /** Make input readOnly to avoid popup keyboard in mobile */
    inputReadOnly: booleanType(),
    format: someType([String, Function, Array]),
    // Value
    // format:  string | CustomFormat<DateType> | (string | CustomFormat<DateType>)[];
    // Render
    // suffixIcon?: VueNode;
    // clearIcon?: VueNode;
    // prevIcon?: VueNode;
    // nextIcon?: VueNode;
    // superPrevIcon?: VueNode;
    // superNextIcon?: VueNode;
    getPopupContainer: functionType(),
    panelRender: functionType(),
    // // Events
    onChange: functionType(),
    "onUpdate:value": functionType(),
    onOk: functionType(),
    onOpenChange: functionType(),
    "onUpdate:open": functionType(),
    onFocus: functionType(),
    onBlur: functionType(),
    onMousedown: functionType(),
    onMouseup: functionType(),
    onMouseenter: functionType(),
    onMouseleave: functionType(),
    onClick: functionType(),
    onContextmenu: functionType(),
    onKeydown: functionType(),
    // WAI-ARIA
    role: String,
    name: String,
    autocomplete: String,
    direction: stringType(),
    showToday: booleanType(),
    showTime: someType([Boolean, Object]),
    locale: objectType(),
    size: stringType(),
    bordered: booleanType(),
    dateRender: functionType(),
    disabledDate: functionType(),
    mode: stringType(),
    picker: stringType(),
    valueFormat: String,
    placement: stringType(),
    status: stringType(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledHours: functionType(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledMinutes: functionType(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledSeconds: functionType()
  };
}
function datePickerProps() {
  return {
    defaultPickerValue: someType([Object, String]),
    defaultValue: someType([Object, String]),
    value: someType([Object, String]),
    presets: arrayType(),
    disabledTime: functionType(),
    renderExtraFooter: functionType(),
    showNow: booleanType(),
    monthCellRender: functionType(),
    // deprecated  Please use `monthCellRender"` instead.',
    monthCellContentRender: functionType()
  };
}
function rangePickerProps() {
  return {
    allowEmpty: arrayType(),
    dateRender: functionType(),
    defaultPickerValue: arrayType(),
    defaultValue: arrayType(),
    value: arrayType(),
    presets: arrayType(),
    disabledTime: functionType(),
    disabled: someType([Boolean, Array]),
    renderExtraFooter: functionType(),
    separator: {
      type: String
    },
    showTime: someType([Boolean, Object]),
    ranges: objectType(),
    placeholder: arrayType(),
    mode: arrayType(),
    onChange: functionType(),
    "onUpdate:value": functionType(),
    onCalendarChange: functionType(),
    onPanelChange: functionType(),
    onOk: functionType()
  };
}

// node_modules/ant-design-vue/es/date-picker/generatePicker/generateSinglePicker.js
var __rest9 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function generateSinglePicker(generateConfig2, extraProps) {
  function getPicker(picker, displayName) {
    const comProps = _extends(_extends(_extends({}, commonProps()), datePickerProps()), extraProps);
    return defineComponent({
      compatConfig: {
        MODE: 3
      },
      name: displayName,
      inheritAttrs: false,
      props: comProps,
      slots: Object,
      setup(_props, _ref) {
        let {
          slots,
          expose,
          attrs,
          emit
        } = _ref;
        const props2 = _props;
        const formItemContext = useInjectFormItemContext();
        const formItemInputContext = FormItemInputContext.useInject();
        if (true) {
          devWarning_default(picker !== "quarter", displayName || "DatePicker", `DatePicker.${displayName} is legacy usage. Please use DatePicker[picker='${picker}'] directly.`);
          devWarning_default(!props2.dropdownClassName, displayName || "DatePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
          devWarning_default(!(props2.monthCellContentRender || slots.monthCellContentRender), displayName || "DatePicker", '`monthCellContentRender` is deprecated. Please use `monthCellRender"` instead.');
          devWarning_default(!attrs.getCalendarContainer, displayName || "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
        }
        const {
          prefixCls,
          direction,
          getPopupContainer,
          size,
          rootPrefixCls,
          disabled
        } = useConfigInject_default("picker", props2);
        const {
          compactSize,
          compactItemClassnames
        } = useCompactItemContext(prefixCls, direction);
        const mergedSize = computed(() => compactSize.value || size.value);
        const [wrapSSR, hashId] = style_default8(prefixCls);
        const pickerRef = ref();
        expose({
          focus: () => {
            var _a2;
            (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
          },
          blur: () => {
            var _a2;
            (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
          }
        });
        const maybeToString = (date) => {
          return props2.valueFormat ? generateConfig2.toString(date, props2.valueFormat) : date;
        };
        const onChange = (date, dateString) => {
          const value2 = maybeToString(date);
          emit("update:value", value2);
          emit("change", value2, dateString);
          formItemContext.onFieldChange();
        };
        const onOpenChange = (open2) => {
          emit("update:open", open2);
          emit("openChange", open2);
        };
        const onFocus = (e) => {
          emit("focus", e);
        };
        const onBlur = (e) => {
          emit("blur", e);
          formItemContext.onFieldBlur();
        };
        const onPanelChange = (date, mode) => {
          const value2 = maybeToString(date);
          emit("panelChange", value2, mode);
        };
        const onOk = (date) => {
          const value2 = maybeToString(date);
          emit("ok", value2);
        };
        const [contextLocale] = useLocaleReceiver("DatePicker", en_US_default);
        const value = computed(() => {
          if (props2.value) {
            return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
          }
          return props2.value === "" ? void 0 : props2.value;
        });
        const defaultValue = computed(() => {
          if (props2.defaultValue) {
            return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
          }
          return props2.defaultValue === "" ? void 0 : props2.defaultValue;
        });
        const defaultPickerValue = computed(() => {
          if (props2.defaultPickerValue) {
            return props2.valueFormat ? generateConfig2.toDate(props2.defaultPickerValue, props2.valueFormat) : props2.defaultPickerValue;
          }
          return props2.defaultPickerValue === "" ? void 0 : props2.defaultPickerValue;
        });
        return () => {
          var _a2, _b, _c, _d, _e, _f;
          const locale = _extends(_extends({}, contextLocale.value), props2.locale);
          const p = _extends(_extends({}, props2), attrs);
          const {
            bordered = true,
            placeholder,
            suffixIcon = (_a2 = slots.suffixIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
            showToday = true,
            transitionName,
            allowClear = true,
            dateRender = slots.dateRender,
            renderExtraFooter = slots.renderExtraFooter,
            monthCellRender = slots.monthCellRender || props2.monthCellContentRender || slots.monthCellContentRender,
            clearIcon = (_b = slots.clearIcon) === null || _b === void 0 ? void 0 : _b.call(slots),
            id = formItemContext.id.value
          } = p, restProps = __rest9(p, ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "monthCellRender", "clearIcon", "id"]);
          const showTime = p.showTime === "" ? true : p.showTime;
          const {
            format: format2
          } = p;
          let additionalOverrideProps = {};
          if (picker) {
            additionalOverrideProps.picker = picker;
          }
          const mergedPicker = picker || p.picker || "date";
          additionalOverrideProps = _extends(_extends(_extends({}, additionalOverrideProps), showTime ? getTimeProps(_extends({
            format: format2,
            picker: mergedPicker
          }, typeof showTime === "object" ? showTime : {})) : {}), mergedPicker === "time" ? getTimeProps(_extends(_extends({
            format: format2
          }, restProps), {
            picker: mergedPicker
          })) : {});
          const pre = prefixCls.value;
          const suffixNode = createVNode(Fragment, null, [suffixIcon || (picker === "time" ? createVNode(ClockCircleOutlined_default, null, null) : createVNode(CalendarOutlined_default, null, null)), formItemInputContext.hasFeedback && formItemInputContext.feedbackIcon]);
          return wrapSSR(createVNode(vc_picker_default, _objectSpread2(_objectSpread2(_objectSpread2({
            "monthCellRender": monthCellRender,
            "dateRender": dateRender,
            "renderExtraFooter": renderExtraFooter,
            "ref": pickerRef,
            "placeholder": getPlaceholder(locale, mergedPicker, placeholder),
            "suffixIcon": suffixNode,
            "dropdownAlign": transPlacement2DropdownAlign(direction.value, props2.placement),
            "clearIcon": clearIcon || createVNode(CloseCircleFilled_default, null, null),
            "allowClear": allowClear,
            "transitionName": transitionName || `${rootPrefixCls.value}-slide-up`
          }, restProps), additionalOverrideProps), {}, {
            "id": id,
            "picker": mergedPicker,
            "value": value.value,
            "defaultValue": defaultValue.value,
            "defaultPickerValue": defaultPickerValue.value,
            "showToday": showToday,
            "locale": locale.lang,
            "class": classNames_default({
              [`${pre}-${mergedSize.value}`]: mergedSize.value,
              [`${pre}-borderless`]: !bordered
            }, getStatusClassNames(pre, getMergedStatus(formItemInputContext.status, props2.status), formItemInputContext.hasFeedback), attrs.class, hashId.value, compactItemClassnames.value),
            "disabled": disabled.value,
            "prefixCls": pre,
            "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
            "generateConfig": generateConfig2,
            "prevIcon": ((_c = slots.prevIcon) === null || _c === void 0 ? void 0 : _c.call(slots)) || createVNode("span", {
              "class": `${pre}-prev-icon`
            }, null),
            "nextIcon": ((_d = slots.nextIcon) === null || _d === void 0 ? void 0 : _d.call(slots)) || createVNode("span", {
              "class": `${pre}-next-icon`
            }, null),
            "superPrevIcon": ((_e = slots.superPrevIcon) === null || _e === void 0 ? void 0 : _e.call(slots)) || createVNode("span", {
              "class": `${pre}-super-prev-icon`
            }, null),
            "superNextIcon": ((_f = slots.superNextIcon) === null || _f === void 0 ? void 0 : _f.call(slots)) || createVNode("span", {
              "class": `${pre}-super-next-icon`
            }, null),
            "components": Components,
            "direction": direction.value,
            "dropdownClassName": classNames_default(hashId.value, props2.popupClassName, props2.dropdownClassName),
            "onChange": onChange,
            "onOpenChange": onOpenChange,
            "onFocus": onFocus,
            "onBlur": onBlur,
            "onPanelChange": onPanelChange,
            "onOk": onOk
          }), null));
        };
      }
    });
  }
  const DatePicker2 = getPicker(void 0, "ADatePicker");
  const WeekPicker2 = getPicker("week", "AWeekPicker");
  const MonthPicker2 = getPicker("month", "AMonthPicker");
  const YearPicker2 = getPicker("year", "AYearPicker");
  const TimePicker3 = getPicker("time", "TimePicker");
  const QuarterPicker2 = getPicker("quarter", "AQuarterPicker");
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker3,
    QuarterPicker: QuarterPicker2
  };
}

// node_modules/ant-design-vue/es/date-picker/generatePicker/generateRangePicker.js
var __rest10 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function generateRangePicker(generateConfig2, extraProps) {
  const RangePicker2 = defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARangePicker",
    inheritAttrs: false,
    props: _extends(_extends(_extends({}, commonProps()), rangePickerProps()), extraProps),
    slots: Object,
    setup(_props, _ref) {
      let {
        expose,
        slots,
        attrs,
        emit
      } = _ref;
      const props2 = _props;
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      if (true) {
        devWarning_default(!props2.dropdownClassName, "RangePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
        devWarning_default(!attrs.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
      }
      const {
        prefixCls,
        direction,
        getPopupContainer,
        size,
        rootPrefixCls,
        disabled
      } = useConfigInject_default("picker", props2);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = computed(() => compactSize.value || size.value);
      const [wrapSSR, hashId] = style_default8(prefixCls);
      const pickerRef = ref();
      expose({
        focus: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const maybeToStrings = (dates) => {
        return props2.valueFormat ? generateConfig2.toString(dates, props2.valueFormat) : dates;
      };
      const onChange = (dates, dateStrings) => {
        const values = maybeToStrings(dates);
        emit("update:value", values);
        emit("change", values, dateStrings);
        formItemContext.onFieldChange();
      };
      const onOpenChange = (open2) => {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      const onFocus = (e) => {
        emit("focus", e);
      };
      const onBlur = (e) => {
        emit("blur", e);
        formItemContext.onFieldBlur();
      };
      const onPanelChange = (dates, modes) => {
        const values = maybeToStrings(dates);
        emit("panelChange", values, modes);
      };
      const onOk = (dates) => {
        const value2 = maybeToStrings(dates);
        emit("ok", value2);
      };
      const onCalendarChange = (dates, dateStrings, info) => {
        const values = maybeToStrings(dates);
        emit("calendarChange", values, dateStrings, info);
      };
      const [contextLocale] = useLocaleReceiver("DatePicker", en_US_default);
      const value = computed(() => {
        if (props2.value) {
          return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
        }
        return props2.value;
      });
      const defaultValue = computed(() => {
        if (props2.defaultValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
        }
        return props2.defaultValue;
      });
      const defaultPickerValue = computed(() => {
        if (props2.defaultPickerValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultPickerValue, props2.valueFormat) : props2.defaultPickerValue;
        }
        return props2.defaultPickerValue;
      });
      return () => {
        var _a2, _b, _c, _d, _e, _f, _g;
        const locale = _extends(_extends({}, contextLocale.value), props2.locale);
        const p = _extends(_extends({}, props2), attrs);
        const {
          prefixCls: customizePrefixCls,
          bordered = true,
          placeholder,
          suffixIcon = (_a2 = slots.suffixIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          picker = "date",
          transitionName,
          allowClear = true,
          dateRender = slots.dateRender,
          renderExtraFooter = slots.renderExtraFooter,
          separator = (_b = slots.separator) === null || _b === void 0 ? void 0 : _b.call(slots),
          clearIcon = (_c = slots.clearIcon) === null || _c === void 0 ? void 0 : _c.call(slots),
          id = formItemContext.id.value
        } = p, restProps = __rest10(p, ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"]);
        delete restProps["onUpdate:value"];
        delete restProps["onUpdate:open"];
        const {
          format: format2,
          showTime
        } = p;
        let additionalOverrideProps = {};
        additionalOverrideProps = _extends(_extends(_extends({}, additionalOverrideProps), showTime ? getTimeProps(_extends({
          format: format2,
          picker
        }, showTime)) : {}), picker === "time" ? getTimeProps(_extends(_extends({
          format: format2
        }, omit_default(restProps, ["disabledTime"])), {
          picker
        })) : {});
        const pre = prefixCls.value;
        const suffixNode = createVNode(Fragment, null, [suffixIcon || (picker === "time" ? createVNode(ClockCircleOutlined_default, null, null) : createVNode(CalendarOutlined_default, null, null)), formItemInputContext.hasFeedback && formItemInputContext.feedbackIcon]);
        return wrapSSR(createVNode(RangePicker_default, _objectSpread2(_objectSpread2(_objectSpread2({
          "dateRender": dateRender,
          "renderExtraFooter": renderExtraFooter,
          "separator": separator || createVNode("span", {
            "aria-label": "to",
            "class": `${pre}-separator`
          }, [createVNode(SwapRightOutlined_default, null, null)]),
          "ref": pickerRef,
          "dropdownAlign": transPlacement2DropdownAlign(direction.value, props2.placement),
          "placeholder": getRangePlaceholder(locale, picker, placeholder),
          "suffixIcon": suffixNode,
          "clearIcon": clearIcon || createVNode(CloseCircleFilled_default, null, null),
          "allowClear": allowClear,
          "transitionName": transitionName || `${rootPrefixCls.value}-slide-up`
        }, restProps), additionalOverrideProps), {}, {
          "disabled": disabled.value,
          "id": id,
          "value": value.value,
          "defaultValue": defaultValue.value,
          "defaultPickerValue": defaultPickerValue.value,
          "picker": picker,
          "class": classNames_default({
            [`${pre}-${mergedSize.value}`]: mergedSize.value,
            [`${pre}-borderless`]: !bordered
          }, getStatusClassNames(pre, getMergedStatus(formItemInputContext.status, props2.status), formItemInputContext.hasFeedback), attrs.class, hashId.value, compactItemClassnames.value),
          "locale": locale.lang,
          "prefixCls": pre,
          "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
          "generateConfig": generateConfig2,
          "prevIcon": ((_d = slots.prevIcon) === null || _d === void 0 ? void 0 : _d.call(slots)) || createVNode("span", {
            "class": `${pre}-prev-icon`
          }, null),
          "nextIcon": ((_e = slots.nextIcon) === null || _e === void 0 ? void 0 : _e.call(slots)) || createVNode("span", {
            "class": `${pre}-next-icon`
          }, null),
          "superPrevIcon": ((_f = slots.superPrevIcon) === null || _f === void 0 ? void 0 : _f.call(slots)) || createVNode("span", {
            "class": `${pre}-super-prev-icon`
          }, null),
          "superNextIcon": ((_g = slots.superNextIcon) === null || _g === void 0 ? void 0 : _g.call(slots)) || createVNode("span", {
            "class": `${pre}-super-next-icon`
          }, null),
          "components": Components,
          "direction": direction.value,
          "dropdownClassName": classNames_default(hashId.value, props2.popupClassName, props2.dropdownClassName),
          "onChange": onChange,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onPanelChange": onPanelChange,
          "onOk": onOk,
          "onCalendarChange": onCalendarChange
        }), null));
      };
    }
  });
  return RangePicker2;
}

// node_modules/ant-design-vue/es/date-picker/generatePicker/index.js
var Components = {
  button: PickerButton_default,
  rangeItem: PickerTag
};
function toArray2(list) {
  if (!list) {
    return [];
  }
  return Array.isArray(list) ? list : [list];
}
function getTimeProps(props2) {
  const {
    format: format2,
    picker,
    showHour,
    showMinute,
    showSecond,
    use12Hours
  } = props2;
  const firstFormat = toArray2(format2)[0];
  const showTimeObj = _extends({}, props2);
  if (firstFormat && typeof firstFormat === "string") {
    if (!firstFormat.includes("s") && showSecond === void 0) {
      showTimeObj.showSecond = false;
    }
    if (!firstFormat.includes("m") && showMinute === void 0) {
      showTimeObj.showMinute = false;
    }
    if (!firstFormat.includes("H") && !firstFormat.includes("h") && showHour === void 0) {
      showTimeObj.showHour = false;
    }
    if ((firstFormat.includes("a") || firstFormat.includes("A")) && use12Hours === void 0) {
      showTimeObj.use12Hours = true;
    }
  }
  if (picker === "time") {
    return showTimeObj;
  }
  if (typeof firstFormat === "function") {
    delete showTimeObj.format;
  }
  return {
    showTime: showTimeObj
  };
}
function generatePicker(generateConfig2, extraProps) {
  const {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker3,
    QuarterPicker: QuarterPicker2
  } = generateSinglePicker(generateConfig2, extraProps);
  const RangePicker2 = generateRangePicker(generateConfig2, extraProps);
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker3,
    QuarterPicker: QuarterPicker2,
    RangePicker: RangePicker2
  };
}
var generatePicker_default = generatePicker;

// node_modules/ant-design-vue/es/date-picker/dayjs.js
var {
  DatePicker,
  WeekPicker,
  MonthPicker,
  YearPicker,
  TimePicker,
  QuarterPicker,
  RangePicker
} = generatePicker_default(dayjs_default);
var dayjs_default3 = _extends(DatePicker, {
  WeekPicker,
  MonthPicker,
  YearPicker,
  RangePicker,
  TimePicker,
  QuarterPicker,
  install: (app) => {
    app.component(DatePicker.name, DatePicker);
    app.component(RangePicker.name, RangePicker);
    app.component(MonthPicker.name, MonthPicker);
    app.component(WeekPicker.name, WeekPicker);
    app.component(QuarterPicker.name, QuarterPicker);
    return app;
  }
});

// node_modules/ant-design-vue/es/date-picker/index.js
var date_picker_default = dayjs_default3;

// node_modules/ant-design-vue/es/descriptions/Cell.js
function notEmpty(val) {
  return val !== void 0 && val !== null;
}
var Cell = (props2) => {
  const {
    itemPrefixCls,
    component,
    span,
    labelStyle,
    contentStyle,
    bordered,
    label,
    content,
    colon
  } = props2;
  const Component = component;
  if (bordered) {
    return createVNode(Component, {
      "class": [{
        [`${itemPrefixCls}-item-label`]: notEmpty(label),
        [`${itemPrefixCls}-item-content`]: notEmpty(content)
      }],
      "colSpan": span
    }, {
      default: () => [notEmpty(label) && createVNode("span", {
        "style": labelStyle
      }, [label]), notEmpty(content) && createVNode("span", {
        "style": contentStyle
      }, [content])]
    });
  }
  return createVNode(Component, {
    "class": [`${itemPrefixCls}-item`],
    "colSpan": span
  }, {
    default: () => [createVNode("div", {
      "class": `${itemPrefixCls}-item-container`
    }, [(label || label === 0) && createVNode("span", {
      "class": [`${itemPrefixCls}-item-label`, {
        [`${itemPrefixCls}-item-no-colon`]: !colon
      }],
      "style": labelStyle
    }, [label]), (content || content === 0) && createVNode("span", {
      "class": `${itemPrefixCls}-item-content`,
      "style": contentStyle
    }, [content])])]
  });
};
var Cell_default = Cell;

// node_modules/ant-design-vue/es/descriptions/Row.js
var Row = (props2) => {
  const renderCells = (items, _ref, _ref2) => {
    let {
      colon,
      prefixCls: prefixCls2,
      bordered: bordered2
    } = _ref;
    let {
      component,
      type,
      showLabel,
      showContent,
      labelStyle: rootLabelStyle,
      contentStyle: rootContentStyle
    } = _ref2;
    return items.map((item, index3) => {
      var _a2, _b;
      const itemProps = item.props || {};
      const {
        prefixCls: itemPrefixCls = prefixCls2,
        span = 1,
        labelStyle: labelStyle2 = itemProps["label-style"],
        contentStyle: contentStyle2 = itemProps["content-style"],
        label = (_b = (_a2 = item.children) === null || _a2 === void 0 ? void 0 : _a2.label) === null || _b === void 0 ? void 0 : _b.call(_a2)
      } = itemProps;
      const children = getSlot(item);
      const className = getClass(item);
      const style = getStyle(item);
      const {
        key
      } = item;
      if (typeof component === "string") {
        return createVNode(Cell_default, {
          "key": `${type}-${String(key) || index3}`,
          "class": className,
          "style": style,
          "labelStyle": _extends(_extends({}, rootLabelStyle), labelStyle2),
          "contentStyle": _extends(_extends({}, rootContentStyle), contentStyle2),
          "span": span,
          "colon": colon,
          "component": component,
          "itemPrefixCls": itemPrefixCls,
          "bordered": bordered2,
          "label": showLabel ? label : null,
          "content": showContent ? children : null
        }, null);
      }
      return [createVNode(Cell_default, {
        "key": `label-${String(key) || index3}`,
        "class": className,
        "style": _extends(_extends(_extends({}, rootLabelStyle), style), labelStyle2),
        "span": 1,
        "colon": colon,
        "component": component[0],
        "itemPrefixCls": itemPrefixCls,
        "bordered": bordered2,
        "label": label
      }, null), createVNode(Cell_default, {
        "key": `content-${String(key) || index3}`,
        "class": className,
        "style": _extends(_extends(_extends({}, rootContentStyle), style), contentStyle2),
        "span": span * 2 - 1,
        "component": component[1],
        "itemPrefixCls": itemPrefixCls,
        "bordered": bordered2,
        "content": children
      }, null)];
    });
  };
  const {
    prefixCls,
    vertical,
    row,
    index: index2,
    bordered
  } = props2;
  const {
    labelStyle,
    contentStyle
  } = inject(descriptionsContext, {
    labelStyle: ref({}),
    contentStyle: ref({})
  });
  if (vertical) {
    return createVNode(Fragment, null, [createVNode("tr", {
      "key": `label-${index2}`,
      "class": `${prefixCls}-row`
    }, [renderCells(row, props2, {
      component: "th",
      type: "label",
      showLabel: true,
      labelStyle: labelStyle.value,
      contentStyle: contentStyle.value
    })]), createVNode("tr", {
      "key": `content-${index2}`,
      "class": `${prefixCls}-row`
    }, [renderCells(row, props2, {
      component: "td",
      type: "content",
      showContent: true,
      labelStyle: labelStyle.value,
      contentStyle: contentStyle.value
    })])]);
  }
  return createVNode("tr", {
    "key": index2,
    "class": `${prefixCls}-row`
  }, [renderCells(row, props2, {
    component: bordered ? ["th", "td"] : "td",
    type: "item",
    showLabel: true,
    showContent: true,
    labelStyle: labelStyle.value,
    contentStyle: contentStyle.value
  })]);
};
var Row_default2 = Row;

// node_modules/ant-design-vue/es/descriptions/style/index.js
var genBorderedStyle = (token) => {
  const {
    componentCls,
    descriptionsSmallPadding,
    descriptionsDefaultPadding,
    descriptionsMiddlePadding,
    descriptionsBg
  } = token;
  return {
    [`&${componentCls}-bordered`]: {
      [`${componentCls}-view`]: {
        border: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`,
        "> table": {
          tableLayout: "auto",
          borderCollapse: "collapse"
        }
      },
      [`${componentCls}-item-label, ${componentCls}-item-content`]: {
        padding: descriptionsDefaultPadding,
        borderInlineEnd: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`,
        "&:last-child": {
          borderInlineEnd: "none"
        }
      },
      [`${componentCls}-item-label`]: {
        backgroundColor: descriptionsBg,
        "&::after": {
          display: "none"
        }
      },
      [`${componentCls}-row`]: {
        borderBottom: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`,
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`&${componentCls}-middle`]: {
        [`${componentCls}-item-label, ${componentCls}-item-content`]: {
          padding: descriptionsMiddlePadding
        }
      },
      [`&${componentCls}-small`]: {
        [`${componentCls}-item-label, ${componentCls}-item-content`]: {
          padding: descriptionsSmallPadding
        }
      }
    }
  };
};
var genDescriptionStyles = (token) => {
  const {
    componentCls,
    descriptionsExtraColor,
    descriptionItemPaddingBottom,
    descriptionsItemLabelColonMarginRight,
    descriptionsItemLabelColonMarginLeft,
    descriptionsTitleMarginBottom
  } = token;
  return {
    [componentCls]: _extends(_extends(_extends({}, resetComponent(token)), genBorderedStyle(token)), {
      [`&-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-header`]: {
        display: "flex",
        alignItems: "center",
        marginBottom: descriptionsTitleMarginBottom
      },
      [`${componentCls}-title`]: _extends(_extends({}, textEllipsis), {
        flex: "auto",
        color: token.colorText,
        fontWeight: token.fontWeightStrong,
        fontSize: token.fontSizeLG,
        lineHeight: token.lineHeightLG
      }),
      [`${componentCls}-extra`]: {
        marginInlineStart: "auto",
        color: descriptionsExtraColor,
        fontSize: token.fontSize
      },
      [`${componentCls}-view`]: {
        width: "100%",
        borderRadius: token.borderRadiusLG,
        table: {
          width: "100%",
          tableLayout: "fixed"
        }
      },
      [`${componentCls}-row`]: {
        "> th, > td": {
          paddingBottom: descriptionItemPaddingBottom
        },
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`${componentCls}-item-label`]: {
        color: token.colorText,
        fontWeight: "normal",
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        textAlign: `start`,
        "&::after": {
          content: '":"',
          position: "relative",
          top: -0.5,
          marginInline: `${descriptionsItemLabelColonMarginLeft}px ${descriptionsItemLabelColonMarginRight}px`
        },
        [`&${componentCls}-item-no-colon::after`]: {
          content: '""'
        }
      },
      [`${componentCls}-item-no-label`]: {
        "&::after": {
          margin: 0,
          content: '""'
        }
      },
      [`${componentCls}-item-content`]: {
        display: "table-cell",
        flex: 1,
        color: token.colorText,
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        wordBreak: "break-word",
        overflowWrap: "break-word"
      },
      [`${componentCls}-item`]: {
        paddingBottom: 0,
        verticalAlign: "top",
        "&-container": {
          display: "flex",
          [`${componentCls}-item-label`]: {
            display: "inline-flex",
            alignItems: "baseline"
          },
          [`${componentCls}-item-content`]: {
            display: "inline-flex",
            alignItems: "baseline"
          }
        }
      },
      "&-middle": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token.paddingSM
          }
        }
      },
      "&-small": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token.paddingXS
          }
        }
      }
    })
  };
};
var style_default17 = genComponentStyleHook("Descriptions", (token) => {
  const descriptionsBg = token.colorFillAlter;
  const descriptionsTitleMarginBottom = token.fontSizeSM * token.lineHeightSM;
  const descriptionsExtraColor = token.colorText;
  const descriptionsSmallPadding = `${token.paddingXS}px ${token.padding}px`;
  const descriptionsDefaultPadding = `${token.padding}px ${token.paddingLG}px`;
  const descriptionsMiddlePadding = `${token.paddingSM}px ${token.paddingLG}px`;
  const descriptionItemPaddingBottom = token.padding;
  const descriptionsItemLabelColonMarginRight = token.marginXS;
  const descriptionsItemLabelColonMarginLeft = token.marginXXS / 2;
  const descriptionToken = merge(token, {
    descriptionsBg,
    descriptionsTitleMarginBottom,
    descriptionsExtraColor,
    descriptionItemPaddingBottom,
    descriptionsSmallPadding,
    descriptionsDefaultPadding,
    descriptionsMiddlePadding,
    descriptionsItemLabelColonMarginRight,
    descriptionsItemLabelColonMarginLeft
  });
  return [genDescriptionStyles(descriptionToken)];
});

// node_modules/ant-design-vue/es/descriptions/index.js
var DescriptionsItemProps = {
  prefixCls: String,
  label: vue_types_default.any,
  span: Number
};
var descriptionsItemProp = () => ({
  prefixCls: String,
  label: vue_types_default.any,
  labelStyle: {
    type: Object,
    default: void 0
  },
  contentStyle: {
    type: Object,
    default: void 0
  },
  span: {
    type: Number,
    default: 1
  }
});
var DescriptionsItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptionsItem",
  props: descriptionsItemProp(),
  setup(_, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
var DEFAULT_COLUMN_MAP = {
  xxxl: 3,
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
function getColumn(column, screens) {
  if (typeof column === "number") {
    return column;
  }
  if (typeof column === "object") {
    for (let i = 0; i < responsiveArray.length; i++) {
      const breakpoint = responsiveArray[i];
      if (screens[breakpoint] && column[breakpoint] !== void 0) {
        return column[breakpoint] || DEFAULT_COLUMN_MAP[breakpoint];
      }
    }
  }
  return 3;
}
function getFilledItem(node, rowRestCol, span) {
  let clone = node;
  if (span === void 0 || span > rowRestCol) {
    clone = cloneElement(node, {
      span: rowRestCol
    });
    warning_default2(span === void 0, "Descriptions", "Sum of column `span` in a line not match `column` of Descriptions.");
  }
  return clone;
}
function getRows(children, column) {
  const childNodes = flattenChildren(children);
  const rows = [];
  let tmpRow = [];
  let rowRestCol = column;
  childNodes.forEach((node, index2) => {
    var _a2;
    const span = (_a2 = node.props) === null || _a2 === void 0 ? void 0 : _a2.span;
    const mergedSpan = span || 1;
    if (index2 === childNodes.length - 1) {
      tmpRow.push(getFilledItem(node, rowRestCol, span));
      rows.push(tmpRow);
      return;
    }
    if (mergedSpan < rowRestCol) {
      rowRestCol -= mergedSpan;
      tmpRow.push(node);
    } else {
      tmpRow.push(getFilledItem(node, rowRestCol, mergedSpan));
      rows.push(tmpRow);
      rowRestCol = column;
      tmpRow = [];
    }
  });
  return rows;
}
var descriptionsProps = () => ({
  prefixCls: String,
  bordered: {
    type: Boolean,
    default: void 0
  },
  size: {
    type: String,
    default: "default"
  },
  title: vue_types_default.any,
  extra: vue_types_default.any,
  column: {
    type: [Number, Object],
    default: () => DEFAULT_COLUMN_MAP
  },
  layout: String,
  colon: {
    type: Boolean,
    default: void 0
  },
  labelStyle: {
    type: Object,
    default: void 0
  },
  contentStyle: {
    type: Object,
    default: void 0
  }
});
var descriptionsContext = Symbol("descriptionsContext");
var Descriptions = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptions",
  inheritAttrs: false,
  props: descriptionsProps(),
  slots: Object,
  Item: DescriptionsItem,
  setup(props2, _ref2) {
    let {
      slots,
      attrs
    } = _ref2;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("descriptions", props2);
    let token;
    const screens = ref({});
    const [wrapSSR, hashId] = style_default17(prefixCls);
    const responsiveObserve = useResponsiveObserver();
    onBeforeMount(() => {
      token = responsiveObserve.value.subscribe((screen) => {
        if (typeof props2.column !== "object") {
          return;
        }
        screens.value = screen;
      });
    });
    onBeforeUnmount(() => {
      responsiveObserve.value.unsubscribe(token);
    });
    provide(descriptionsContext, {
      labelStyle: toRef(props2, "labelStyle"),
      contentStyle: toRef(props2, "contentStyle")
    });
    const mergeColumn = computed(() => getColumn(props2.column, screens.value));
    return () => {
      var _a2, _b, _c;
      const {
        size,
        bordered = false,
        layout = "horizontal",
        colon = true,
        title = (_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        extra = (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots)
      } = props2;
      const children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      const rows = getRows(children, mergeColumn.value);
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": [prefixCls.value, {
          [`${prefixCls.value}-${size}`]: size !== "default",
          [`${prefixCls.value}-bordered`]: !!bordered,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value]
      }), [(title || extra) && createVNode("div", {
        "class": `${prefixCls.value}-header`
      }, [title && createVNode("div", {
        "class": `${prefixCls.value}-title`
      }, [title]), extra && createVNode("div", {
        "class": `${prefixCls.value}-extra`
      }, [extra])]), createVNode("div", {
        "class": `${prefixCls.value}-view`
      }, [createVNode("table", null, [createVNode("tbody", null, [rows.map((row, index2) => createVNode(Row_default2, {
        "key": index2,
        "index": index2,
        "colon": colon,
        "prefixCls": prefixCls.value,
        "vertical": layout === "vertical",
        "bordered": bordered,
        "row": row
      }, null))])])])]));
    };
  }
});
Descriptions.install = function(app) {
  app.component(Descriptions.name, Descriptions);
  app.component(Descriptions.Item.name, Descriptions.Item);
  return app;
};
var descriptions_default = Descriptions;

// node_modules/ant-design-vue/es/vc-drawer/src/IDrawerPropTypes.js
var props = () => ({
  prefixCls: String,
  width: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number]),
  height: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number]),
  style: {
    type: Object,
    default: void 0
  },
  class: String,
  rootClassName: String,
  rootStyle: objectType(),
  placement: {
    type: String
  },
  wrapperClassName: String,
  level: {
    type: [String, Array]
  },
  levelMove: {
    type: [Number, Function, Array]
  },
  duration: String,
  ease: String,
  showMask: {
    type: Boolean,
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  maskStyle: {
    type: Object,
    default: void 0
  },
  afterVisibleChange: Function,
  keyboard: {
    type: Boolean,
    default: void 0
  },
  contentWrapperStyle: arrayType(),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  // Motion
  motion: functionType(),
  maskMotion: objectType()
});
var drawerProps = () => _extends(_extends({}, props()), {
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.func, vue_types_default.object, vue_types_default.looseBool])
});
var drawerChildProps = () => _extends(_extends({}, props()), {
  getContainer: Function,
  getOpenCount: Function,
  scrollLocker: vue_types_default.any,
  inline: Boolean
});

// node_modules/ant-design-vue/es/vc-drawer/src/utils.js
function dataToArray(vars) {
  if (Array.isArray(vars)) {
    return vars;
  }
  return [vars];
}
var transitionEndObject = {
  transition: "transitionend",
  WebkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd otransitionend"
};
var transitionStr = Object.keys(transitionEndObject).filter((key) => {
  if (typeof document === "undefined") {
    return false;
  }
  const html = document.getElementsByTagName("html")[0];
  return key in (html ? html.style : {});
})[0];
var transitionEndFun = transitionEndObject[transitionStr];
var windowIsUndefined = !(typeof window !== "undefined" && window.document && window.document.createElement);

// node_modules/ant-design-vue/es/vc-drawer/src/DrawerChild.js
var __rest11 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var currentDrawer = {};
var DrawerChild = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: drawerChildProps(),
  emits: ["close", "handleClick", "change"],
  setup(props2, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const contentWrapper = shallowRef();
    const dom = shallowRef();
    const maskDom = shallowRef();
    const handlerDom = shallowRef();
    const contentDom = shallowRef();
    let levelDom = [];
    const drawerId = `drawer_id_${Number((Date.now() + Math.random()).toString().replace(".", Math.round(Math.random() * 9).toString())).toString(16)}`;
    onMounted(() => {
      nextTick(() => {
        var _a2;
        const {
          open: open2,
          getContainer,
          showMask,
          autofocus
        } = props2;
        const container = getContainer === null || getContainer === void 0 ? void 0 : getContainer();
        getLevelDom(props2);
        if (open2) {
          if (container && container.parentNode === document.body) {
            currentDrawer[drawerId] = open2;
          }
          nextTick(() => {
            if (autofocus) {
              domFocus();
            }
          });
          if (showMask) {
            (_a2 = props2.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.lock();
          }
        }
      });
    });
    watch(() => props2.level, () => {
      getLevelDom(props2);
    }, {
      flush: "post"
    });
    watch(() => props2.open, () => {
      const {
        open: open2,
        getContainer,
        scrollLocker,
        showMask,
        autofocus
      } = props2;
      const container = getContainer === null || getContainer === void 0 ? void 0 : getContainer();
      if (container && container.parentNode === document.body) {
        currentDrawer[drawerId] = !!open2;
      }
      if (open2) {
        if (autofocus) {
          domFocus();
        }
        if (showMask) {
          scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.lock();
        }
      } else {
        scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.unLock();
      }
    }, {
      flush: "post"
    });
    onUnmounted(() => {
      var _a2;
      const {
        open: open2
      } = props2;
      delete currentDrawer[drawerId];
      if (open2) {
        document.body.style.touchAction = "";
      }
      (_a2 = props2.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.unLock();
    });
    watch(() => props2.placement, (val) => {
      if (val) {
        contentDom.value = null;
      }
    });
    const domFocus = () => {
      var _a2, _b;
      (_b = (_a2 = dom.value) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b === void 0 ? void 0 : _b.call(_a2);
    };
    const onClose = (e) => {
      emit("close", e);
    };
    const onKeyDown = (e) => {
      if (e.keyCode === KeyCode_default.ESC) {
        e.stopPropagation();
        onClose(e);
      }
    };
    const onAfterVisibleChange = () => {
      const {
        open: open2,
        afterVisibleChange
      } = props2;
      if (afterVisibleChange) {
        afterVisibleChange(!!open2);
      }
    };
    const getLevelDom = (_ref2) => {
      let {
        level,
        getContainer
      } = _ref2;
      if (windowIsUndefined) {
        return;
      }
      const container = getContainer === null || getContainer === void 0 ? void 0 : getContainer();
      const parent = container ? container.parentNode : null;
      levelDom = [];
      if (level === "all") {
        const children = parent ? Array.prototype.slice.call(parent.children) : [];
        children.forEach((child) => {
          if (child.nodeName !== "SCRIPT" && child.nodeName !== "STYLE" && child.nodeName !== "LINK" && child !== container) {
            levelDom.push(child);
          }
        });
      } else if (level) {
        dataToArray(level).forEach((key) => {
          document.querySelectorAll(key).forEach((item) => {
            levelDom.push(item);
          });
        });
      }
    };
    const onHandleClick = (e) => {
      emit("handleClick", e);
    };
    const canOpen = shallowRef(false);
    watch(dom, () => {
      nextTick(() => {
        canOpen.value = true;
      });
    });
    return () => {
      var _a2, _b;
      const {
        width,
        height,
        open: $open,
        prefixCls,
        placement,
        level,
        levelMove,
        ease,
        duration,
        getContainer,
        onChange,
        afterVisibleChange,
        showMask,
        maskClosable,
        maskStyle,
        keyboard,
        getOpenCount,
        scrollLocker,
        contentWrapperStyle,
        style,
        class: className,
        rootClassName,
        rootStyle,
        maskMotion,
        motion,
        inline
      } = props2, otherProps = __rest11(props2, ["width", "height", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration", "getContainer", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "keyboard", "getOpenCount", "scrollLocker", "contentWrapperStyle", "style", "class", "rootClassName", "rootStyle", "maskMotion", "motion", "inline"]);
      const open2 = $open && canOpen.value;
      const wrapperClassName = classNames_default(prefixCls, {
        [`${prefixCls}-${placement}`]: true,
        [`${prefixCls}-open`]: open2,
        [`${prefixCls}-inline`]: inline,
        "no-mask": !showMask,
        [rootClassName]: true
      });
      const motionProps = typeof motion === "function" ? motion(placement) : motion;
      return createVNode("div", _objectSpread2(_objectSpread2({}, omit_default(otherProps, ["autofocus"])), {}, {
        "tabindex": -1,
        "class": wrapperClassName,
        "style": rootStyle,
        "ref": dom,
        "onKeydown": open2 && keyboard ? onKeyDown : void 0
      }), [createVNode(Transition, maskMotion, {
        default: () => [showMask && withDirectives(createVNode("div", {
          "class": `${prefixCls}-mask`,
          "onClick": maskClosable ? onClose : void 0,
          "style": maskStyle,
          "ref": maskDom
        }, null), [[vShow, open2]])]
      }), createVNode(Transition, _objectSpread2(_objectSpread2({}, motionProps), {}, {
        "onAfterEnter": onAfterVisibleChange,
        "onAfterLeave": onAfterVisibleChange
      }), {
        default: () => [withDirectives(createVNode("div", {
          "class": `${prefixCls}-content-wrapper`,
          "style": [contentWrapperStyle],
          "ref": contentWrapper
        }, [createVNode("div", {
          "class": [`${prefixCls}-content`, className],
          "style": style,
          "ref": contentDom
        }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), slots.handler ? createVNode("div", {
          "onClick": onHandleClick,
          "ref": handlerDom
        }, [(_b = slots.handler) === null || _b === void 0 ? void 0 : _b.call(slots)]) : null]), [[vShow, open2]])]
      })]);
    };
  }
});
var DrawerChild_default = DrawerChild;

// node_modules/ant-design-vue/es/vc-drawer/src/DrawerWrapper.js
var __rest12 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var DrawerWrapper = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: initDefaultProps_default(drawerProps(), {
    prefixCls: "drawer",
    placement: "left",
    getContainer: "body",
    level: "all",
    duration: ".3s",
    ease: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    afterVisibleChange: () => {
    },
    showMask: true,
    maskClosable: true,
    maskStyle: {},
    wrapperClassName: "",
    keyboard: true,
    forceRender: false,
    autofocus: true
  }),
  emits: ["handleClick", "close"],
  setup(props2, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const dom = ref(null);
    const onHandleClick = (e) => {
      emit("handleClick", e);
    };
    const onClose = (e) => {
      emit("close", e);
    };
    return () => {
      const {
        getContainer,
        wrapperClassName,
        rootClassName,
        rootStyle,
        forceRender
      } = props2, otherProps = __rest12(props2, ["getContainer", "wrapperClassName", "rootClassName", "rootStyle", "forceRender"]);
      let portal = null;
      if (!getContainer) {
        return createVNode(DrawerChild_default, _objectSpread2(_objectSpread2({}, otherProps), {}, {
          "rootClassName": rootClassName,
          "rootStyle": rootStyle,
          "open": props2.open,
          "onClose": onClose,
          "onHandleClick": onHandleClick,
          "inline": true
        }), slots);
      }
      const $forceRender = !!slots.handler || forceRender;
      if ($forceRender || props2.open || dom.value) {
        portal = createVNode(PortalWrapper_default, {
          "autoLock": true,
          "visible": props2.open,
          "forceRender": $forceRender,
          "getContainer": getContainer,
          "wrapperClassName": wrapperClassName
        }, {
          default: (_a2) => {
            var {
              visible,
              afterClose
            } = _a2, rest = __rest12(_a2, ["visible", "afterClose"]);
            return createVNode(DrawerChild_default, _objectSpread2(_objectSpread2(_objectSpread2({
              "ref": dom
            }, otherProps), rest), {}, {
              "rootClassName": rootClassName,
              "rootStyle": rootStyle,
              "open": visible !== void 0 ? visible : props2.open,
              "afterVisibleChange": afterClose !== void 0 ? afterClose : props2.afterVisibleChange,
              "onClose": onClose,
              "onHandleClick": onHandleClick
            }), slots);
          }
        });
      }
      return portal;
    };
  }
});
var DrawerWrapper_default = DrawerWrapper;

// node_modules/ant-design-vue/es/vc-drawer/index.js
var vc_drawer_default = DrawerWrapper_default;

// node_modules/ant-design-vue/es/drawer/style/motion.js
var genMotionStyle2 = (token) => {
  const {
    componentCls,
    motionDurationSlow
  } = token;
  const sharedPanelMotion = {
    "&-enter, &-appear, &-leave": {
      "&-start": {
        transition: "none"
      },
      "&-active": {
        transition: `all ${motionDurationSlow}`
      }
    }
  };
  return {
    [componentCls]: {
      // ======================== Mask ========================
      [`${componentCls}-mask-motion`]: {
        "&-enter, &-appear, &-leave": {
          "&-active": {
            transition: `all ${motionDurationSlow}`
          }
        },
        "&-enter, &-appear": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        }
      },
      // ======================= Panel ========================
      [`${componentCls}-panel-motion`]: {
        // Left
        "&-left": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(-100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(-100%)"
            }
          }
        }],
        // Right
        "&-right": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(100%)"
            }
          }
        }],
        // Top
        "&-top": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(-100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(-100%)"
            }
          }
        }],
        // Bottom
        "&-bottom": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(100%)"
            }
          }
        }]
      }
    }
  };
};
var motion_default2 = genMotionStyle2;

// node_modules/ant-design-vue/es/drawer/style/index.js
var genDrawerStyle = (token) => {
  const {
    componentCls,
    zIndexPopup,
    colorBgMask,
    colorBgElevated,
    motionDurationSlow,
    motionDurationMid,
    padding,
    paddingLG,
    fontSizeLG,
    lineHeightLG,
    lineWidth,
    lineType,
    colorSplit,
    marginSM,
    colorIcon,
    colorIconHover,
    colorText,
    fontWeightStrong,
    drawerFooterPaddingVertical,
    drawerFooterPaddingHorizontal
  } = token;
  const wrapperCls = `${componentCls}-content-wrapper`;
  return {
    [componentCls]: {
      position: "fixed",
      inset: 0,
      zIndex: zIndexPopup,
      pointerEvents: "none",
      "&-pure": {
        position: "relative",
        background: colorBgElevated,
        [`&${componentCls}-left`]: {
          boxShadow: token.boxShadowDrawerLeft
        },
        [`&${componentCls}-right`]: {
          boxShadow: token.boxShadowDrawerRight
        },
        [`&${componentCls}-top`]: {
          boxShadow: token.boxShadowDrawerUp
        },
        [`&${componentCls}-bottom`]: {
          boxShadow: token.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      // ====================== Mask ======================
      [`${componentCls}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: zIndexPopup,
        background: colorBgMask,
        pointerEvents: "auto"
      },
      // ==================== Content =====================
      [wrapperCls]: {
        position: "absolute",
        zIndex: zIndexPopup,
        transition: `all ${motionDurationSlow}`,
        "&-hidden": {
          display: "none"
        }
      },
      // Placement
      [`&-left > ${wrapperCls}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: true,
          value: 0
        },
        boxShadow: token.boxShadowDrawerLeft
      },
      [`&-right > ${wrapperCls}`]: {
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        boxShadow: token.boxShadowDrawerRight
      },
      [`&-top > ${wrapperCls}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: token.boxShadowDrawerUp
      },
      [`&-bottom > ${wrapperCls}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: token.boxShadowDrawerDown
      },
      [`${componentCls}-content`]: {
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: colorBgElevated,
        pointerEvents: "auto"
      },
      // ===================== Panel ======================
      [`${componentCls}-wrapper-body`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%"
      },
      // Header
      [`${componentCls}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${padding}px ${paddingLG}px`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${componentCls}-extra`]: {
        flex: "none"
      },
      [`${componentCls}-close`]: {
        display: "inline-block",
        marginInlineEnd: marginSM,
        color: colorIcon,
        fontWeight: fontWeightStrong,
        fontSize: fontSizeLG,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        outline: 0,
        cursor: "pointer",
        transition: `color ${motionDurationMid}`,
        textRendering: "auto",
        "&:focus, &:hover": {
          color: colorIconHover,
          textDecoration: "none"
        }
      },
      [`${componentCls}-title`]: {
        flex: 1,
        margin: 0,
        color: colorText,
        fontWeight: token.fontWeightStrong,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG
      },
      // Body
      [`${componentCls}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: paddingLG,
        overflow: "auto"
      },
      // Footer
      [`${componentCls}-footer`]: {
        flexShrink: 0,
        padding: `${drawerFooterPaddingVertical}px ${drawerFooterPaddingHorizontal}px`,
        borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var style_default18 = genComponentStyleHook("Drawer", (token) => {
  const drawerToken = merge(token, {
    drawerFooterPaddingVertical: token.paddingXS,
    drawerFooterPaddingHorizontal: token.padding
  });
  return [genDrawerStyle(drawerToken), motion_default2(drawerToken)];
}, (token) => ({
  zIndexPopup: token.zIndexPopupBase
}));

// node_modules/ant-design-vue/es/drawer/index.js
var __rest13 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var PlacementTypes = ["top", "right", "bottom", "left"];
var defaultPushState = {
  distance: 180
};
var drawerProps2 = () => ({
  autofocus: {
    type: Boolean,
    default: void 0
  },
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: vue_types_default.any,
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  mask: {
    type: Boolean,
    default: void 0
  },
  maskStyle: objectType(),
  rootClassName: String,
  rootStyle: objectType(),
  size: {
    type: String
  },
  drawerStyle: objectType(),
  headerStyle: objectType(),
  bodyStyle: objectType(),
  contentWrapperStyle: {
    type: Object,
    default: void 0
  },
  title: vue_types_default.any,
  /** @deprecated Please use `open` instead */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  width: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number]),
  height: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number]),
  zIndex: Number,
  prefixCls: String,
  push: vue_types_default.oneOfType([vue_types_default.looseBool, {
    type: Object
  }]),
  placement: vue_types_default.oneOf(PlacementTypes),
  keyboard: {
    type: Boolean,
    default: void 0
  },
  extra: vue_types_default.any,
  footer: vue_types_default.any,
  footerStyle: objectType(),
  level: vue_types_default.any,
  levelMove: {
    type: [Number, Array, Function]
  },
  handle: vue_types_default.any,
  /** @deprecated Use `@afterVisibleChange` instead */
  afterVisibleChange: Function,
  /** @deprecated Please use `@afterOpenChange` instead */
  onAfterVisibleChange: Function,
  onAfterOpenChange: Function,
  /** @deprecated Please use `onUpdate:open` instead */
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onClose: Function
});
var Drawer = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADrawer",
  inheritAttrs: false,
  props: initDefaultProps_default(drawerProps2(), {
    closable: true,
    placement: "right",
    maskClosable: true,
    mask: true,
    level: null,
    keyboard: true,
    push: defaultPushState
  }),
  slots: Object,
  // emits: ['update:visible', 'close', 'afterVisibleChange'],
  setup(props2, _ref) {
    let {
      emit,
      slots,
      attrs
    } = _ref;
    const sPush = shallowRef(false);
    const destroyClose = shallowRef(false);
    const vcDrawer = shallowRef(null);
    const load = shallowRef(false);
    const visible = shallowRef(false);
    const mergedOpen = computed(() => {
      var _a2;
      return (_a2 = props2.open) !== null && _a2 !== void 0 ? _a2 : props2.visible;
    });
    watch(mergedOpen, () => {
      if (mergedOpen.value) {
        load.value = true;
      } else {
        visible.value = false;
      }
    }, {
      immediate: true
    });
    watch([mergedOpen, load], () => {
      if (mergedOpen.value && load.value) {
        visible.value = true;
      }
    }, {
      immediate: true
    });
    const parentDrawerOpts = inject("parentDrawerOpts", null);
    const {
      prefixCls,
      getPopupContainer,
      direction
    } = useConfigInject_default("drawer", props2);
    const [wrapSSR, hashId] = style_default18(prefixCls);
    const getContainer = computed(() => (
      // 有可能为 false，所以不能直接判断
      props2.getContainer === void 0 && (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value) ? () => getPopupContainer.value(document.body) : props2.getContainer
    ));
    devWarning_default(!props2.afterVisibleChange, "Drawer", "`afterVisibleChange` prop is deprecated, please use `@afterVisibleChange` event instead");
    if (true) {
      [["visible", "open"], ["onUpdate:visible", "onUpdate:open"], ["onAfterVisibleChange", "onAfterOpenChange"]].forEach((_ref2) => {
        let [deprecatedName, newName] = _ref2;
        devWarning_default(!props2[deprecatedName], "Drawer", `\`${deprecatedName}\` is deprecated, please use \`${newName}\` instead.`);
      });
    }
    const setPush = () => {
      sPush.value = true;
    };
    const setPull = () => {
      sPush.value = false;
      nextTick(() => {
        domFocus();
      });
    };
    provide("parentDrawerOpts", {
      setPush,
      setPull
    });
    onMounted(() => {
      if (mergedOpen.value && parentDrawerOpts) {
        parentDrawerOpts.setPush();
      }
    });
    onUnmounted(() => {
      if (parentDrawerOpts) {
        parentDrawerOpts.setPull();
      }
    });
    watch(visible, () => {
      if (parentDrawerOpts) {
        if (visible.value) {
          parentDrawerOpts.setPush();
        } else {
          parentDrawerOpts.setPull();
        }
      }
    }, {
      flush: "post"
    });
    const domFocus = () => {
      var _a2, _b;
      (_b = (_a2 = vcDrawer.value) === null || _a2 === void 0 ? void 0 : _a2.domFocus) === null || _b === void 0 ? void 0 : _b.call(_a2);
    };
    const close = (e) => {
      emit("update:visible", false);
      emit("update:open", false);
      emit("close", e);
    };
    const afterVisibleChange = (open2) => {
      var _a2;
      if (!open2) {
        if (destroyClose.value === false) {
          destroyClose.value = true;
        }
        if (props2.destroyOnClose) {
          load.value = false;
        }
      }
      (_a2 = props2.afterVisibleChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, open2);
      emit("afterVisibleChange", open2);
      emit("afterOpenChange", open2);
    };
    const pushTransform = computed(() => {
      const {
        push,
        placement
      } = props2;
      let distance;
      if (typeof push === "boolean") {
        distance = push ? defaultPushState.distance : 0;
      } else {
        distance = push.distance;
      }
      distance = parseFloat(String(distance || 0));
      if (placement === "left" || placement === "right") {
        return `translateX(${placement === "left" ? distance : -distance}px)`;
      }
      if (placement === "top" || placement === "bottom") {
        return `translateY(${placement === "top" ? distance : -distance}px)`;
      }
      return null;
    });
    const mergedWidth = computed(() => {
      var _a2;
      return (_a2 = props2.width) !== null && _a2 !== void 0 ? _a2 : props2.size === "large" ? 736 : 378;
    });
    const mergedHeight = computed(() => {
      var _a2;
      return (_a2 = props2.height) !== null && _a2 !== void 0 ? _a2 : props2.size === "large" ? 736 : 378;
    });
    const offsetStyle = computed(() => {
      const {
        mask,
        placement
      } = props2;
      if (!visible.value && !mask) {
        return {};
      }
      const val = {};
      if (placement === "left" || placement === "right") {
        val.width = isNumeric_default(mergedWidth.value) ? `${mergedWidth.value}px` : mergedWidth.value;
      } else {
        val.height = isNumeric_default(mergedHeight.value) ? `${mergedHeight.value}px` : mergedHeight.value;
      }
      return val;
    });
    const wrapperStyle2 = computed(() => {
      const {
        zIndex,
        contentWrapperStyle
      } = props2;
      const val = offsetStyle.value;
      return [{
        zIndex,
        transform: sPush.value ? pushTransform.value : void 0
      }, _extends({}, contentWrapperStyle), val];
    });
    const renderHeader = (prefixCls2) => {
      const {
        closable,
        headerStyle
      } = props2;
      const extra = getPropsSlot(slots, props2, "extra");
      const title = getPropsSlot(slots, props2, "title");
      if (!title && !closable) {
        return null;
      }
      return createVNode("div", {
        "class": classNames_default(`${prefixCls2}-header`, {
          [`${prefixCls2}-header-close-only`]: closable && !title && !extra
        }),
        "style": headerStyle
      }, [createVNode("div", {
        "class": `${prefixCls2}-header-title`
      }, [renderCloseIcon(prefixCls2), title && createVNode("div", {
        "class": `${prefixCls2}-title`
      }, [title])]), extra && createVNode("div", {
        "class": `${prefixCls2}-extra`
      }, [extra])]);
    };
    const renderCloseIcon = (prefixCls2) => {
      var _a2;
      const {
        closable
      } = props2;
      const $closeIcon = slots.closeIcon ? (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots) : props2.closeIcon;
      return closable && createVNode("button", {
        "key": "closer",
        "onClick": close,
        "aria-label": "Close",
        "class": `${prefixCls2}-close`
      }, [$closeIcon === void 0 ? createVNode(CloseOutlined_default, null, null) : $closeIcon]);
    };
    const renderBody = (prefixCls2) => {
      var _a2;
      if (destroyClose.value && !props2.forceRender && !load.value) {
        return null;
      }
      const {
        bodyStyle,
        drawerStyle
      } = props2;
      return createVNode("div", {
        "class": `${prefixCls2}-wrapper-body`,
        "style": drawerStyle
      }, [renderHeader(prefixCls2), createVNode("div", {
        "key": "body",
        "class": `${prefixCls2}-body`,
        "style": bodyStyle
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), renderFooter(prefixCls2)]);
    };
    const renderFooter = (prefixCls2) => {
      const footer = getPropsSlot(slots, props2, "footer");
      if (!footer) {
        return null;
      }
      const footerClassName = `${prefixCls2}-footer`;
      return createVNode("div", {
        "class": footerClassName,
        "style": props2.footerStyle
      }, [footer]);
    };
    const drawerClassName = computed(() => classNames_default({
      "no-mask": !props2.mask,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl"
    }, props2.rootClassName, hashId.value));
    const maskMotion = computed(() => {
      return getTransitionProps(getTransitionName(prefixCls.value, "mask-motion"));
    });
    const panelMotion = (motionPlacement) => {
      return getTransitionProps(getTransitionName(prefixCls.value, `panel-motion-${motionPlacement}`));
    };
    return () => {
      const {
        width,
        height,
        placement,
        mask,
        forceRender
      } = props2, rest = __rest13(props2, ["width", "height", "placement", "mask", "forceRender"]);
      const vcDrawerProps = _extends(_extends(_extends({}, attrs), omit_default(rest, ["size", "closeIcon", "closable", "destroyOnClose", "drawerStyle", "headerStyle", "bodyStyle", "title", "push", "onAfterVisibleChange", "onClose", "onUpdate:visible", "onUpdate:open", "visible"])), {
        forceRender,
        onClose: close,
        afterVisibleChange,
        handler: false,
        prefixCls: prefixCls.value,
        open: visible.value,
        showMask: mask,
        placement,
        ref: vcDrawer
      });
      return wrapSSR(createVNode(NoCompactStyle, null, {
        default: () => [createVNode(vc_drawer_default, _objectSpread2(_objectSpread2({}, vcDrawerProps), {}, {
          "maskMotion": maskMotion.value,
          "motion": panelMotion,
          "width": mergedWidth.value,
          "height": mergedHeight.value,
          "getContainer": getContainer.value,
          "rootClassName": drawerClassName.value,
          "rootStyle": props2.rootStyle,
          "contentWrapperStyle": wrapperStyle2.value
        }), {
          handler: props2.handle ? () => props2.handle : slots.handle,
          default: () => renderBody(prefixCls.value)
        })]
      }));
    };
  }
});
var drawer_default = withInstall(Drawer);

// node_modules/ant-design-vue/es/float-button/interface.js
var floatButtonProps = () => {
  return {
    prefixCls: String,
    description: vue_types_default.any,
    type: stringType("default"),
    shape: stringType("circle"),
    tooltip: vue_types_default.any,
    href: String,
    target: String,
    badge: objectType(),
    onClick: functionType()
  };
};
var floatButtonContentProps = () => {
  return {
    prefixCls: stringType()
  };
};
var floatButtonGroupProps = () => {
  return _extends(_extends({}, floatButtonProps()), {
    // 包含的 Float Button
    // 触发方式 (有触发方式为菜单模式）
    trigger: stringType(),
    // 受控展开
    open: booleanType(),
    // 展开收起的回调
    onOpenChange: functionType(),
    "onUpdate:open": functionType()
  });
};
var backTopProps = () => {
  return _extends(_extends({}, floatButtonProps()), {
    prefixCls: String,
    duration: Number,
    target: functionType(),
    visibilityHeight: Number,
    onClick: functionType()
  });
};

// node_modules/ant-design-vue/es/float-button/FloatButtonContent.js
var FloatButtonContent = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButtonContent",
  inheritAttrs: false,
  props: floatButtonContentProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    return () => {
      var _a2;
      const {
        prefixCls
      } = props2;
      const description = filterEmpty((_a2 = slots.description) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": [attrs.class, `${prefixCls}-content`]
      }), [slots.icon || description.length ? createVNode(Fragment, null, [slots.icon && createVNode("div", {
        "class": `${prefixCls}-icon`
      }, [slots.icon()]), description.length ? createVNode("div", {
        "class": `${prefixCls}-description`
      }, [description]) : null]) : createVNode("div", {
        "class": `${prefixCls}-icon`
      }, [createVNode(FileTextOutlined_default, null, null)])]);
    };
  }
});
var FloatButtonContent_default = FloatButtonContent;

// node_modules/ant-design-vue/es/float-button/context.js
var contextKey = Symbol("floatButtonGroupContext");
var useProvideFloatButtonGroupContext = (props2) => {
  provide(contextKey, props2);
  return props2;
};
var useInjectFloatButtonGroupContext = () => {
  return inject(contextKey, {
    shape: ref()
  });
};

// node_modules/ant-design-vue/es/float-button/util.js
var getOffset3 = (radius) => {
  if (radius === 0) {
    return 0;
  }
  return radius - Math.sqrt(Math.pow(radius, 2) / 2);
};
var util_default = getOffset3;

// node_modules/ant-design-vue/es/float-button/style/index.js
var initFloatButtonGroupMotion = (token) => {
  const {
    componentCls,
    floatButtonSize,
    motionDurationSlow,
    motionEaseInOutCirc
  } = token;
  const groupPrefixCls = `${componentCls}-group`;
  const moveDownIn = new Keyframes_default("antFloatButtonMoveDownIn", {
    "0%": {
      transform: `translate3d(0, ${floatButtonSize}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveDownOut = new Keyframes_default("antFloatButtonMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: `translate3d(0, ${floatButtonSize}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  return [{
    [`${groupPrefixCls}-wrap`]: _extends({}, initMotion(`${groupPrefixCls}-wrap`, moveDownIn, moveDownOut, motionDurationSlow, true))
  }, {
    [`${groupPrefixCls}-wrap`]: {
      [`
          &${groupPrefixCls}-wrap-enter,
          &${groupPrefixCls}-wrap-appear
        `]: {
        opacity: 0,
        animationTimingFunction: motionEaseInOutCirc
      },
      [`&${groupPrefixCls}-wrap-leave`]: {
        animationTimingFunction: motionEaseInOutCirc
      }
    }
  }];
};
var floatButtonGroupStyle = (token) => {
  const {
    antCls,
    componentCls,
    floatButtonSize,
    margin,
    borderRadiusLG,
    borderRadiusSM,
    badgeOffset,
    floatButtonBodyPadding
  } = token;
  const groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: _extends(_extends({}, resetComponent(token)), {
      zIndex: 99,
      display: "block",
      border: "none",
      position: "fixed",
      width: floatButtonSize,
      height: "auto",
      boxShadow: "none",
      minHeight: floatButtonSize,
      insetInlineEnd: token.floatButtonInsetInlineEnd,
      insetBlockEnd: token.floatButtonInsetBlockEnd,
      borderRadius: borderRadiusLG,
      [`${groupPrefixCls}-wrap`]: {
        zIndex: -1,
        display: "block",
        position: "relative",
        marginBottom: margin
      },
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [componentCls]: {
        position: "static"
      }
    }),
    [`${groupPrefixCls}-circle`]: {
      [`${componentCls}-circle:not(:last-child)`]: {
        marginBottom: token.margin,
        [`${componentCls}-body`]: {
          width: floatButtonSize,
          height: floatButtonSize,
          borderRadius: "50%"
        }
      }
    },
    [`${groupPrefixCls}-square`]: {
      [`${componentCls}-square`]: {
        borderRadius: 0,
        padding: 0,
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderStartEndRadius: borderRadiusLG
        },
        "&:last-child": {
          borderEndStartRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        },
        "&:not(:last-child)": {
          borderBottom: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`
        },
        [`${antCls}-badge`]: {
          [`${antCls}-badge-count`]: {
            top: -(floatButtonBodyPadding + badgeOffset),
            insetInlineEnd: -(floatButtonBodyPadding + badgeOffset)
          }
        }
      },
      [`${groupPrefixCls}-wrap`]: {
        display: "block",
        borderRadius: borderRadiusLG,
        boxShadow: token.boxShadowSecondary,
        [`${componentCls}-square`]: {
          boxShadow: "none",
          marginTop: 0,
          borderRadius: 0,
          padding: floatButtonBodyPadding,
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderStartEndRadius: borderRadiusLG
          },
          "&:last-child": {
            borderEndStartRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          },
          "&:not(:last-child)": {
            borderBottom: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`
          },
          [`${componentCls}-body`]: {
            width: token.floatButtonBodySize,
            height: token.floatButtonBodySize
          }
        }
      }
    },
    [`${groupPrefixCls}-circle-shadow`]: {
      boxShadow: "none"
    },
    [`${groupPrefixCls}-square-shadow`]: {
      boxShadow: token.boxShadowSecondary,
      [`${componentCls}-square`]: {
        boxShadow: "none",
        padding: floatButtonBodyPadding,
        [`${componentCls}-body`]: {
          width: token.floatButtonBodySize,
          height: token.floatButtonBodySize,
          borderRadius: borderRadiusSM
        }
      }
    }
  };
};
var sharedFloatButtonStyle = (token) => {
  const {
    antCls,
    componentCls,
    floatButtonBodyPadding,
    floatButtonIconSize,
    floatButtonSize,
    borderRadiusLG,
    badgeOffset,
    dotOffsetInSquare,
    dotOffsetInCircle
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      border: "none",
      position: "fixed",
      cursor: "pointer",
      zIndex: 99,
      display: "block",
      justifyContent: "center",
      alignItems: "center",
      width: floatButtonSize,
      height: floatButtonSize,
      insetInlineEnd: token.floatButtonInsetInlineEnd,
      insetBlockEnd: token.floatButtonInsetBlockEnd,
      boxShadow: token.boxShadowSecondary,
      // Pure Panel
      "&-pure": {
        position: "relative",
        inset: "auto"
      },
      "&:empty": {
        display: "none"
      },
      [`${antCls}-badge`]: {
        width: "100%",
        height: "100%",
        [`${antCls}-badge-count`]: {
          transform: "translate(0, 0)",
          transformOrigin: "center",
          top: -badgeOffset,
          insetInlineEnd: -badgeOffset
        }
      },
      [`${componentCls}-body`]: {
        width: "100%",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        transition: `all ${token.motionDurationMid}`,
        [`${componentCls}-content`]: {
          overflow: "hidden",
          textAlign: "center",
          minHeight: floatButtonSize,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          padding: `${floatButtonBodyPadding / 2}px ${floatButtonBodyPadding}px`,
          [`${componentCls}-icon`]: {
            textAlign: "center",
            margin: "auto",
            width: floatButtonIconSize,
            fontSize: floatButtonIconSize,
            lineHeight: 1
          }
        }
      }
    }),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-circle`]: {
      height: floatButtonSize,
      borderRadius: "50%",
      [`${antCls}-badge`]: {
        [`${antCls}-badge-dot`]: {
          top: dotOffsetInCircle,
          insetInlineEnd: dotOffsetInCircle
        }
      },
      [`${componentCls}-body`]: {
        borderRadius: "50%"
      }
    },
    [`${componentCls}-square`]: {
      height: "auto",
      minHeight: floatButtonSize,
      borderRadius: borderRadiusLG,
      [`${antCls}-badge`]: {
        [`${antCls}-badge-dot`]: {
          top: dotOffsetInSquare,
          insetInlineEnd: dotOffsetInSquare
        }
      },
      [`${componentCls}-body`]: {
        height: "auto",
        borderRadius: borderRadiusLG
      }
    },
    [`${componentCls}-default`]: {
      backgroundColor: token.floatButtonBackgroundColor,
      transition: `background-color ${token.motionDurationMid}`,
      [`${componentCls}-body`]: {
        backgroundColor: token.floatButtonBackgroundColor,
        transition: `background-color ${token.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token.colorFillContent
        },
        [`${componentCls}-content`]: {
          [`${componentCls}-icon`]: {
            color: token.colorText
          },
          [`${componentCls}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${token.fontSizeLG}px`,
            color: token.colorText,
            fontSize: token.fontSizeSM
          }
        }
      }
    },
    [`${componentCls}-primary`]: {
      backgroundColor: token.colorPrimary,
      [`${componentCls}-body`]: {
        backgroundColor: token.colorPrimary,
        transition: `background-color ${token.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token.colorPrimaryHover
        },
        [`${componentCls}-content`]: {
          [`${componentCls}-icon`]: {
            color: token.colorTextLightSolid
          },
          [`${componentCls}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${token.fontSizeLG}px`,
            color: token.colorTextLightSolid,
            fontSize: token.fontSizeSM
          }
        }
      }
    }
  };
};
var style_default19 = genComponentStyleHook("FloatButton", (token) => {
  const {
    colorTextLightSolid,
    colorBgElevated,
    controlHeightLG,
    marginXXL,
    marginLG,
    fontSize,
    fontSizeIcon,
    controlItemBgHover,
    paddingXXS,
    borderRadiusLG
  } = token;
  const floatButtonToken = merge(token, {
    floatButtonBackgroundColor: colorBgElevated,
    floatButtonColor: colorTextLightSolid,
    floatButtonHoverBackgroundColor: controlItemBgHover,
    floatButtonFontSize: fontSize,
    floatButtonIconSize: fontSizeIcon * 1.5,
    floatButtonSize: controlHeightLG,
    floatButtonInsetBlockEnd: marginXXL,
    floatButtonInsetInlineEnd: marginLG,
    floatButtonBodySize: controlHeightLG - paddingXXS * 2,
    // 这里的 paddingXXS 是简写，完整逻辑是 (controlHeightLG - (controlHeightLG - paddingXXS * 2)) / 2,
    floatButtonBodyPadding: paddingXXS,
    badgeOffset: paddingXXS * 1.5,
    dotOffsetInCircle: util_default(controlHeightLG / 2),
    dotOffsetInSquare: util_default(borderRadiusLG)
  });
  return [floatButtonGroupStyle(floatButtonToken), sharedFloatButtonStyle(floatButtonToken), initFadeMotion(token), initFloatButtonGroupMotion(floatButtonToken)];
});

// node_modules/ant-design-vue/es/float-button/FloatButton.js
var __rest14 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var floatButtonPrefixCls = "float-btn";
var FloatButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButton",
  inheritAttrs: false,
  props: initDefaultProps_default(floatButtonProps(), {
    type: "default",
    shape: "circle"
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default(floatButtonPrefixCls, props2);
    const [wrapSSR, hashId] = style_default19(prefixCls);
    const {
      shape: groupShape
    } = useInjectFloatButtonGroupContext();
    const floatButtonRef = ref(null);
    const mergeShape = computed(() => {
      return (groupShape === null || groupShape === void 0 ? void 0 : groupShape.value) || props2.shape;
    });
    return () => {
      var _a2;
      const {
        prefixCls: customPrefixCls,
        type = "default",
        shape = "circle",
        description = (_a2 = slots.description) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        tooltip,
        badge = {}
      } = props2, restProps = __rest14(props2, ["prefixCls", "type", "shape", "description", "tooltip", "badge"]);
      const classString = classNames_default(prefixCls.value, `${prefixCls.value}-${type}`, `${prefixCls.value}-${mergeShape.value}`, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value);
      const buttonNode = createVNode(tooltip_default, {
        "placement": "left"
      }, {
        title: slots.tooltip || tooltip ? () => slots.tooltip && slots.tooltip() || tooltip : void 0,
        default: () => createVNode(badge_default, badge, {
          default: () => [createVNode("div", {
            "class": `${prefixCls.value}-body`
          }, [createVNode(FloatButtonContent_default, {
            "prefixCls": prefixCls.value
          }, {
            icon: slots.icon,
            description: () => description
          })])]
        })
      });
      if (true) {
        warning_default2(!(shape === "circle" && description), "FloatButton", "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended.");
      }
      return wrapSSR(props2.href ? createVNode("a", _objectSpread2(_objectSpread2(_objectSpread2({
        "ref": floatButtonRef
      }, attrs), restProps), {}, {
        "class": classString
      }), [buttonNode]) : createVNode("button", _objectSpread2(_objectSpread2(_objectSpread2({
        "ref": floatButtonRef
      }, attrs), restProps), {}, {
        "class": classString,
        "type": "button"
      }), [buttonNode]));
    };
  }
});
var FloatButton_default = FloatButton;

// node_modules/ant-design-vue/es/float-button/FloatButtonGroup.js
var FloatButtonGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButtonGroup",
  inheritAttrs: false,
  props: initDefaultProps_default(floatButtonGroupProps(), {
    type: "default",
    shape: "circle"
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default(floatButtonPrefixCls, props2);
    const [wrapSSR, hashId] = style_default19(prefixCls);
    const [open2, setOpen] = useMergedState(false, {
      value: computed(() => props2.open)
    });
    const floatButtonGroupRef = ref(null);
    const floatButtonRef = ref(null);
    useProvideFloatButtonGroupContext({
      shape: computed(() => props2.shape)
    });
    const hoverTypeAction = {
      onMouseenter() {
        var _a2;
        setOpen(true);
        emit("update:open", true);
        (_a2 = props2.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, true);
      },
      onMouseleave() {
        var _a2;
        setOpen(false);
        emit("update:open", false);
        (_a2 = props2.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, false);
      }
    };
    const hoverAction = computed(() => {
      return props2.trigger === "hover" ? hoverTypeAction : {};
    });
    const handleOpenChange = () => {
      var _a2;
      const nextOpen = !open2.value;
      emit("update:open", nextOpen);
      (_a2 = props2.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, nextOpen);
      setOpen(nextOpen);
    };
    const onClick = (e) => {
      var _a2, _b, _c;
      if ((_a2 = floatButtonGroupRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(e.target)) {
        if ((_b = findDOMNode(floatButtonRef.value)) === null || _b === void 0 ? void 0 : _b.contains(e.target)) {
          handleOpenChange();
        }
        return;
      }
      setOpen(false);
      emit("update:open", false);
      (_c = props2.onOpenChange) === null || _c === void 0 ? void 0 : _c.call(props2, false);
    };
    watch(computed(() => props2.trigger), (value) => {
      if (!canUseDom_default()) {
        return;
      }
      document.removeEventListener("click", onClick);
      if (value === "click") {
        document.addEventListener("click", onClick);
      }
    }, {
      immediate: true
    });
    onBeforeUnmount(() => {
      document.removeEventListener("click", onClick);
    });
    return () => {
      var _a2;
      const {
        shape = "circle",
        type = "default",
        tooltip,
        description,
        trigger
      } = props2;
      const groupPrefixCls = `${prefixCls.value}-group`;
      const groupCls = classNames_default(groupPrefixCls, hashId.value, attrs.class, {
        [`${groupPrefixCls}-rtl`]: direction.value === "rtl",
        [`${groupPrefixCls}-${shape}`]: shape,
        [`${groupPrefixCls}-${shape}-shadow`]: !trigger
      });
      const wrapperCls = classNames_default(hashId.value, `${groupPrefixCls}-wrap`);
      const transitionProps = getTransitionProps(`${groupPrefixCls}-wrap`);
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({
        "ref": floatButtonGroupRef
      }, attrs), {}, {
        "class": groupCls
      }, hoverAction.value), [trigger && ["click", "hover"].includes(trigger) ? createVNode(Fragment, null, [createVNode(Transition, transitionProps, {
        default: () => [withDirectives(createVNode("div", {
          "class": wrapperCls
        }, [slots.default && slots.default()]), [[vShow, open2.value]])]
      }), createVNode(FloatButton_default, {
        "ref": floatButtonRef,
        "type": type,
        "shape": shape,
        "tooltip": tooltip,
        "description": description
      }, {
        icon: () => {
          var _a3, _b;
          return open2.value ? ((_a3 = slots.closeIcon) === null || _a3 === void 0 ? void 0 : _a3.call(slots)) || createVNode(CloseOutlined_default, null, null) : ((_b = slots.icon) === null || _b === void 0 ? void 0 : _b.call(slots)) || createVNode(FileTextOutlined_default, null, null);
        },
        tooltip: slots.tooltip,
        description: slots.description
      })]) : (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
var FloatButtonGroup_default = FloatButtonGroup;

// node_modules/ant-design-vue/es/float-button/BackTop.js
var BackTop = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABackTop",
  inheritAttrs: false,
  props: initDefaultProps_default(backTopProps(), {
    visibilityHeight: 400,
    target: () => window,
    duration: 450,
    type: "default",
    shape: "circle"
  }),
  // emits: ['click'],
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default(floatButtonPrefixCls, props2);
    const [wrapSSR] = style_default19(prefixCls);
    const domRef = ref();
    const state = reactive({
      visible: props2.visibilityHeight === 0,
      scrollEvent: null
    });
    const getDefaultTarget2 = () => domRef.value && domRef.value.ownerDocument ? domRef.value.ownerDocument : window;
    const scrollToTop = (e) => {
      const {
        target = getDefaultTarget2,
        duration
      } = props2;
      scrollTo(0, {
        getContainer: target,
        duration
      });
      emit("click", e);
    };
    const handleScroll = throttleByAnimationFrame_default((e) => {
      const {
        visibilityHeight
      } = props2;
      const scrollTop = getScroll(e.target, true);
      state.visible = scrollTop >= visibilityHeight;
    });
    const bindScrollEvent = () => {
      const {
        target
      } = props2;
      const getTarget = target || getDefaultTarget2;
      const container = getTarget();
      handleScroll({
        target: container
      });
      container === null || container === void 0 ? void 0 : container.addEventListener("scroll", handleScroll);
    };
    const scrollRemove = () => {
      const {
        target
      } = props2;
      const getTarget = target || getDefaultTarget2;
      const container = getTarget();
      handleScroll.cancel();
      container === null || container === void 0 ? void 0 : container.removeEventListener("scroll", handleScroll);
    };
    watch(() => props2.target, () => {
      scrollRemove();
      nextTick(() => {
        bindScrollEvent();
      });
    });
    onMounted(() => {
      nextTick(() => {
        bindScrollEvent();
      });
    });
    onActivated(() => {
      nextTick(() => {
        bindScrollEvent();
      });
    });
    onDeactivated(() => {
      scrollRemove();
    });
    onBeforeUnmount(() => {
      scrollRemove();
    });
    const floatButtonGroupContext = useInjectFloatButtonGroupContext();
    return () => {
      const {
        description,
        type,
        shape,
        tooltip,
        badge
      } = props2;
      const floatButtonProps2 = _extends(_extends({}, attrs), {
        shape: (floatButtonGroupContext === null || floatButtonGroupContext === void 0 ? void 0 : floatButtonGroupContext.shape.value) || shape,
        onClick: scrollToTop,
        class: {
          [`${prefixCls.value}`]: true,
          [`${attrs.class}`]: attrs.class,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        },
        description,
        type,
        tooltip,
        badge
      });
      const transitionProps = getTransitionProps("fade");
      return wrapSSR(createVNode(Transition, transitionProps, {
        default: () => [withDirectives(createVNode(FloatButton_default, _objectSpread2(_objectSpread2({}, floatButtonProps2), {}, {
          "ref": domRef
        }), {
          icon: () => {
            var _a2;
            return ((_a2 = slots.icon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || createVNode(VerticalAlignTopOutlined_default, null, null);
          }
        }), [[vShow, state.visible]])]
      }));
    };
  }
});
var BackTop_default = BackTop;

// node_modules/ant-design-vue/es/float-button/index.js
FloatButton_default.Group = FloatButtonGroup_default;
FloatButton_default.BackTop = BackTop_default;
FloatButton_default.install = function(app) {
  app.component(FloatButton_default.name, FloatButton_default);
  app.component(FloatButtonGroup_default.name, FloatButtonGroup_default);
  app.component(BackTop_default.name, BackTop_default);
  return app;
};
var float_button_default = FloatButton_default;

// node_modules/ant-design-vue/es/vc-image/src/hooks/useFrameSetState.js
function useFrameSetState(initial) {
  const frame = ref(null);
  const state = reactive(_extends({}, initial));
  const queue = ref([]);
  const setFrameState = (newState) => {
    if (frame.value === null) {
      queue.value = [];
      frame.value = wrapperRaf(() => {
        let memoState;
        queue.value.forEach((queueState) => {
          memoState = _extends(_extends({}, memoState), queueState);
        });
        _extends(state, memoState);
        frame.value = null;
      });
    }
    queue.value.push(newState);
  };
  onMounted(() => {
    frame.value && wrapperRaf.cancel(frame.value);
  });
  return [state, setFrameState];
}

// node_modules/ant-design-vue/es/vc-image/src/getFixScaleEleTransPosition.js
function fixPoint(key, start, width, clientWidth) {
  const startAddWidth = start + width;
  const offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return {
        [key]: offsetStart
      };
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return {
        [key]: -offsetStart
      };
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return {
      [key]: start < 0 ? offsetStart : -offsetStart
    };
  }
  return {};
}
function getFixScaleEleTransPosition(width, height, left, top) {
  const {
    width: clientWidth,
    height: clientHeight
  } = getClientSize();
  let fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = _extends(_extends({}, fixPoint("x", left, width, clientWidth)), fixPoint("y", top, height, clientHeight));
  }
  return fixPos;
}

// node_modules/ant-design-vue/es/vc-image/src/PreviewGroup.js
var __rest15 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var previewGroupContext = Symbol("previewGroupContext");
var context = {
  provide: (val) => {
    provide(previewGroupContext, val);
  },
  inject: () => {
    return inject(previewGroupContext, {
      isPreviewGroup: shallowRef(false),
      previewUrls: computed(() => /* @__PURE__ */ new Map()),
      setPreviewUrls: () => {
      },
      current: ref(null),
      setCurrent: () => {
      },
      setShowPreview: () => {
      },
      setMousePosition: () => {
      },
      registerImage: null,
      rootClassName: ""
    });
  }
};
var imageGroupProps = () => ({
  previewPrefixCls: String,
  preview: {
    type: [Boolean, Object],
    default: true
  },
  icons: {
    type: Object,
    default: () => ({})
  }
});
var Group2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PreviewGroup",
  inheritAttrs: false,
  props: imageGroupProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const preview = computed(() => {
      const defaultValues = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0,
        current: 0
      };
      return typeof props2.preview === "object" ? mergeDefaultValue(props2.preview, defaultValues) : defaultValues;
    });
    const previewUrls = reactive(/* @__PURE__ */ new Map());
    const current = ref();
    const previewVisible = computed(() => preview.value.visible);
    const getPreviewContainer = computed(() => preview.value.getContainer);
    const onPreviewVisibleChange = (val, preval) => {
      var _a2, _b;
      (_b = (_a2 = preview.value).onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(_a2, val, preval);
    };
    const [isShowPreview, setShowPreview] = useMergedState(!!previewVisible.value, {
      value: previewVisible,
      onChange: onPreviewVisibleChange
    });
    const mousePosition = ref(null);
    const isControlled = computed(() => previewVisible.value !== void 0);
    const previewUrlsKeys = computed(() => Array.from(previewUrls.keys()));
    const currentControlledKey = computed(() => previewUrlsKeys.value[preview.value.current]);
    const canPreviewUrls = computed(() => new Map(Array.from(previewUrls).filter((_ref2) => {
      let [, {
        canPreview
      }] = _ref2;
      return !!canPreview;
    }).map((_ref3) => {
      let [id, {
        url
      }] = _ref3;
      return [id, url];
    })));
    const setPreviewUrls = function(id, url) {
      let canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      previewUrls.set(id, {
        url,
        canPreview
      });
    };
    const setCurrent = (val) => {
      current.value = val;
    };
    const setMousePosition = (val) => {
      mousePosition.value = val;
    };
    const registerImage = function(id, url) {
      let canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      const unRegister = () => {
        previewUrls.delete(id);
      };
      previewUrls.set(id, {
        url,
        canPreview
      });
      return unRegister;
    };
    const onPreviewClose = (e) => {
      e === null || e === void 0 ? void 0 : e.stopPropagation();
      setShowPreview(false);
      setMousePosition(null);
    };
    watch(currentControlledKey, (val) => {
      setCurrent(val);
    }, {
      immediate: true,
      flush: "post"
    });
    watchEffect(() => {
      if (isShowPreview.value && isControlled.value) {
        setCurrent(currentControlledKey.value);
      }
    }, {
      flush: "post"
    });
    context.provide({
      isPreviewGroup: shallowRef(true),
      previewUrls: canPreviewUrls,
      setPreviewUrls,
      current,
      setCurrent,
      setShowPreview,
      setMousePosition,
      registerImage
    });
    return () => {
      const dialogProps = __rest15(preview.value, []);
      return createVNode(Fragment, null, [slots.default && slots.default(), createVNode(Preview_default, _objectSpread2(_objectSpread2({}, dialogProps), {}, {
        "ria-hidden": !isShowPreview.value,
        "visible": isShowPreview.value,
        "prefixCls": props2.previewPrefixCls,
        "onClose": onPreviewClose,
        "mousePosition": mousePosition.value,
        "src": canPreviewUrls.value.get(current.value),
        "icons": props2.icons,
        "getContainer": getPreviewContainer.value
      }), null)]);
    };
  }
});
var PreviewGroup_default = Group2;

// node_modules/ant-design-vue/es/vc-image/src/Preview.js
var initialPosition = {
  x: 0,
  y: 0
};
var previewProps = _extends(_extends({}, dialogPropTypes()), {
  src: String,
  alt: String,
  rootClassName: String,
  icons: {
    type: Object,
    default: () => ({})
  }
});
var Preview = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Preview",
  inheritAttrs: false,
  props: previewProps,
  emits: ["close", "afterClose"],
  setup(props2, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    const {
      rotateLeft,
      rotateRight,
      zoomIn,
      zoomOut,
      close,
      left,
      right,
      flipX,
      flipY
    } = reactive(props2.icons);
    const scale = shallowRef(1);
    const rotate = shallowRef(0);
    const flip = reactive({
      x: 1,
      y: 1
    });
    const [position, setPosition] = useFrameSetState(initialPosition);
    const onClose = () => emit("close");
    const imgRef = shallowRef();
    const originPositionRef = reactive({
      originX: 0,
      originY: 0,
      deltaX: 0,
      deltaY: 0
    });
    const isMoving = shallowRef(false);
    const groupContext = context.inject();
    const {
      previewUrls,
      current,
      isPreviewGroup,
      setCurrent
    } = groupContext;
    const previewGroupCount = computed(() => previewUrls.value.size);
    const previewUrlsKeys = computed(() => Array.from(previewUrls.value.keys()));
    const currentPreviewIndex = computed(() => previewUrlsKeys.value.indexOf(current.value));
    const combinationSrc = computed(() => {
      return isPreviewGroup.value ? previewUrls.value.get(current.value) : props2.src;
    });
    const showLeftOrRightSwitches = computed(() => isPreviewGroup.value && previewGroupCount.value > 1);
    const lastWheelZoomDirection = shallowRef({
      wheelDirection: 0
    });
    const onAfterClose = () => {
      scale.value = 1;
      rotate.value = 0;
      flip.x = 1;
      flip.y = 1;
      setPosition(initialPosition);
      emit("afterClose");
    };
    const onZoomIn = (isWheel) => {
      if (!isWheel) {
        scale.value++;
      } else {
        scale.value += 0.5;
      }
      setPosition(initialPosition);
    };
    const onZoomOut = (isWheel) => {
      if (scale.value > 1) {
        if (!isWheel) {
          scale.value--;
        } else {
          scale.value -= 0.5;
        }
      }
      setPosition(initialPosition);
    };
    const onRotateRight = () => {
      rotate.value += 90;
    };
    const onRotateLeft = () => {
      rotate.value -= 90;
    };
    const onFlipX = () => {
      flip.x = -flip.x;
    };
    const onFlipY = () => {
      flip.y = -flip.y;
    };
    const onSwitchLeft = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (currentPreviewIndex.value > 0) {
        setCurrent(previewUrlsKeys.value[currentPreviewIndex.value - 1]);
      }
    };
    const onSwitchRight = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (currentPreviewIndex.value < previewGroupCount.value - 1) {
        setCurrent(previewUrlsKeys.value[currentPreviewIndex.value + 1]);
      }
    };
    const wrapClassName = classNames_default({
      [`${props2.prefixCls}-moving`]: isMoving.value
    });
    const toolClassName = `${props2.prefixCls}-operations-operation`;
    const iconClassName = `${props2.prefixCls}-operations-icon`;
    const tools = [{
      icon: close,
      onClick: onClose,
      type: "close"
    }, {
      icon: zoomIn,
      onClick: () => onZoomIn(),
      type: "zoomIn"
    }, {
      icon: zoomOut,
      onClick: () => onZoomOut(),
      type: "zoomOut",
      disabled: computed(() => scale.value === 1)
    }, {
      icon: rotateRight,
      onClick: onRotateRight,
      type: "rotateRight"
    }, {
      icon: rotateLeft,
      onClick: onRotateLeft,
      type: "rotateLeft"
    }, {
      icon: flipX,
      onClick: onFlipX,
      type: "flipX"
    }, {
      icon: flipY,
      onClick: onFlipY,
      type: "flipY"
    }];
    const onMouseUp = () => {
      if (props2.visible && isMoving.value) {
        const width = imgRef.value.offsetWidth * scale.value;
        const height = imgRef.value.offsetHeight * scale.value;
        const {
          left: left2,
          top
        } = getOffset(imgRef.value);
        const isRotate = rotate.value % 180 !== 0;
        isMoving.value = false;
        const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left2, top);
        if (fixState) {
          setPosition(_extends({}, fixState));
        }
      }
    };
    const onMouseDown = (event) => {
      if (event.button !== 0)
        return;
      event.preventDefault();
      event.stopPropagation();
      originPositionRef.deltaX = event.pageX - position.x;
      originPositionRef.deltaY = event.pageY - position.y;
      originPositionRef.originX = position.x;
      originPositionRef.originY = position.y;
      isMoving.value = true;
    };
    const onMouseMove = (event) => {
      if (props2.visible && isMoving.value) {
        setPosition({
          x: event.pageX - originPositionRef.deltaX,
          y: event.pageY - originPositionRef.deltaY
        });
      }
    };
    const onWheelMove = (event) => {
      if (!props2.visible)
        return;
      event.preventDefault();
      const wheelDirection = event.deltaY;
      lastWheelZoomDirection.value = {
        wheelDirection
      };
    };
    const onKeyDown = (event) => {
      if (!props2.visible || !showLeftOrRightSwitches.value)
        return;
      event.preventDefault();
      if (event.keyCode === KeyCode_default.LEFT) {
        if (currentPreviewIndex.value > 0) {
          setCurrent(previewUrlsKeys.value[currentPreviewIndex.value - 1]);
        }
      } else if (event.keyCode === KeyCode_default.RIGHT) {
        if (currentPreviewIndex.value < previewGroupCount.value - 1) {
          setCurrent(previewUrlsKeys.value[currentPreviewIndex.value + 1]);
        }
      }
    };
    const onDoubleClick = () => {
      if (props2.visible) {
        if (scale.value !== 1) {
          scale.value = 1;
        }
        if (position.x !== initialPosition.x || position.y !== initialPosition.y) {
          setPosition(initialPosition);
        }
      }
    };
    let removeListeners = () => {
    };
    onMounted(() => {
      watch([() => props2.visible, isMoving], () => {
        removeListeners();
        let onTopMouseUpListener;
        let onTopMouseMoveListener;
        const onMouseUpListener = addEventListenerWrap(window, "mouseup", onMouseUp, false);
        const onMouseMoveListener = addEventListenerWrap(window, "mousemove", onMouseMove, false);
        const onScrollWheelListener = addEventListenerWrap(window, "wheel", onWheelMove, {
          passive: false
        });
        const onKeyDownListener = addEventListenerWrap(window, "keydown", onKeyDown, false);
        try {
          if (window.top !== window.self) {
            onTopMouseUpListener = addEventListenerWrap(window.top, "mouseup", onMouseUp, false);
            onTopMouseMoveListener = addEventListenerWrap(window.top, "mousemove", onMouseMove, false);
          }
        } catch (error) {
          warning(false, `[vc-image] ${error}`);
        }
        removeListeners = () => {
          onMouseUpListener.remove();
          onMouseMoveListener.remove();
          onScrollWheelListener.remove();
          onKeyDownListener.remove();
          if (onTopMouseUpListener)
            onTopMouseUpListener.remove();
          if (onTopMouseMoveListener)
            onTopMouseMoveListener.remove();
        };
      }, {
        flush: "post",
        immediate: true
      });
      watch([lastWheelZoomDirection], () => {
        const {
          wheelDirection
        } = lastWheelZoomDirection.value;
        if (wheelDirection > 0) {
          onZoomOut(true);
        } else if (wheelDirection < 0) {
          onZoomIn(true);
        }
      });
    });
    onUnmounted(() => {
      removeListeners();
    });
    return () => {
      const {
        visible,
        prefixCls,
        rootClassName
      } = props2;
      return createVNode(vc_dialog_default, _objectSpread2(_objectSpread2({}, attrs), {}, {
        "transitionName": props2.transitionName,
        "maskTransitionName": props2.maskTransitionName,
        "closable": false,
        "keyboard": true,
        "prefixCls": prefixCls,
        "onClose": onClose,
        "afterClose": onAfterClose,
        "visible": visible,
        "wrapClassName": wrapClassName,
        "rootClassName": rootClassName,
        "getContainer": props2.getContainer
      }), {
        default: () => [createVNode("div", {
          "class": [`${props2.prefixCls}-operations-wrapper`, rootClassName]
        }, [createVNode("ul", {
          "class": `${props2.prefixCls}-operations`
        }, [tools.map((_ref2) => {
          let {
            icon: IconType,
            onClick,
            type,
            disabled
          } = _ref2;
          return createVNode("li", {
            "class": classNames_default(toolClassName, {
              [`${props2.prefixCls}-operations-operation-disabled`]: disabled && (disabled === null || disabled === void 0 ? void 0 : disabled.value)
            }),
            "onClick": onClick,
            "key": type
          }, [cloneVNode(IconType, {
            class: iconClassName
          })]);
        })])]), createVNode("div", {
          "class": `${props2.prefixCls}-img-wrapper`,
          "style": {
            transform: `translate3d(${position.x}px, ${position.y}px, 0)`
          }
        }, [createVNode("img", {
          "onMousedown": onMouseDown,
          "onDblclick": onDoubleClick,
          "ref": imgRef,
          "class": `${props2.prefixCls}-img`,
          "src": combinationSrc.value,
          "alt": props2.alt,
          "style": {
            transform: `scale3d(${flip.x * scale.value}, ${flip.y * scale.value}, 1) rotate(${rotate.value}deg)`
          }
        }, null)]), showLeftOrRightSwitches.value && createVNode("div", {
          "class": classNames_default(`${props2.prefixCls}-switch-left`, {
            [`${props2.prefixCls}-switch-left-disabled`]: currentPreviewIndex.value <= 0
          }),
          "onClick": onSwitchLeft
        }, [left]), showLeftOrRightSwitches.value && createVNode("div", {
          "class": classNames_default(`${props2.prefixCls}-switch-right`, {
            [`${props2.prefixCls}-switch-right-disabled`]: currentPreviewIndex.value >= previewGroupCount.value - 1
          }),
          "onClick": onSwitchRight
        }, [right])]
      });
    };
  }
});
var Preview_default = Preview;

// node_modules/ant-design-vue/es/vc-image/src/Image.js
var __rest16 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var imageProps = () => ({
  src: String,
  wrapperClassName: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  rootClassName: String,
  prefixCls: String,
  previewPrefixCls: String,
  width: [Number, String],
  height: [Number, String],
  previewMask: {
    type: [Boolean, Function],
    default: void 0
  },
  placeholder: vue_types_default.any,
  fallback: String,
  preview: {
    type: [Boolean, Object],
    default: true
  },
  onClick: {
    type: Function
  },
  onError: {
    type: Function
  }
});
var mergeDefaultValue = (obj, defaultValues) => {
  const res = _extends({}, obj);
  Object.keys(defaultValues).forEach((key) => {
    if (obj[key] === void 0) {
      res[key] = defaultValues[key];
    }
  });
  return res;
};
var uuid2 = 0;
var ImageInternal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "VcImage",
  inheritAttrs: false,
  props: imageProps(),
  emits: ["click", "error"],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const prefixCls = computed(() => props2.prefixCls);
    const previewPrefixCls = computed(() => `${prefixCls.value}-preview`);
    const preview = computed(() => {
      const defaultValues = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0
      };
      return typeof props2.preview === "object" ? mergeDefaultValue(props2.preview, defaultValues) : defaultValues;
    });
    const src = computed(() => {
      var _a2;
      return (_a2 = preview.value.src) !== null && _a2 !== void 0 ? _a2 : props2.src;
    });
    const isCustomPlaceholder = computed(() => props2.placeholder && props2.placeholder !== true || slots.placeholder);
    const previewVisible = computed(() => preview.value.visible);
    const getPreviewContainer = computed(() => preview.value.getContainer);
    const isControlled = computed(() => previewVisible.value !== void 0);
    const onPreviewVisibleChange = (val, preval) => {
      var _a2, _b;
      (_b = (_a2 = preview.value).onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(_a2, val, preval);
    };
    const [isShowPreview, setShowPreview] = useMergedState(!!previewVisible.value, {
      value: previewVisible,
      onChange: onPreviewVisibleChange
    });
    const status = ref(isCustomPlaceholder.value ? "loading" : "normal");
    watch(() => props2.src, () => {
      status.value = isCustomPlaceholder.value ? "loading" : "normal";
    });
    const mousePosition = ref(null);
    const isError = computed(() => status.value === "error");
    const groupContext = context.inject();
    const {
      isPreviewGroup,
      setCurrent,
      setShowPreview: setGroupShowPreview,
      setMousePosition: setGroupMousePosition,
      registerImage
    } = groupContext;
    const currentId = ref(uuid2++);
    const canPreview = computed(() => props2.preview && !isError.value);
    const onLoad = () => {
      status.value = "normal";
    };
    const onError = (e) => {
      status.value = "error";
      emit("error", e);
    };
    const onPreview = (e) => {
      if (!isControlled.value) {
        const {
          left,
          top
        } = getOffset(e.target);
        if (isPreviewGroup.value) {
          setCurrent(currentId.value);
          setGroupMousePosition({
            x: left,
            y: top
          });
        } else {
          mousePosition.value = {
            x: left,
            y: top
          };
        }
      }
      if (isPreviewGroup.value) {
        setGroupShowPreview(true);
      } else {
        setShowPreview(true);
      }
      emit("click", e);
    };
    const onPreviewClose = () => {
      setShowPreview(false);
      if (!isControlled.value) {
        mousePosition.value = null;
      }
    };
    const img = ref(null);
    watch(() => img, () => {
      if (status.value !== "loading")
        return;
      if (img.value.complete && (img.value.naturalWidth || img.value.naturalHeight)) {
        onLoad();
      }
    });
    let unRegister = () => {
    };
    onMounted(() => {
      watch([src, canPreview], () => {
        unRegister();
        if (!isPreviewGroup.value) {
          return () => {
          };
        }
        unRegister = registerImage(currentId.value, src.value, canPreview.value);
        if (!canPreview.value) {
          unRegister();
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    onUnmounted(() => {
      unRegister();
    });
    const toSizePx = (l) => {
      if (isNumber_default(l))
        return l + "px";
      return l;
    };
    return () => {
      const {
        prefixCls: prefixCls2,
        wrapperClassName,
        fallback,
        src: imgSrc,
        placeholder,
        wrapperStyle: wrapperStyle2,
        rootClassName,
        width,
        height,
        crossorigin,
        decoding,
        alt,
        sizes,
        srcset,
        usemap,
        class: cls,
        style
      } = _extends(_extends({}, props2), attrs);
      const _a2 = preview.value, {
        icons: icons2,
        maskClassName
      } = _a2, dialogProps = __rest16(_a2, ["icons", "maskClassName"]);
      const wrappperClass = classNames_default(prefixCls2, wrapperClassName, rootClassName, {
        [`${prefixCls2}-error`]: isError.value
      });
      const mergedSrc = isError.value && fallback ? fallback : src.value;
      const imgCommonProps = {
        crossorigin,
        decoding,
        alt,
        sizes,
        srcset,
        usemap,
        width,
        height,
        class: classNames_default(`${prefixCls2}-img`, {
          [`${prefixCls2}-img-placeholder`]: placeholder === true
        }, cls),
        style: _extends({
          height: toSizePx(height)
        }, style)
      };
      return createVNode(Fragment, null, [createVNode("div", {
        "class": wrappperClass,
        "onClick": canPreview.value ? onPreview : (e) => {
          emit("click", e);
        },
        "style": _extends({
          width: toSizePx(width),
          height: toSizePx(height)
        }, wrapperStyle2)
      }, [createVNode("img", _objectSpread2(_objectSpread2(_objectSpread2({}, imgCommonProps), isError.value && fallback ? {
        src: fallback
      } : {
        onLoad,
        onError,
        src: imgSrc
      }), {}, {
        "ref": img
      }), null), status.value === "loading" && createVNode("div", {
        "aria-hidden": "true",
        "class": `${prefixCls2}-placeholder`
      }, [placeholder || slots.placeholder && slots.placeholder()]), slots.previewMask && canPreview.value && createVNode("div", {
        "class": [`${prefixCls2}-mask`, maskClassName]
      }, [slots.previewMask()])]), !isPreviewGroup.value && canPreview.value && createVNode(Preview_default, _objectSpread2(_objectSpread2({}, dialogProps), {}, {
        "aria-hidden": !isShowPreview.value,
        "visible": isShowPreview.value,
        "prefixCls": previewPrefixCls.value,
        "onClose": onPreviewClose,
        "mousePosition": mousePosition.value,
        "src": mergedSrc,
        "alt": alt,
        "getContainer": getPreviewContainer.value,
        "icons": icons2,
        "rootClassName": rootClassName
      }), null)]);
    };
  }
});
ImageInternal.PreviewGroup = PreviewGroup_default;
var Image_default2 = ImageInternal;

// node_modules/ant-design-vue/es/vc-image/index.js
var vc_image_default = Image_default2;

// node_modules/ant-design-vue/es/image/style/index.js
var genBoxStyle = (position) => ({
  position: position || "absolute",
  inset: 0
});
var genImageMaskStyle = (token) => {
  const {
    iconCls,
    motionDurationSlow,
    paddingXXS,
    marginXXS,
    prefixCls
  } = token;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    background: new TinyColor("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${motionDurationSlow}`,
    [`.${prefixCls}-mask-info`]: _extends(_extends({}, textEllipsis), {
      padding: `0 ${paddingXXS}px`,
      [iconCls]: {
        marginInlineEnd: marginXXS,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
};
var genPreviewOperationsStyle = (token) => {
  const {
    previewCls,
    modalMaskBg,
    paddingSM,
    previewOperationColorDisabled,
    motionDurationSlow
  } = token;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-operations`]: _extends(_extends({}, resetComponent(token)), {
      display: "flex",
      flexDirection: "row-reverse",
      alignItems: "center",
      color: token.previewOperationColor,
      listStyle: "none",
      background: operationBg.toRgbString(),
      pointerEvents: "auto",
      "&-operation": {
        marginInlineStart: paddingSM,
        padding: paddingSM,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        userSelect: "none",
        "&:hover": {
          background: operationBgHover.toRgbString()
        },
        "&-disabled": {
          color: previewOperationColorDisabled,
          pointerEvents: "none"
        },
        "&:last-of-type": {
          marginInlineStart: 0
        }
      },
      "&-progress": {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateX(-50%)"
      },
      "&-icon": {
        fontSize: token.previewOperationSize
      }
    })
  };
};
var genPreviewSwitchStyle = (token) => {
  const {
    modalMaskBg,
    iconCls,
    previewOperationColorDisabled,
    previewCls,
    zIndexPopup,
    motionDurationSlow
  } = token;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-switch-left, ${previewCls}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: zIndexPopup + 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: token.imagePreviewSwitchSize,
      height: token.imagePreviewSwitchSize,
      marginTop: -token.imagePreviewSwitchSize / 2,
      color: token.previewOperationColor,
      background: operationBg.toRgbString(),
      borderRadius: "50%",
      transform: `translateY(-50%)`,
      cursor: "pointer",
      transition: `all ${motionDurationSlow}`,
      pointerEvents: "auto",
      userSelect: "none",
      "&:hover": {
        background: operationBgHover.toRgbString()
      },
      [`&-disabled`]: {
        "&, &:hover": {
          color: previewOperationColorDisabled,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${iconCls}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${iconCls}`]: {
        fontSize: token.previewOperationSize
      }
    },
    [`${previewCls}-switch-left`]: {
      insetInlineStart: token.marginSM
    },
    [`${previewCls}-switch-right`]: {
      insetInlineEnd: token.marginSM
    }
  };
};
var genImagePreviewStyle = (token) => {
  const {
    motionEaseOut,
    previewCls,
    motionDurationSlow,
    componentCls
  } = token;
  return [
    {
      [`${componentCls}-preview-root`]: {
        [previewCls]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${previewCls}-body`]: _extends(_extends({}, genBoxStyle()), {
          overflow: "hidden"
        }),
        [`${previewCls}-img`]: {
          maxWidth: "100%",
          maxHeight: "100%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
          userSelect: "none",
          pointerEvents: "auto",
          "&-wrapper": _extends(_extends({}, genBoxStyle()), {
            transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${previewCls}-moving`]: {
          [`${previewCls}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${componentCls}-preview-root`]: {
        [`${previewCls}-wrap`]: {
          zIndex: token.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${componentCls}-preview-operations-wrapper`]: {
        position: "fixed",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        zIndex: token.zIndexPopup + 1,
        width: "100%"
      },
      "&": [genPreviewOperationsStyle(token), genPreviewSwitchStyle(token)]
    }
  ];
};
var genImageStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    // ============================== image ==============================
    [componentCls]: {
      position: "relative",
      display: "inline-block",
      [`${componentCls}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${componentCls}-img-placeholder`]: {
        backgroundColor: token.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${componentCls}-mask`]: _extends({}, genImageMaskStyle(token)),
      [`${componentCls}-mask:hover`]: {
        opacity: 1
      },
      [`${componentCls}-placeholder`]: _extends({}, genBoxStyle())
    }
  };
};
var genPreviewMotion = (token) => {
  const {
    previewCls
  } = token;
  return {
    [`${previewCls}-root`]: initZoomMotion(token, "zoom"),
    [`&`]: initFadeMotion(token, true)
  };
};
var style_default20 = genComponentStyleHook("Image", (token) => {
  const previewCls = `${token.componentCls}-preview`;
  const imageToken = merge(token, {
    previewCls,
    modalMaskBg: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    imagePreviewSwitchSize: token.controlHeightLG
  });
  return [genImageStyle(imageToken), genImagePreviewStyle(imageToken), genModalMaskStyle(merge(imageToken, {
    componentCls: previewCls
  })), genPreviewMotion(imageToken)];
}, (token) => ({
  zIndexPopup: token.zIndexPopupBase + 80,
  previewOperationColor: new TinyColor(token.colorTextLightSolid).toRgbString(),
  previewOperationColorDisabled: new TinyColor(token.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: token.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
}));

// node_modules/ant-design-vue/es/image/PreviewGroup.js
var icons = {
  rotateLeft: createVNode(RotateLeftOutlined_default, null, null),
  rotateRight: createVNode(RotateRightOutlined_default, null, null),
  zoomIn: createVNode(ZoomInOutlined_default, null, null),
  zoomOut: createVNode(ZoomOutOutlined_default, null, null),
  close: createVNode(CloseOutlined_default, null, null),
  left: createVNode(LeftOutlined_default, null, null),
  right: createVNode(RightOutlined_default, null, null),
  flipX: createVNode(SwapOutlined_default, null, null),
  flipY: createVNode(SwapOutlined_default, {
    "rotate": 90
  }, null)
};
var previewGroupProps = () => ({
  previewPrefixCls: String,
  preview: anyType()
});
var InternalPreviewGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AImagePreviewGroup",
  inheritAttrs: false,
  props: previewGroupProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls,
      rootPrefixCls
    } = useConfigInject_default("image", props2);
    const previewPrefixCls = computed(() => `${prefixCls.value}-preview`);
    const [wrapSSR, hashId] = style_default20(prefixCls);
    const mergedPreview = computed(() => {
      const {
        preview
      } = props2;
      if (preview === false) {
        return preview;
      }
      const _preview = typeof preview === "object" ? preview : {};
      return _extends(_extends({}, _preview), {
        rootClassName: hashId.value,
        transitionName: getTransitionName(rootPrefixCls.value, "zoom", _preview.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls.value, "fade", _preview.maskTransitionName)
      });
    });
    return () => {
      return wrapSSR(createVNode(PreviewGroup_default, _objectSpread2(_objectSpread2({}, _extends(_extends({}, attrs), props2)), {}, {
        "preview": mergedPreview.value,
        "icons": icons,
        "previewPrefixCls": previewPrefixCls.value
      }), slots));
    };
  }
});
var PreviewGroup_default2 = InternalPreviewGroup;

// node_modules/ant-design-vue/es/image/index.js
var Image2 = defineComponent({
  name: "AImage",
  inheritAttrs: false,
  props: imageProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      rootPrefixCls,
      configProvider
    } = useConfigInject_default("image", props2);
    const [wrapSSR, hashId] = style_default20(prefixCls);
    const mergedPreview = computed(() => {
      const {
        preview
      } = props2;
      if (preview === false) {
        return preview;
      }
      const _preview = typeof preview === "object" ? preview : {};
      return _extends(_extends({
        icons
      }, _preview), {
        transitionName: getTransitionName(rootPrefixCls.value, "zoom", _preview.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls.value, "fade", _preview.maskTransitionName)
      });
    });
    return () => {
      var _a2, _b;
      const imageLocale = ((_b = (_a2 = configProvider.locale) === null || _a2 === void 0 ? void 0 : _a2.value) === null || _b === void 0 ? void 0 : _b.Image) || en_US_default3.Image;
      const defaultPreviewMask = () => createVNode("div", {
        "class": `${prefixCls.value}-mask-info`
      }, [createVNode(EyeOutlined_default, null, null), imageLocale === null || imageLocale === void 0 ? void 0 : imageLocale.preview]);
      const {
        previewMask = slots.previewMask || defaultPreviewMask
      } = props2;
      return wrapSSR(createVNode(vc_image_default, _objectSpread2(_objectSpread2({}, _extends(_extends(_extends({}, attrs), props2), {
        prefixCls: prefixCls.value
      })), {}, {
        "preview": mergedPreview.value,
        "rootClassName": classNames_default(props2.rootClassName, hashId.value)
      }), _extends(_extends({}, slots), {
        previewMask: typeof previewMask === "function" ? previewMask : null
      })));
    };
  }
});
Image2.PreviewGroup = PreviewGroup_default2;
Image2.install = function(app) {
  app.component(Image2.name, Image2);
  app.component(Image2.PreviewGroup.name, Image2.PreviewGroup);
  return app;
};
var image_default = Image2;

// node_modules/ant-design-vue/es/input-number/src/utils/supportUtil.js
function supportBigInt() {
  return typeof BigInt === "function";
}

// node_modules/ant-design-vue/es/input-number/src/utils/numberUtil.js
function trimNumber(numStr) {
  let str = numStr.trim();
  let negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = `0${str}`;
  }
  const trimStr = str || "0";
  const splitNumber = trimStr.split(".");
  const integerStr = splitNumber[0] || "0";
  const decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  const negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`
  };
}
function isE(number) {
  const str = String(number);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
function getNumberPrecision(number) {
  const numStr = String(number);
  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch === null || decimalMatch === void 0 ? void 0 : decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
function num2str(number) {
  let numStr = String(number);
  if (isE(number)) {
    if (number > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
}

// node_modules/ant-design-vue/es/input-number/src/utils/MiniDecimal.js
function isEmpty(value) {
  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
var NumberDecimal = class _NumberDecimal {
  constructor(value) {
    this.origin = "";
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  negate() {
    return new _NumberDecimal(-this.toNumber());
  }
  add(value) {
    if (this.isInvalidate()) {
      return new _NumberDecimal(value);
    }
    const target = Number(value);
    if (Number.isNaN(target)) {
      return this;
    }
    const number = this.number + target;
    if (number > Number.MAX_SAFE_INTEGER) {
      return new _NumberDecimal(Number.MAX_SAFE_INTEGER);
    }
    if (number < Number.MIN_SAFE_INTEGER) {
      return new _NumberDecimal(Number.MIN_SAFE_INTEGER);
    }
    const maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
    return new _NumberDecimal(number.toFixed(maxPrecision));
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return Number.isNaN(this.number);
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(target) {
    return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
  }
  lessEquals(target) {
    return this.add(target.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.number;
  }
  toString() {
    let safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!safe) {
      return this.origin;
    }
    if (this.isInvalidate()) {
      return "";
    }
    return num2str(this.number);
  }
};
var BigIntDecimal = class _BigIntDecimal {
  constructor(value) {
    this.origin = "";
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    if (value === "-" || Number.isNaN(value)) {
      this.nan = true;
      return;
    }
    let mergedValue = value;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      const trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      const numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      const decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  getMark() {
    return this.negative ? "-" : "";
  }
  getIntegerStr() {
    return this.integer.toString();
  }
  getDecimalStr() {
    return this.decimal.toString().padStart(this.decimalLen, "0");
  }
  /**
   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
   * This is used for add function only.
   */
  alignDecimal(decimalLength) {
    const str = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(decimalLength, "0")}`;
    return BigInt(str);
  }
  negate() {
    const clone = new _BigIntDecimal(this.toString());
    clone.negative = !clone.negative;
    return clone;
  }
  add(value) {
    if (this.isInvalidate()) {
      return new _BigIntDecimal(value);
    }
    const offset = new _BigIntDecimal(value);
    if (offset.isInvalidate()) {
      return this;
    }
    const maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);
    const myAlignedDecimal = this.alignDecimal(maxDecimalLength);
    const offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);
    const valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();
    const {
      negativeStr,
      trimStr
    } = trimNumber(valueStr);
    const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, "0")}`;
    return new _BigIntDecimal(`${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`);
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return this.nan;
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(target) {
    return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
  }
  lessEquals(target) {
    return this.add(target.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    if (this.isNaN()) {
      return NaN;
    }
    return Number(this.toString());
  }
  toString() {
    let safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!safe) {
      return this.origin;
    }
    if (this.isInvalidate()) {
      return "";
    }
    return trimNumber(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr;
  }
};
function getMiniDecimal(value) {
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}
function toFixed(numStr, separatorStr, precision) {
  let cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (numStr === "") {
    return "";
  }
  const {
    negativeStr,
    integerStr,
    decimalStr
  } = trimNumber(numStr);
  const precisionDecimalStr = `${separatorStr}${decimalStr}`;
  const numberWithoutDecimal = `${negativeStr}${integerStr}`;
  if (precision >= 0) {
    const advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      const advancedDecimal = getMiniDecimal(numStr).add(`${negativeStr}0.${"0".repeat(precision)}${10 - advancedNum}`);
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return `${numberWithoutDecimal}${separatorStr}${decimalStr.padEnd(precision, "0").slice(0, precision)}`;
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return `${numberWithoutDecimal}${precisionDecimalStr}`;
}

// node_modules/ant-design-vue/es/input-number/src/StepHandler.js
var STEP_INTERVAL = 200;
var STEP_DELAY = 600;
var StepHandler_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "StepHandler",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    upDisabled: Boolean,
    downDisabled: Boolean,
    onStep: functionType()
  },
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const stepTimeoutRef = ref();
    const onStepMouseDown = (e, up) => {
      e.preventDefault();
      emit("step", up);
      function loopStep() {
        emit("step", up);
        stepTimeoutRef.value = setTimeout(loopStep, STEP_INTERVAL);
      }
      stepTimeoutRef.value = setTimeout(loopStep, STEP_DELAY);
    };
    const onStopStep = () => {
      clearTimeout(stepTimeoutRef.value);
    };
    onBeforeUnmount(() => {
      onStopStep();
    });
    return () => {
      if (isMobile_default()) {
        return null;
      }
      const {
        prefixCls,
        upDisabled,
        downDisabled
      } = props2;
      const handlerClassName = `${prefixCls}-handler`;
      const upClassName = classNames_default(handlerClassName, `${handlerClassName}-up`, {
        [`${handlerClassName}-up-disabled`]: upDisabled
      });
      const downClassName = classNames_default(handlerClassName, `${handlerClassName}-down`, {
        [`${handlerClassName}-down-disabled`]: downDisabled
      });
      const sharedHandlerProps = {
        unselectable: "on",
        role: "button",
        onMouseup: onStopStep,
        onMouseleave: onStopStep
      };
      const {
        upNode,
        downNode
      } = slots;
      return createVNode("div", {
        "class": `${handlerClassName}-wrap`
      }, [createVNode("span", _objectSpread2(_objectSpread2({}, sharedHandlerProps), {}, {
        "onMousedown": (e) => {
          onStepMouseDown(e, true);
        },
        "aria-label": "Increase Value",
        "aria-disabled": upDisabled,
        "class": upClassName
      }), [(upNode === null || upNode === void 0 ? void 0 : upNode()) || createVNode("span", {
        "unselectable": "on",
        "class": `${prefixCls}-handler-up-inner`
      }, null)]), createVNode("span", _objectSpread2(_objectSpread2({}, sharedHandlerProps), {}, {
        "onMousedown": (e) => {
          onStepMouseDown(e, false);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": downDisabled,
        "class": downClassName
      }), [(downNode === null || downNode === void 0 ? void 0 : downNode()) || createVNode("span", {
        "unselectable": "on",
        "class": `${prefixCls}-handler-down-inner`
      }, null)])]);
    };
  }
});

// node_modules/ant-design-vue/es/input-number/src/hooks/useCursor.js
function useCursor(inputRef, focused) {
  const selectionRef = ref(null);
  function recordCursor() {
    try {
      const {
        selectionStart: start,
        selectionEnd: end,
        value
      } = inputRef.value;
      const beforeTxt = value.substring(0, start);
      const afterTxt = value.substring(end);
      selectionRef.value = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch (e) {
    }
  }
  function restoreCursor() {
    if (inputRef.value && selectionRef.value && focused.value) {
      try {
        const {
          value
        } = inputRef.value;
        const {
          beforeTxt,
          afterTxt,
          start
        } = selectionRef.value;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.value.afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[start - 1];
          const newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        inputRef.value.setSelectionRange(startPos, startPos);
      } catch (e) {
        warning(false, `Something warning of cursor restore. Please fire issue about this: ${e.message}`);
      }
    }
  }
  return [recordCursor, restoreCursor];
}

// node_modules/ant-design-vue/es/input-number/src/hooks/useFrame.js
var useFrame_default = () => {
  const idRef = shallowRef(0);
  const cleanUp = () => {
    wrapperRaf.cancel(idRef.value);
  };
  onBeforeUnmount(() => {
    cleanUp();
  });
  return (callback) => {
    cleanUp();
    idRef.value = wrapperRaf(() => {
      callback();
    });
  };
};

// node_modules/ant-design-vue/es/input-number/src/InputNumber.js
var __rest17 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var getDecimalValue = (stringMode, decimalValue) => {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
var getDecimalIfValidate = (value) => {
  const decimal = getMiniDecimal(value);
  return decimal.isInvalidate() ? null : decimal;
};
var inputNumberProps = () => ({
  /** value will show as string */
  stringMode: booleanType(),
  defaultValue: someType([String, Number]),
  value: someType([String, Number]),
  prefixCls: stringType(),
  min: someType([String, Number]),
  max: someType([String, Number]),
  step: someType([String, Number], 1),
  tabindex: Number,
  controls: booleanType(true),
  readonly: booleanType(),
  disabled: booleanType(),
  autofocus: booleanType(),
  keyboard: booleanType(true),
  /** Parse display value to validate number */
  parser: functionType(),
  /** Transform `value` to display value show in input */
  formatter: functionType(),
  /** Syntactic sugar of `formatter`. Config precision of display. */
  precision: Number,
  /** Syntactic sugar of `formatter`. Config decimal separator of display. */
  decimalSeparator: String,
  onInput: functionType(),
  onChange: functionType(),
  onPressEnter: functionType(),
  onStep: functionType(),
  onBlur: functionType(),
  onFocus: functionType()
});
var InputNumber_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InnerInputNumber",
  inheritAttrs: false,
  props: _extends(_extends({}, inputNumberProps()), {
    lazy: Boolean
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit,
      expose
    } = _ref;
    const inputRef = shallowRef();
    const focus = shallowRef(false);
    const userTypingRef = shallowRef(false);
    const compositionRef = shallowRef(false);
    const decimalValue = shallowRef(getMiniDecimal(props2.value));
    function setUncontrolledDecimalValue(newDecimal) {
      if (props2.value === void 0) {
        decimalValue.value = newDecimal;
      }
    }
    const getPrecision2 = (numStr, userTyping) => {
      if (userTyping) {
        return void 0;
      }
      if (props2.precision >= 0) {
        return props2.precision;
      }
      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props2.step));
    };
    const mergedParser = (num) => {
      const numStr = String(num);
      if (props2.parser) {
        return props2.parser(numStr);
      }
      let parsedStr = numStr;
      if (props2.decimalSeparator) {
        parsedStr = parsedStr.replace(props2.decimalSeparator, ".");
      }
      return parsedStr.replace(/[^\w.-]+/g, "");
    };
    const inputValue = shallowRef("");
    const mergedFormatter = (number, userTyping) => {
      if (props2.formatter) {
        return props2.formatter(number, {
          userTyping,
          input: String(inputValue.value)
        });
      }
      let str = typeof number === "number" ? num2str(number) : number;
      if (!userTyping) {
        const mergedPrecision = getPrecision2(str, userTyping);
        if (validateNumber(str) && (props2.decimalSeparator || mergedPrecision >= 0)) {
          const separatorStr = props2.decimalSeparator || ".";
          str = toFixed(str, separatorStr, mergedPrecision);
        }
      }
      return str;
    };
    const initValue = (() => {
      const initValue2 = props2.value;
      if (decimalValue.value.isInvalidate() && ["string", "number"].includes(typeof initValue2)) {
        return Number.isNaN(initValue2) ? "" : initValue2;
      }
      return mergedFormatter(decimalValue.value.toString(), false);
    })();
    inputValue.value = initValue;
    function setInputValue(newValue, userTyping) {
      inputValue.value = mergedFormatter(
        // Invalidate number is sometime passed by external control, we should let it go
        // Otherwise is controlled by internal interactive logic which check by userTyping
        // You can ref 'show limited value when input is not focused' test for more info.
        newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
        userTyping
      );
    }
    const maxDecimal = computed(() => getDecimalIfValidate(props2.max));
    const minDecimal = computed(() => getDecimalIfValidate(props2.min));
    const upDisabled = computed(() => {
      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return maxDecimal.value.lessEquals(decimalValue.value);
    });
    const downDisabled = computed(() => {
      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return decimalValue.value.lessEquals(minDecimal.value);
    });
    const [recordCursor, restoreCursor] = useCursor(inputRef, focus);
    const getRangeValue = (target) => {
      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {
        return maxDecimal.value;
      }
      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {
        return minDecimal.value;
      }
      return null;
    };
    const isInRange2 = (target) => !getRangeValue(target);
    const triggerValueUpdate = (newValue, userTyping) => {
      var _a2;
      let updateValue = newValue;
      let isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
      if (!updateValue.isEmpty() && !userTyping) {
        updateValue = getRangeValue(updateValue) || updateValue;
        isRangeValidate = true;
      }
      if (!props2.readonly && !props2.disabled && isRangeValidate) {
        const numStr = updateValue.toString();
        const mergedPrecision = getPrecision2(numStr, userTyping);
        if (mergedPrecision >= 0) {
          updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
        }
        if (!updateValue.equals(decimalValue.value)) {
          setUncontrolledDecimalValue(updateValue);
          (_a2 = props2.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, updateValue.isEmpty() ? null : getDecimalValue(props2.stringMode, updateValue));
          if (props2.value === void 0) {
            setInputValue(updateValue, userTyping);
          }
        }
        return updateValue;
      }
      return decimalValue.value;
    };
    const onNextPromise = useFrame_default();
    const collectInputValue = (inputStr) => {
      var _a2;
      recordCursor();
      inputValue.value = inputStr;
      if (!compositionRef.value) {
        const finalValue = mergedParser(inputStr);
        const finalDecimal = getMiniDecimal(finalValue);
        if (!finalDecimal.isNaN()) {
          triggerValueUpdate(finalDecimal, true);
        }
      }
      (_a2 = props2.onInput) === null || _a2 === void 0 ? void 0 : _a2.call(props2, inputStr);
      onNextPromise(() => {
        let nextInputStr = inputStr;
        if (!props2.parser) {
          nextInputStr = inputStr.replace(/。/g, ".");
        }
        if (nextInputStr !== inputStr) {
          collectInputValue(nextInputStr);
        }
      });
    };
    const onCompositionStart = () => {
      compositionRef.value = true;
    };
    const onCompositionEnd = () => {
      compositionRef.value = false;
      collectInputValue(inputRef.value.value);
    };
    const onInternalInput = (e) => {
      collectInputValue(e.target.value);
    };
    const onInternalStep = (up) => {
      var _a2, _b;
      if (up && upDisabled.value || !up && downDisabled.value) {
        return;
      }
      userTypingRef.value = false;
      let stepDecimal = getMiniDecimal(props2.step);
      if (!up) {
        stepDecimal = stepDecimal.negate();
      }
      const target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());
      const updatedValue = triggerValueUpdate(target, false);
      (_a2 = props2.onStep) === null || _a2 === void 0 ? void 0 : _a2.call(props2, getDecimalValue(props2.stringMode, updatedValue), {
        offset: props2.step,
        type: up ? "up" : "down"
      });
      (_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.focus();
    };
    const flushInputValue = (userTyping) => {
      const parsedValue = getMiniDecimal(mergedParser(inputValue.value));
      let formatValue2 = parsedValue;
      if (!parsedValue.isNaN()) {
        formatValue2 = triggerValueUpdate(parsedValue, userTyping);
      } else {
        formatValue2 = decimalValue.value;
      }
      if (props2.value !== void 0) {
        setInputValue(decimalValue.value, false);
      } else if (!formatValue2.isNaN()) {
        setInputValue(formatValue2, false);
      }
    };
    const onBeforeInput = () => {
      userTypingRef.value = true;
    };
    const onKeyDown = (event) => {
      var _a2;
      const {
        which
      } = event;
      userTypingRef.value = true;
      if (which === KeyCode_default.ENTER) {
        if (!compositionRef.value) {
          userTypingRef.value = false;
        }
        flushInputValue(false);
        (_a2 = props2.onPressEnter) === null || _a2 === void 0 ? void 0 : _a2.call(props2, event);
      }
      if (props2.keyboard === false) {
        return;
      }
      if (!compositionRef.value && [KeyCode_default.UP, KeyCode_default.DOWN].includes(which)) {
        onInternalStep(KeyCode_default.UP === which);
        event.preventDefault();
      }
    };
    const onKeyUp = () => {
      userTypingRef.value = false;
    };
    const onBlur = (e) => {
      flushInputValue(false);
      focus.value = false;
      userTypingRef.value = false;
      emit("blur", e);
    };
    watch(() => props2.precision, () => {
      if (!decimalValue.value.isInvalidate()) {
        setInputValue(decimalValue.value, false);
      }
    }, {
      flush: "post"
    });
    watch(() => props2.value, () => {
      const newValue = getMiniDecimal(props2.value);
      decimalValue.value = newValue;
      const currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));
      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props2.formatter) {
        setInputValue(newValue, userTypingRef.value);
      }
    }, {
      flush: "post"
    });
    watch(inputValue, () => {
      if (props2.formatter) {
        restoreCursor();
      }
    }, {
      flush: "post"
    });
    watch(() => props2.disabled, (val) => {
      if (val) {
        focus.value = false;
      }
    });
    expose({
      focus: () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur: () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      }
    });
    return () => {
      const _a2 = _extends(_extends({}, attrs), props2), {
        prefixCls = "rc-input-number",
        min,
        max,
        step = 1,
        defaultValue,
        value,
        disabled,
        readonly,
        keyboard,
        controls = true,
        autofocus,
        stringMode,
        parser,
        formatter,
        precision,
        decimalSeparator,
        onChange,
        onInput,
        onPressEnter,
        onStep,
        lazy,
        class: className,
        style
      } = _a2, inputProps = __rest17(_a2, ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard", "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "lazy", "class", "style"]);
      const {
        upHandler,
        downHandler
      } = slots;
      const inputClassName = `${prefixCls}-input`;
      const eventProps = {};
      if (lazy) {
        eventProps.onChange = onInternalInput;
      } else {
        eventProps.onInput = onInternalInput;
      }
      return createVNode("div", {
        "class": classNames_default(prefixCls, className, {
          [`${prefixCls}-focused`]: focus.value,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-readonly`]: readonly,
          [`${prefixCls}-not-a-number`]: decimalValue.value.isNaN(),
          [`${prefixCls}-out-of-range`]: !decimalValue.value.isInvalidate() && !isInRange2(decimalValue.value)
        }),
        "style": style,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp
      }, [controls && createVNode(StepHandler_default, {
        "prefixCls": prefixCls,
        "upDisabled": upDisabled.value,
        "downDisabled": downDisabled.value,
        "onStep": onInternalStep
      }, {
        upNode: upHandler,
        downNode: downHandler
      }), createVNode("div", {
        "class": `${inputClassName}-wrap`
      }, [createVNode("input", _objectSpread2(_objectSpread2(_objectSpread2({
        "autofocus": autofocus,
        "autocomplete": "off",
        "role": "spinbutton",
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),
        "step": step
      }, inputProps), {}, {
        "ref": inputRef,
        "class": inputClassName,
        "value": inputValue.value,
        "disabled": disabled,
        "readonly": readonly,
        "onFocus": (e) => {
          focus.value = true;
          emit("focus", e);
        }
      }, eventProps), {}, {
        "onBlur": onBlur,
        "onCompositionstart": onCompositionStart,
        "onCompositionend": onCompositionEnd,
        "onBeforeinput": onBeforeInput
      }), null)])]);
    };
  }
});

// node_modules/ant-design-vue/es/_util/isValidValue.js
function isValidValue_default(val) {
  return val !== void 0 && val !== null;
}

// node_modules/ant-design-vue/es/input-number/style/index.js
var genInputNumberStyles = (token) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    colorError,
    inputPaddingHorizontalSM,
    colorTextDescription,
    motionDurationMid,
    colorPrimary,
    controlHeight,
    inputPaddingHorizontal,
    colorBgContainer,
    colorTextDisabled,
    borderRadiusSM,
    borderRadiusLG,
    controlWidth,
    handleVisible
  } = token;
  return [
    {
      [componentCls]: _extends(_extends(_extends(_extends({}, resetComponent(token)), genBasicInputStyle(token)), genStatusStyle(token, componentCls)), {
        display: "inline-block",
        width: controlWidth,
        margin: 0,
        padding: 0,
        border: `${lineWidth}px ${lineType} ${colorBorder}`,
        borderRadius,
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: fontSizeLG,
          borderRadius: borderRadiusLG,
          [`input${componentCls}-input`]: {
            height: controlHeightLG - 2 * lineWidth
          }
        },
        "&-sm": {
          padding: 0,
          borderRadius: borderRadiusSM,
          [`input${componentCls}-input`]: {
            height: controlHeightSM - 2 * lineWidth,
            padding: `0 ${inputPaddingHorizontalSM}px`
          }
        },
        "&:hover": _extends({}, genHoverStyle(token)),
        "&-focused": _extends({}, genActiveStyle(token)),
        "&-disabled": _extends(_extends({}, genDisabledStyle(token)), {
          [`${componentCls}-input`]: {
            cursor: "not-allowed"
          }
        }),
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          input: {
            color: colorError
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": _extends(_extends(_extends({}, resetComponent(token)), genInputGroupStyle(token)), {
          "&-wrapper": {
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            [`${componentCls}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            }
          }
        }),
        [componentCls]: {
          "&-input": _extends(_extends({
            width: "100%",
            height: controlHeight - 2 * lineWidth,
            padding: `0 ${inputPaddingHorizontal}px`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius,
            outline: 0,
            transition: `all ${motionDurationMid} linear`,
            appearance: "textfield",
            color: token.colorText,
            fontSize: "inherit",
            verticalAlign: "top"
          }, genPlaceholderStyle(token.colorTextPlaceholder)), {
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              /* stylelint-disable-next-line property-no-vendor-prefix */
              webkitAppearance: "none",
              appearance: "none"
            }
          })
        }
      })
    },
    // Handler
    {
      [componentCls]: {
        [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
          opacity: 1
        },
        [`${componentCls}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: token.handleWidth,
          height: "100%",
          background: colorBgContainer,
          borderStartStartRadius: 0,
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius,
          borderEndStartRadius: 0,
          opacity: handleVisible === true ? 1 : 0,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `opacity ${motionDurationMid} linear ${motionDurationMid}`,
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${componentCls}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: token.handleFontSize
            }
          }
        },
        [`${componentCls}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: colorTextDescription,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
          transition: `all ${motionDurationMid} linear`,
          "&:active": {
            background: token.colorFillAlter
          },
          // Hover
          "&:hover": {
            height: `60%`,
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              color: colorPrimary
            }
          },
          "&-up-inner, &-down-inner": _extends(_extends({}, resetIcon()), {
            color: colorTextDescription,
            transition: `all ${motionDurationMid} linear`,
            userSelect: "none"
          })
        },
        [`${componentCls}-handler-up`]: {
          borderStartEndRadius: borderRadius
        },
        [`${componentCls}-handler-down`]: {
          borderBlockStart: `${lineWidth}px ${lineType} ${colorBorder}`,
          borderEndEndRadius: borderRadius
        },
        // Disabled
        "&-disabled, &-readonly": {
          [`${componentCls}-handler-wrap`]: {
            display: "none"
          },
          [`${componentCls}-input`]: {
            color: "inherit"
          }
        },
        [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: colorTextDisabled
        }
      }
    },
    // Border-less
    {
      [`${componentCls}-borderless`]: {
        borderColor: "transparent",
        boxShadow: "none",
        [`${componentCls}-handler-down`]: {
          borderBlockStartWidth: 0
        }
      }
    }
  ];
};
var genAffixWrapperStyles = (token) => {
  const {
    componentCls,
    inputPaddingHorizontal,
    inputAffixPadding,
    controlWidth,
    borderRadiusLG,
    borderRadiusSM
  } = token;
  return {
    [`${componentCls}-affix-wrapper`]: _extends(_extends(_extends({}, genBasicInputStyle(token)), genStatusStyle(token, `${componentCls}-affix-wrapper`)), {
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      width: controlWidth,
      padding: 0,
      paddingInlineStart: inputPaddingHorizontal,
      "&-lg": {
        borderRadius: borderRadiusLG
      },
      "&-sm": {
        borderRadius: borderRadiusSM
      },
      [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: _extends(_extends({}, genHoverStyle(token)), {
        zIndex: 1
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${componentCls}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> div${componentCls}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${componentCls}-focused`]: {
          boxShadow: "none !important"
        }
      },
      [`input${componentCls}-input`]: {
        padding: 0
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}-handler-wrap`]: {
        zIndex: 2
      },
      [componentCls]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: "100%",
          marginInlineEnd: inputPaddingHorizontal,
          marginInlineStart: inputAffixPadding
        }
      }
    })
  };
};
var style_default21 = genComponentStyleHook("InputNumber", (token) => {
  const inputNumberToken = initInputToken(token);
  return [
    genInputNumberStyles(inputNumberToken),
    genAffixWrapperStyles(inputNumberToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputNumberToken)
  ];
}, (token) => ({
  controlWidth: 90,
  handleWidth: token.controlHeightSM - token.lineWidth * 2,
  handleFontSize: token.fontSize / 2,
  handleVisible: "auto"
}));

// node_modules/ant-design-vue/es/input-number/index.js
var __rest18 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var baseProps = inputNumberProps();
var inputNumberProps2 = () => _extends(_extends({}, baseProps), {
  size: stringType(),
  bordered: booleanType(true),
  placeholder: String,
  name: String,
  id: String,
  type: String,
  addonBefore: vue_types_default.any,
  addonAfter: vue_types_default.any,
  prefix: vue_types_default.any,
  "onUpdate:value": baseProps.onChange,
  valueModifiers: Object,
  status: stringType()
});
var InputNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputNumber",
  inheritAttrs: false,
  props: inputNumberProps2(),
  // emits: ['focus', 'blur', 'change', 'input', 'update:value'],
  slots: Object,
  setup(props2, _ref) {
    let {
      emit,
      expose,
      attrs,
      slots
    } = _ref;
    var _a2;
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const {
      prefixCls,
      size,
      direction,
      disabled
    } = useConfigInject_default("input-number", props2);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a3;
      return (_a3 = disabled.value) !== null && _a3 !== void 0 ? _a3 : disabledContext.value;
    });
    const [wrapSSR, hashId] = style_default21(prefixCls);
    const mergedSize = computed(() => compactSize.value || size.value);
    const mergedValue = shallowRef((_a2 = props2.value) !== null && _a2 !== void 0 ? _a2 : props2.defaultValue);
    const focused = shallowRef(false);
    watch(() => props2.value, () => {
      mergedValue.value = props2.value;
    });
    const inputNumberRef = shallowRef(null);
    const focus = () => {
      var _a3;
      (_a3 = inputNumberRef.value) === null || _a3 === void 0 ? void 0 : _a3.focus();
    };
    const blur = () => {
      var _a3;
      (_a3 = inputNumberRef.value) === null || _a3 === void 0 ? void 0 : _a3.blur();
    };
    expose({
      focus,
      blur
    });
    const handleChange = (val) => {
      if (props2.value === void 0) {
        mergedValue.value = val;
      }
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    const handleBlur = (e) => {
      focused.value = false;
      emit("blur", e);
      formItemContext.onFieldBlur();
    };
    const handleFocus = (e) => {
      focused.value = true;
      emit("focus", e);
    };
    return () => {
      var _a3, _b, _c, _d;
      const {
        hasFeedback,
        isFormItemInput,
        feedbackIcon
      } = formItemInputContext;
      const id = (_a3 = props2.id) !== null && _a3 !== void 0 ? _a3 : formItemContext.id.value;
      const _e = _extends(_extends(_extends({}, attrs), props2), {
        id,
        disabled: mergedDisabled.value
      }), {
        class: className,
        bordered,
        readonly,
        style,
        addonBefore = (_b = slots.addonBefore) === null || _b === void 0 ? void 0 : _b.call(slots),
        addonAfter = (_c = slots.addonAfter) === null || _c === void 0 ? void 0 : _c.call(slots),
        prefix = (_d = slots.prefix) === null || _d === void 0 ? void 0 : _d.call(slots),
        valueModifiers = {}
      } = _e, others = __rest18(_e, ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"]);
      const preCls = prefixCls.value;
      const inputNumberClass = classNames_default({
        [`${preCls}-lg`]: mergedSize.value === "large",
        [`${preCls}-sm`]: mergedSize.value === "small",
        [`${preCls}-rtl`]: direction.value === "rtl",
        [`${preCls}-readonly`]: readonly,
        [`${preCls}-borderless`]: !bordered,
        [`${preCls}-in-form-item`]: isFormItemInput
      }, getStatusClassNames(preCls, mergedStatus.value), className, compactItemClassnames.value, hashId.value);
      let element = createVNode(InputNumber_default, _objectSpread2(_objectSpread2({}, omit_default(others, ["size", "defaultValue"])), {}, {
        "ref": inputNumberRef,
        "lazy": !!valueModifiers.lazy,
        "value": mergedValue.value,
        "class": inputNumberClass,
        "prefixCls": preCls,
        "readonly": readonly,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "onFocus": handleFocus
      }), {
        upHandler: slots.upIcon ? () => createVNode("span", {
          "class": `${preCls}-handler-up-inner`
        }, [slots.upIcon()]) : () => createVNode(UpOutlined_default, {
          "class": `${preCls}-handler-up-inner`
        }, null),
        downHandler: slots.downIcon ? () => createVNode("span", {
          "class": `${preCls}-handler-down-inner`
        }, [slots.downIcon()]) : () => createVNode(DownOutlined_default, {
          "class": `${preCls}-handler-down-inner`
        }, null)
      });
      const hasAddon = isValidValue_default(addonBefore) || isValidValue_default(addonAfter);
      const hasPrefix = isValidValue_default(prefix);
      if (hasPrefix || hasFeedback) {
        const affixWrapperCls = classNames_default(`${preCls}-affix-wrapper`, getStatusClassNames(`${preCls}-affix-wrapper`, mergedStatus.value, hasFeedback), {
          [`${preCls}-affix-wrapper-focused`]: focused.value,
          [`${preCls}-affix-wrapper-disabled`]: mergedDisabled.value,
          [`${preCls}-affix-wrapper-sm`]: mergedSize.value === "small",
          [`${preCls}-affix-wrapper-lg`]: mergedSize.value === "large",
          [`${preCls}-affix-wrapper-rtl`]: direction.value === "rtl",
          [`${preCls}-affix-wrapper-readonly`]: readonly,
          [`${preCls}-affix-wrapper-borderless`]: !bordered,
          // className will go to addon wrapper
          [`${className}`]: !hasAddon && className
        }, hashId.value);
        element = createVNode("div", {
          "class": affixWrapperCls,
          "style": style,
          "onClick": focus
        }, [hasPrefix && createVNode("span", {
          "class": `${preCls}-prefix`
        }, [prefix]), element, hasFeedback && createVNode("span", {
          "class": `${preCls}-suffix`
        }, [feedbackIcon])]);
      }
      if (hasAddon) {
        const wrapperClassName = `${preCls}-group`;
        const addonClassName = `${wrapperClassName}-addon`;
        const addonBeforeNode = addonBefore ? createVNode("div", {
          "class": addonClassName
        }, [addonBefore]) : null;
        const addonAfterNode = addonAfter ? createVNode("div", {
          "class": addonClassName
        }, [addonAfter]) : null;
        const mergedWrapperClassName = classNames_default(`${preCls}-wrapper`, wrapperClassName, {
          [`${wrapperClassName}-rtl`]: direction.value === "rtl"
        }, hashId.value);
        const mergedGroupClassName = classNames_default(`${preCls}-group-wrapper`, {
          [`${preCls}-group-wrapper-sm`]: mergedSize.value === "small",
          [`${preCls}-group-wrapper-lg`]: mergedSize.value === "large",
          [`${preCls}-group-wrapper-rtl`]: direction.value === "rtl"
        }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus.value, hasFeedback), className, hashId.value);
        element = createVNode("div", {
          "class": mergedGroupClassName,
          "style": style
        }, [createVNode("div", {
          "class": mergedWrapperClassName
        }, [addonBeforeNode && createVNode(NoCompactStyle, null, {
          default: () => [createVNode(NoFormStatus, null, {
            default: () => [addonBeforeNode]
          })]
        }), element, addonAfterNode && createVNode(NoCompactStyle, null, {
          default: () => [createVNode(NoFormStatus, null, {
            default: () => [addonAfterNode]
          })]
        })])]);
      }
      return wrapSSR(cloneElement(element, {
        style
      }));
    };
  }
});
var input_number_default = _extends(InputNumber, {
  install: (app) => {
    app.component(InputNumber.name, InputNumber);
    return app;
  }
});

// node_modules/ant-design-vue/es/layout/style/light.js
var genLayoutLightStyle = (token) => {
  const {
    componentCls,
    colorBgContainer,
    colorBgBody,
    colorText
  } = token;
  return {
    [`${componentCls}-sider-light`]: {
      background: colorBgContainer,
      [`${componentCls}-sider-trigger`]: {
        color: colorText,
        background: colorBgContainer
      },
      [`${componentCls}-sider-zero-width-trigger`]: {
        color: colorText,
        background: colorBgContainer,
        border: `1px solid ${colorBgBody}`,
        borderInlineStart: 0
      }
    }
  };
};
var light_default = genLayoutLightStyle;

// node_modules/ant-design-vue/es/layout/style/index.js
var genLayoutStyle = (token) => {
  const {
    antCls,
    // .ant
    componentCls,
    // .ant-layout
    colorText,
    colorTextLightSolid,
    colorBgHeader,
    colorBgBody,
    colorBgTrigger,
    layoutHeaderHeight,
    layoutHeaderPaddingInline,
    layoutHeaderColor,
    layoutFooterPadding,
    layoutTriggerHeight,
    layoutZeroTriggerSize,
    motionDurationMid,
    motionDurationSlow,
    fontSize,
    borderRadius
  } = token;
  return {
    [componentCls]: _extends(_extends({
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      color: colorText,
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: colorBgBody,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${componentCls}-has-sider`]: {
        flexDirection: "row",
        [`> ${componentCls}, > ${componentCls}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${componentCls}-header, &${componentCls}-footer`]: {
        flex: "0 0 auto"
      },
      [`${componentCls}-header`]: {
        height: layoutHeaderHeight,
        paddingInline: layoutHeaderPaddingInline,
        color: layoutHeaderColor,
        lineHeight: `${layoutHeaderHeight}px`,
        background: colorBgHeader,
        // Other components/menu/style/index.less line:686
        // Integration with header element so menu items have the same height
        [`${antCls}-menu`]: {
          lineHeight: "inherit"
        }
      },
      [`${componentCls}-footer`]: {
        padding: layoutFooterPadding,
        color: colorText,
        fontSize,
        background: colorBgBody
      },
      [`${componentCls}-content`]: {
        flex: "auto",
        // fix firefox can't set height smaller than content on flex item
        minHeight: 0
      },
      [`${componentCls}-sider`]: {
        position: "relative",
        // fix firefox can't set width smaller than content on flex item
        minWidth: 0,
        background: colorBgHeader,
        transition: `all ${motionDurationMid}, background 0s`,
        "&-children": {
          height: "100%",
          // Hack for fixing margin collapse bug
          // https://github.com/ant-design/ant-design/issues/7967
          // solution from https://stackoverflow.com/a/33132624/3040605
          marginTop: -0.1,
          paddingTop: 0.1,
          [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
            width: "auto"
          }
        },
        "&-has-trigger": {
          paddingBottom: layoutTriggerHeight
        },
        "&-right": {
          order: 1
        },
        "&-trigger": {
          position: "fixed",
          bottom: 0,
          zIndex: 1,
          height: layoutTriggerHeight,
          color: colorTextLightSolid,
          lineHeight: `${layoutTriggerHeight}px`,
          textAlign: "center",
          background: colorBgTrigger,
          cursor: "pointer",
          transition: `all ${motionDurationMid}`
        },
        "&-zero-width": {
          "> *": {
            overflow: "hidden"
          },
          "&-trigger": {
            position: "absolute",
            top: layoutHeaderHeight,
            insetInlineEnd: -layoutZeroTriggerSize,
            zIndex: 1,
            width: layoutZeroTriggerSize,
            height: layoutZeroTriggerSize,
            color: colorTextLightSolid,
            fontSize: token.fontSizeXL,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            background: colorBgHeader,
            borderStartStartRadius: 0,
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius,
            borderEndStartRadius: 0,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&::after": {
              position: "absolute",
              inset: 0,
              background: "transparent",
              transition: `all ${motionDurationSlow}`,
              content: '""'
            },
            "&:hover::after": {
              // FIXME: Hardcode, but seems no need to create a token for this
              background: `rgba(255, 255, 255, 0.2)`
            },
            "&-right": {
              insetInlineStart: -layoutZeroTriggerSize,
              borderStartStartRadius: borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: borderRadius
            }
          }
        }
      }
    }, light_default(token)), {
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
};
var style_default22 = genComponentStyleHook("Layout", (token) => {
  const {
    colorText,
    controlHeightSM,
    controlHeight,
    controlHeightLG,
    marginXXS
  } = token;
  const layoutHeaderPaddingInline = controlHeightLG * 1.25;
  const layoutToken = merge(token, {
    // Layout
    layoutHeaderHeight: controlHeight * 2,
    layoutHeaderPaddingInline,
    layoutHeaderColor: colorText,
    layoutFooterPadding: `${controlHeightSM}px ${layoutHeaderPaddingInline}px`,
    layoutTriggerHeight: controlHeightLG + marginXXS * 2,
    layoutZeroTriggerSize: controlHeightLG
  });
  return [genLayoutStyle(layoutToken)];
}, (token) => {
  const {
    colorBgLayout
  } = token;
  return {
    colorBgHeader: "#001529",
    colorBgBody: colorBgLayout,
    colorBgTrigger: "#002140"
  };
});

// node_modules/ant-design-vue/es/layout/layout.js
var basicProps = () => ({
  prefixCls: String,
  hasSider: {
    type: Boolean,
    default: void 0
  },
  tagName: String
});
function generator(_ref) {
  let {
    suffixCls,
    tagName,
    name
  } = _ref;
  return (BasicComponent) => {
    const Adapter = defineComponent({
      compatConfig: {
        MODE: 3
      },
      name,
      props: basicProps(),
      setup(props2, _ref2) {
        let {
          slots
        } = _ref2;
        const {
          prefixCls
        } = useConfigInject_default(suffixCls, props2);
        return () => {
          const basicComponentProps = _extends(_extends({}, props2), {
            prefixCls: prefixCls.value,
            tagName
          });
          return createVNode(BasicComponent, basicComponentProps, slots);
        };
      }
    });
    return Adapter;
  };
}
var Basic = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: basicProps(),
  setup(props2, _ref3) {
    let {
      slots
    } = _ref3;
    return () => createVNode(props2.tagName, {
      class: props2.prefixCls
    }, slots);
  }
});
var BasicLayout = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: basicProps(),
  setup(props2, _ref4) {
    let {
      slots,
      attrs
    } = _ref4;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("", props2);
    const [wrapSSR, hashId] = style_default22(prefixCls);
    const siders = ref([]);
    const siderHookProvider = {
      addSider: (id) => {
        siders.value = [...siders.value, id];
      },
      removeSider: (id) => {
        siders.value = siders.value.filter((currentId) => currentId !== id);
      }
    };
    provide(SiderHookProviderKey, siderHookProvider);
    const divCls = computed(() => {
      const {
        prefixCls: prefixCls2,
        hasSider
      } = props2;
      return {
        [hashId.value]: true,
        [`${prefixCls2}`]: true,
        [`${prefixCls2}-has-sider`]: typeof hasSider === "boolean" ? hasSider : siders.value.length > 0,
        [`${prefixCls2}-rtl`]: direction.value === "rtl"
      };
    });
    return () => {
      const {
        tagName
      } = props2;
      return wrapSSR(createVNode(tagName, _extends(_extends({}, attrs), {
        class: [divCls.value, attrs.class]
      }), slots));
    };
  }
});
var Layout = generator({
  suffixCls: "layout",
  tagName: "section",
  name: "ALayout"
})(BasicLayout);
var Header2 = generator({
  suffixCls: "layout-header",
  tagName: "header",
  name: "ALayoutHeader"
})(Basic);
var Footer = generator({
  suffixCls: "layout-footer",
  tagName: "footer",
  name: "ALayoutFooter"
})(Basic);
var Content = generator({
  suffixCls: "layout-content",
  tagName: "main",
  name: "ALayoutContent"
})(Basic);
var layout_default = Layout;

// node_modules/ant-design-vue/es/layout/Sider.js
var dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px",
  xxxl: "1999.98px"
};
var siderProps = () => ({
  prefixCls: String,
  collapsible: {
    type: Boolean,
    default: void 0
  },
  collapsed: {
    type: Boolean,
    default: void 0
  },
  defaultCollapsed: {
    type: Boolean,
    default: void 0
  },
  reverseArrow: {
    type: Boolean,
    default: void 0
  },
  zeroWidthTriggerStyle: {
    type: Object,
    default: void 0
  },
  trigger: vue_types_default.any,
  width: vue_types_default.oneOfType([vue_types_default.number, vue_types_default.string]),
  collapsedWidth: vue_types_default.oneOfType([vue_types_default.number, vue_types_default.string]),
  breakpoint: vue_types_default.oneOf(tuple("xs", "sm", "md", "lg", "xl", "xxl", "xxxl")),
  theme: vue_types_default.oneOf(tuple("light", "dark")).def("dark"),
  onBreakpoint: Function,
  onCollapse: Function
});
var generateId = (() => {
  let i = 0;
  return function() {
    let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    i += 1;
    return `${prefix}${i}`;
  };
})();
var Sider_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ALayoutSider",
  inheritAttrs: false,
  props: initDefaultProps_default(siderProps(), {
    collapsible: false,
    defaultCollapsed: false,
    reverseArrow: false,
    width: 200,
    collapsedWidth: 80
  }),
  emits: ["breakpoint", "update:collapsed", "collapse"],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("layout-sider", props2);
    const siderHook = inject(SiderHookProviderKey, void 0);
    const collapsed = shallowRef(!!(props2.collapsed !== void 0 ? props2.collapsed : props2.defaultCollapsed));
    const below = shallowRef(false);
    watch(() => props2.collapsed, () => {
      collapsed.value = !!props2.collapsed;
    });
    provide(SiderCollapsedKey, collapsed);
    const handleSetCollapsed = (value, type) => {
      if (props2.collapsed === void 0) {
        collapsed.value = value;
      }
      emit("update:collapsed", value);
      emit("collapse", value, type);
    };
    const responsiveHandlerRef = shallowRef((mql2) => {
      below.value = mql2.matches;
      emit("breakpoint", mql2.matches);
      if (collapsed.value !== mql2.matches) {
        handleSetCollapsed(mql2.matches, "responsive");
      }
    });
    let mql;
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.value(mql2);
    }
    const uniqueId = generateId("ant-sider-");
    siderHook && siderHook.addSider(uniqueId);
    onMounted(() => {
      watch(() => props2.breakpoint, () => {
        try {
          mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
        } catch (error) {
          mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
        }
        if (typeof window !== "undefined") {
          const {
            matchMedia
          } = window;
          if (matchMedia && props2.breakpoint && props2.breakpoint in dimensionMaxMap) {
            mql = matchMedia(`(max-width: ${dimensionMaxMap[props2.breakpoint]})`);
            try {
              mql.addEventListener("change", responsiveHandler);
            } catch (error) {
              mql.addListener(responsiveHandler);
            }
            responsiveHandler(mql);
          }
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      try {
        mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
      } catch (error) {
        mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
      }
      siderHook && siderHook.removeSider(uniqueId);
    });
    const toggle = () => {
      handleSetCollapsed(!collapsed.value, "clickTrigger");
    };
    return () => {
      var _a2, _b;
      const pre = prefixCls.value;
      const {
        collapsedWidth,
        width,
        reverseArrow,
        zeroWidthTriggerStyle,
        trigger = (_a2 = slots.trigger) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        collapsible,
        theme
      } = props2;
      const rawWidth = collapsed.value ? collapsedWidth : width;
      const siderWidth = isNumeric_default(rawWidth) ? `${rawWidth}px` : String(rawWidth);
      const zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? createVNode("span", {
        "onClick": toggle,
        "class": classNames_default(`${pre}-zero-width-trigger`, `${pre}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
        "style": zeroWidthTriggerStyle
      }, [trigger || createVNode(BarsOutlined_default, null, null)]) : null;
      const iconObj = {
        expanded: reverseArrow ? createVNode(RightOutlined_default, null, null) : createVNode(LeftOutlined_default, null, null),
        collapsed: reverseArrow ? createVNode(LeftOutlined_default, null, null) : createVNode(RightOutlined_default, null, null)
      };
      const status = collapsed.value ? "collapsed" : "expanded";
      const defaultTrigger = iconObj[status];
      const triggerDom = trigger !== null ? zeroWidthTrigger || createVNode("div", {
        "class": `${pre}-trigger`,
        "onClick": toggle,
        "style": {
          width: siderWidth
        }
      }, [trigger || defaultTrigger]) : null;
      const divStyle = [attrs.style, {
        flex: `0 0 ${siderWidth}`,
        maxWidth: siderWidth,
        minWidth: siderWidth,
        width: siderWidth
      }];
      const siderCls = classNames_default(pre, `${pre}-${theme}`, {
        [`${pre}-collapsed`]: !!collapsed.value,
        [`${pre}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
        [`${pre}-below`]: !!below.value,
        [`${pre}-zero-width`]: parseFloat(siderWidth) === 0
      }, attrs.class);
      return createVNode("aside", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": siderCls,
        "style": divStyle
      }), [createVNode("div", {
        "class": `${pre}-children`
      }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)]), collapsible || below.value && zeroWidthTrigger ? triggerDom : null]);
    };
  }
});

// node_modules/ant-design-vue/es/layout/index.js
var LayoutHeader = Header2;
var LayoutFooter = Footer;
var LayoutSider = Sider_default;
var LayoutContent = Content;
var layout_default2 = _extends(layout_default, {
  Header: Header2,
  Footer,
  Content,
  Sider: Sider_default,
  install: (app) => {
    app.component(layout_default.name, layout_default);
    app.component(Header2.name, Header2);
    app.component(Footer.name, Footer);
    app.component(Sider_default.name, Sider_default);
    app.component(Content.name, Content);
    return app;
  }
});

// node_modules/ant-design-vue/es/list/ItemMeta.js
var listItemMetaProps = () => ({
  avatar: vue_types_default.any,
  description: vue_types_default.any,
  prefixCls: String,
  title: vue_types_default.any
});
var ItemMeta_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AListItemMeta",
  props: listItemMetaProps(),
  displayName: "AListItemMeta",
  __ANT_LIST_ITEM_META: true,
  slots: Object,
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("list", props2);
    return () => {
      var _a2, _b, _c, _d, _e, _f;
      const classString = `${prefixCls.value}-item-meta`;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      const description = (_c = props2.description) !== null && _c !== void 0 ? _c : (_d = slots.description) === null || _d === void 0 ? void 0 : _d.call(slots);
      const avatar = (_e = props2.avatar) !== null && _e !== void 0 ? _e : (_f = slots.avatar) === null || _f === void 0 ? void 0 : _f.call(slots);
      const content = createVNode("div", {
        "class": `${prefixCls.value}-item-meta-content`
      }, [title && createVNode("h4", {
        "class": `${prefixCls.value}-item-meta-title`
      }, [title]), description && createVNode("div", {
        "class": `${prefixCls.value}-item-meta-description`
      }, [description])]);
      return createVNode("div", {
        "class": classString
      }, [avatar && createVNode("div", {
        "class": `${prefixCls.value}-item-meta-avatar`
      }, [avatar]), (title || description) && content]);
    };
  }
});

// node_modules/ant-design-vue/es/list/contextKey.js
var ListContextKey = Symbol("ListContextKey");

// node_modules/ant-design-vue/es/list/Item.js
var __rest19 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var listItemProps = () => ({
  prefixCls: String,
  extra: vue_types_default.any,
  actions: vue_types_default.array,
  grid: Object,
  colStyle: {
    type: Object,
    default: void 0
  }
});
var Item_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AListItem",
  inheritAttrs: false,
  Meta: ItemMeta_default,
  props: listItemProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      itemLayout,
      grid
    } = inject(ListContextKey, {
      grid: ref(),
      itemLayout: ref()
    });
    const {
      prefixCls
    } = useConfigInject_default("list", props2);
    const isItemContainsTextNodeAndNotSingular = () => {
      var _a2;
      const children = ((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || [];
      let result;
      children.forEach((element) => {
        if (isStringElement(element) && !isEmptyElement(element)) {
          result = true;
        }
      });
      return result && children.length > 1;
    };
    const isFlexMode = () => {
      var _a2, _b;
      const extra = (_a2 = props2.extra) !== null && _a2 !== void 0 ? _a2 : (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots);
      if (itemLayout.value === "vertical") {
        return !!extra;
      }
      return !isItemContainsTextNodeAndNotSingular();
    };
    return () => {
      var _a2, _b, _c, _d, _e;
      const {
        class: className
      } = attrs, restAttrs = __rest19(attrs, ["class"]);
      const pre = prefixCls.value;
      const extra = (_a2 = props2.extra) !== null && _a2 !== void 0 ? _a2 : (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots);
      const children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      let actions = (_d = props2.actions) !== null && _d !== void 0 ? _d : flattenChildren((_e = slots.actions) === null || _e === void 0 ? void 0 : _e.call(slots));
      actions = actions && !Array.isArray(actions) ? [actions] : actions;
      const actionsContent = actions && actions.length > 0 && createVNode("ul", {
        "class": `${pre}-item-action`,
        "key": "actions"
      }, [actions.map((action, i) => createVNode("li", {
        "key": `${pre}-item-action-${i}`
      }, [action, i !== actions.length - 1 && createVNode("em", {
        "class": `${pre}-item-action-split`
      }, null)]))]);
      const Element2 = grid.value ? "div" : "li";
      const itemChildren = createVNode(Element2, _objectSpread2(_objectSpread2({}, restAttrs), {}, {
        "class": classNames_default(`${pre}-item`, {
          [`${pre}-item-no-flex`]: !isFlexMode()
        }, className)
      }), {
        default: () => [itemLayout.value === "vertical" && extra ? [createVNode("div", {
          "class": `${pre}-item-main`,
          "key": "content"
        }, [children, actionsContent]), createVNode("div", {
          "class": `${pre}-item-extra`,
          "key": "extra"
        }, [extra])] : [children, actionsContent, cloneElement(extra, {
          key: "extra"
        })]]
      });
      return grid.value ? createVNode(Col_default, {
        "flex": 1,
        "style": props2.colStyle
      }, {
        default: () => [itemChildren]
      }) : itemChildren;
    };
  }
});

// node_modules/ant-design-vue/es/list/style/index.js
var genBorderedStyle2 = (token) => {
  const {
    listBorderedCls,
    componentCls,
    paddingLG,
    margin,
    padding,
    listItemPaddingSM,
    marginLG,
    borderRadiusLG
  } = token;
  return {
    [`${listBorderedCls}`]: {
      border: `${token.lineWidth}px ${token.lineType} ${token.colorBorder}`,
      borderRadius: borderRadiusLG,
      [`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: {
        paddingInline: paddingLG
      },
      [`${componentCls}-pagination`]: {
        margin: `${margin}px ${marginLG}px`
      }
    },
    [`${listBorderedCls}${componentCls}-sm`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: listItemPaddingSM
      }
    },
    [`${listBorderedCls}${componentCls}-lg`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: `${padding}px ${paddingLG}px`
      }
    }
  };
};
var genResponsiveStyle = (token) => {
  const {
    componentCls,
    screenSM,
    screenMD,
    marginLG,
    marginSM,
    margin
  } = token;
  return {
    [`@media screen and (max-width:${screenMD})`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-action`]: {
            marginInlineStart: marginLG
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-extra`]: {
            marginInlineStart: marginLG
          }
        }
      }
    },
    [`@media screen and (max-width: ${screenSM})`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap",
          [`${componentCls}-action`]: {
            marginInlineStart: marginSM
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap-reverse",
          [`${componentCls}-item-main`]: {
            minWidth: token.contentWidth
          },
          [`${componentCls}-item-extra`]: {
            margin: `auto auto ${margin}px`
          }
        }
      }
    }
  };
};
var genBaseStyle7 = (token) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    minHeight,
    paddingSM,
    marginLG,
    padding,
    listItemPadding,
    colorPrimary,
    listItemPaddingSM,
    listItemPaddingLG,
    paddingXS,
    margin,
    colorText,
    colorTextDescription,
    motionDurationSlow,
    lineWidth
  } = token;
  return {
    [`${componentCls}`]: _extends(_extends({}, resetComponent(token)), {
      position: "relative",
      "*": {
        outline: "none"
      },
      [`${componentCls}-header, ${componentCls}-footer`]: {
        background: "transparent",
        paddingBlock: paddingSM
      },
      [`${componentCls}-pagination`]: {
        marginBlockStart: marginLG,
        textAlign: "end",
        // https://github.com/ant-design/ant-design/issues/20037
        [`${antCls}-pagination-options`]: {
          textAlign: "start"
        }
      },
      [`${componentCls}-spin`]: {
        minHeight,
        textAlign: "center"
      },
      [`${componentCls}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${componentCls}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: listItemPadding,
        color: colorText,
        [`${componentCls}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${componentCls}-item-meta-avatar`]: {
            marginInlineEnd: padding
          },
          [`${componentCls}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: colorText
          },
          [`${componentCls}-item-meta-title`]: {
            marginBottom: token.marginXXS,
            color: colorText,
            fontSize: token.fontSize,
            lineHeight: token.lineHeight,
            "> a": {
              color: colorText,
              transition: `all ${motionDurationSlow}`,
              [`&:hover`]: {
                color: colorPrimary
              }
            }
          },
          [`${componentCls}-item-meta-description`]: {
            color: colorTextDescription,
            fontSize: token.fontSize,
            lineHeight: token.lineHeight
          }
        },
        [`${componentCls}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: token.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          [`& > li`]: {
            position: "relative",
            display: "inline-block",
            padding: `0 ${paddingXS}px`,
            color: colorTextDescription,
            fontSize: token.fontSize,
            lineHeight: token.lineHeight,
            textAlign: "center",
            [`&:first-child`]: {
              paddingInlineStart: 0
            }
          },
          [`${componentCls}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: lineWidth,
            height: Math.ceil(token.fontSize * token.lineHeight) - token.marginXXS * 2,
            transform: "translateY(-50%)",
            backgroundColor: token.colorSplit
          }
        }
      },
      [`${componentCls}-empty`]: {
        padding: `${padding}px 0`,
        color: colorTextDescription,
        fontSize: token.fontSizeSM,
        textAlign: "center"
      },
      [`${componentCls}-empty-text`]: {
        padding,
        color: token.colorTextDisabled,
        fontSize: token.fontSize,
        textAlign: "center"
      },
      // ============================ without flex ============================
      [`${componentCls}-item-no-flex`]: {
        display: "block"
      }
    }),
    [`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: margin,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${componentCls}-vertical ${componentCls}-item`]: {
      alignItems: "initial",
      [`${componentCls}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${componentCls}-item-extra`]: {
        marginInlineStart: marginLG
      },
      [`${componentCls}-item-meta`]: {
        marginBlockEnd: padding,
        [`${componentCls}-item-meta-title`]: {
          marginBlockEnd: paddingSM,
          color: colorText,
          fontSize: token.fontSizeLG,
          lineHeight: token.lineHeightLG
        }
      },
      [`${componentCls}-item-action`]: {
        marginBlockStart: padding,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${padding}px`,
          [`&:first-child`]: {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${componentCls}-split ${componentCls}-item`]: {
      borderBlockEnd: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`,
      [`&:last-child`]: {
        borderBlockEnd: "none"
      }
    },
    [`${componentCls}-split ${componentCls}-header`]: {
      borderBlockEnd: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`
    },
    [`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: {
      borderTop: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`
    },
    [`${componentCls}-loading ${componentCls}-spin-nested-loading`]: {
      minHeight: controlHeight
    },
    [`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: {
      borderBlockEnd: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`
    },
    [`${componentCls}-lg ${componentCls}-item`]: {
      padding: listItemPaddingLG
    },
    [`${componentCls}-sm ${componentCls}-item`]: {
      padding: listItemPaddingSM
    },
    // Horizontal
    [`${componentCls}:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-no-flex`]: {
        [`${componentCls}-item-action`]: {
          float: "right"
        }
      }
    }
  };
};
var style_default23 = genComponentStyleHook("List", (token) => {
  const listToken = merge(token, {
    listBorderedCls: `${token.componentCls}-bordered`,
    minHeight: token.controlHeightLG,
    listItemPadding: `${token.paddingContentVertical}px ${token.paddingContentHorizontalLG}px`,
    listItemPaddingSM: `${token.paddingContentVerticalSM}px ${token.paddingContentHorizontal}px`,
    listItemPaddingLG: `${token.paddingContentVerticalLG}px ${token.paddingContentHorizontalLG}px`
  });
  return [genBaseStyle7(listToken), genBorderedStyle2(listToken), genResponsiveStyle(listToken)];
}, {
  contentWidth: 220
});

// node_modules/ant-design-vue/es/list/index.js
var listProps = () => ({
  bordered: booleanType(),
  dataSource: arrayType(),
  extra: vNodeType(),
  grid: objectType(),
  itemLayout: String,
  loading: someType([Boolean, Object]),
  loadMore: vNodeType(),
  pagination: someType([Boolean, Object]),
  prefixCls: String,
  rowKey: someType([String, Number, Function]),
  renderItem: functionType(),
  size: String,
  split: booleanType(),
  header: vNodeType(),
  footer: vNodeType(),
  locale: objectType()
});
var List = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AList",
  inheritAttrs: false,
  Item: Item_default,
  props: initDefaultProps_default(listProps(), {
    dataSource: [],
    bordered: false,
    split: true,
    loading: false,
    pagination: false
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    var _a2, _b;
    provide(ListContextKey, {
      grid: toRef(props2, "grid"),
      itemLayout: toRef(props2, "itemLayout")
    });
    const defaultPaginationProps = {
      current: 1,
      total: 0
    };
    const {
      prefixCls,
      direction,
      renderEmpty
    } = useConfigInject_default("list", props2);
    const [wrapSSR, hashId] = style_default23(prefixCls);
    const paginationObj = computed(() => props2.pagination && typeof props2.pagination === "object" ? props2.pagination : {});
    const paginationCurrent = ref((_a2 = paginationObj.value.defaultCurrent) !== null && _a2 !== void 0 ? _a2 : 1);
    const paginationSize = ref((_b = paginationObj.value.defaultPageSize) !== null && _b !== void 0 ? _b : 10);
    watch(paginationObj, () => {
      if ("current" in paginationObj.value) {
        paginationCurrent.value = paginationObj.value.current;
      }
      if ("pageSize" in paginationObj.value) {
        paginationSize.value = paginationObj.value.pageSize;
      }
    });
    const listItemsKeys = [];
    const triggerPaginationEvent = (eventName) => (page, pageSize) => {
      paginationCurrent.value = page;
      paginationSize.value = pageSize;
      if (paginationObj.value[eventName]) {
        paginationObj.value[eventName](page, pageSize);
      }
    };
    const onPaginationChange = triggerPaginationEvent("onChange");
    const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
    const loadingProp = computed(() => {
      if (typeof props2.loading === "boolean") {
        return {
          spinning: props2.loading
        };
      } else {
        return props2.loading;
      }
    });
    const isLoading = computed(() => loadingProp.value && loadingProp.value.spinning);
    const sizeCls = computed(() => {
      let size = "";
      switch (props2.size) {
        case "large":
          size = "lg";
          break;
        case "small":
          size = "sm";
          break;
        default:
          break;
      }
      return size;
    });
    const classObj = computed(() => ({
      [`${prefixCls.value}`]: true,
      [`${prefixCls.value}-vertical`]: props2.itemLayout === "vertical",
      [`${prefixCls.value}-${sizeCls.value}`]: sizeCls.value,
      [`${prefixCls.value}-split`]: props2.split,
      [`${prefixCls.value}-bordered`]: props2.bordered,
      [`${prefixCls.value}-loading`]: isLoading.value,
      [`${prefixCls.value}-grid`]: !!props2.grid,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl"
    }));
    const paginationProps = computed(() => {
      const pp = _extends(_extends(_extends({}, defaultPaginationProps), {
        total: props2.dataSource.length,
        current: paginationCurrent.value,
        pageSize: paginationSize.value
      }), props2.pagination || {});
      const largestPage = Math.ceil(pp.total / pp.pageSize);
      if (pp.current > largestPage) {
        pp.current = largestPage;
      }
      return pp;
    });
    const splitDataSource = computed(() => {
      let dd = [...props2.dataSource];
      if (props2.pagination) {
        if (props2.dataSource.length > (paginationProps.value.current - 1) * paginationProps.value.pageSize) {
          dd = [...props2.dataSource].splice((paginationProps.value.current - 1) * paginationProps.value.pageSize, paginationProps.value.pageSize);
        }
      }
      return dd;
    });
    const screens = useBreakpoint_default();
    const currentBreakpoint = eagerComputed(() => {
      for (let i = 0; i < responsiveArray.length; i += 1) {
        const breakpoint = responsiveArray[i];
        if (screens.value[breakpoint]) {
          return breakpoint;
        }
      }
      return void 0;
    });
    const colStyle = computed(() => {
      if (!props2.grid) {
        return void 0;
      }
      const columnCount = currentBreakpoint.value && props2.grid[currentBreakpoint.value] ? props2.grid[currentBreakpoint.value] : props2.grid.column;
      if (columnCount) {
        return {
          width: `${100 / columnCount}%`,
          maxWidth: `${100 / columnCount}%`
        };
      }
      return void 0;
    });
    const renderInnerItem = (item, index2) => {
      var _a3;
      const renderItem = (_a3 = props2.renderItem) !== null && _a3 !== void 0 ? _a3 : slots.renderItem;
      if (!renderItem)
        return null;
      let key;
      const rowKeyType = typeof props2.rowKey;
      if (rowKeyType === "function") {
        key = props2.rowKey(item);
      } else if (rowKeyType === "string" || rowKeyType === "number") {
        key = item[props2.rowKey];
      } else {
        key = item.key;
      }
      if (!key) {
        key = `list-item-${index2}`;
      }
      listItemsKeys[index2] = key;
      return renderItem({
        item,
        index: index2
      });
    };
    return () => {
      var _a3, _b2, _c, _d, _e, _f, _g, _h;
      const loadMore = (_a3 = props2.loadMore) !== null && _a3 !== void 0 ? _a3 : (_b2 = slots.loadMore) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
      const footer = (_c = props2.footer) !== null && _c !== void 0 ? _c : (_d = slots.footer) === null || _d === void 0 ? void 0 : _d.call(slots);
      const header = (_e = props2.header) !== null && _e !== void 0 ? _e : (_f = slots.header) === null || _f === void 0 ? void 0 : _f.call(slots);
      const children = flattenChildren((_g = slots.default) === null || _g === void 0 ? void 0 : _g.call(slots));
      const isSomethingAfterLastItem = !!(loadMore || props2.pagination || footer);
      const classString = classNames_default(_extends(_extends({}, classObj.value), {
        [`${prefixCls.value}-something-after-last-item`]: isSomethingAfterLastItem
      }), attrs.class, hashId.value);
      const paginationContent = props2.pagination ? createVNode("div", {
        "class": `${prefixCls.value}-pagination`
      }, [createVNode(pagination_default, _objectSpread2(_objectSpread2({}, paginationProps.value), {}, {
        "onChange": onPaginationChange,
        "onShowSizeChange": onPaginationShowSizeChange
      }), null)]) : null;
      let childrenContent = isLoading.value && createVNode("div", {
        "style": {
          minHeight: "53px"
        }
      }, null);
      if (splitDataSource.value.length > 0) {
        listItemsKeys.length = 0;
        const items = splitDataSource.value.map((item, index2) => renderInnerItem(item, index2));
        const childrenList = items.map((child, index2) => createVNode("div", {
          "key": listItemsKeys[index2],
          "style": colStyle.value
        }, [child]));
        childrenContent = props2.grid ? createVNode(Row_default, {
          "gutter": props2.grid.gutter
        }, {
          default: () => [childrenList]
        }) : createVNode("ul", {
          "class": `${prefixCls.value}-items`
        }, [items]);
      } else if (!children.length && !isLoading.value) {
        childrenContent = createVNode("div", {
          "class": `${prefixCls.value}-empty-text`
        }, [((_h = props2.locale) === null || _h === void 0 ? void 0 : _h.emptyText) || renderEmpty("List")]);
      }
      const paginationPosition = paginationProps.value.position || "bottom";
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": classString
      }), [(paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && createVNode("div", {
        "class": `${prefixCls.value}-header`
      }, [header]), createVNode(spin_default, loadingProp.value, {
        default: () => [childrenContent, children]
      }), footer && createVNode("div", {
        "class": `${prefixCls.value}-footer`
      }, [footer]), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent]));
    };
  }
});
List.install = function(app) {
  app.component(List.name, List);
  app.component(List.Item.name, List.Item);
  app.component(List.Item.Meta.name, List.Item.Meta);
  return app;
};
var list_default = List;

// node_modules/ant-design-vue/es/vc-mentions/src/util.js
function getBeforeSelectionText(input) {
  const {
    selectionStart
  } = input;
  return input.value.slice(0, selectionStart);
}
function getLastMeasureIndex(text) {
  let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const prefixList = Array.isArray(prefix) ? prefix : [prefix];
  return prefixList.reduce((lastMatch, prefixStr) => {
    const lastIndex = text.lastIndexOf(prefixStr);
    if (lastIndex > lastMatch.location) {
      return {
        location: lastIndex,
        prefix: prefixStr
      };
    }
    return lastMatch;
  }, {
    location: -1,
    prefix: ""
  });
}
function lower(char) {
  return (char || "").toLowerCase();
}
function reduceText(text, targetText, split) {
  const firstChar = text[0];
  if (!firstChar || firstChar === split) {
    return text;
  }
  let restText = text;
  const targetTextLen = targetText.length;
  for (let i = 0; i < targetTextLen; i += 1) {
    if (lower(restText[i]) !== lower(targetText[i])) {
      restText = restText.slice(i);
      break;
    } else if (i === targetTextLen - 1) {
      restText = restText.slice(targetTextLen);
    }
  }
  return restText;
}
function replaceWithMeasure(text, measureConfig) {
  const {
    measureLocation,
    prefix,
    targetText,
    selectionStart,
    split
  } = measureConfig;
  let beforeMeasureText = text.slice(0, measureLocation);
  if (beforeMeasureText[beforeMeasureText.length - split.length] === split) {
    beforeMeasureText = beforeMeasureText.slice(0, beforeMeasureText.length - split.length);
  }
  if (beforeMeasureText) {
    beforeMeasureText = `${beforeMeasureText}${split}`;
  }
  let restText = reduceText(text.slice(selectionStart), targetText.slice(selectionStart - measureLocation - prefix.length), split);
  if (restText.slice(0, split.length) === split) {
    restText = restText.slice(split.length);
  }
  const connectedStartText = `${beforeMeasureText}${prefix}${targetText}${split}`;
  return {
    text: `${connectedStartText}${restText}`,
    selectionLocation: connectedStartText.length
  };
}
function setInputSelection(input, location) {
  input.setSelectionRange(location, location);
  input.blur();
  input.focus();
}
function validateSearch(text, props2) {
  const {
    split
  } = props2;
  return !split || text.indexOf(split) === -1;
}
function filterOption(input, _ref) {
  let {
    value = ""
  } = _ref;
  const lowerCase = input.toLowerCase();
  return value.toLowerCase().indexOf(lowerCase) !== -1;
}

// node_modules/ant-design-vue/es/vc-mentions/src/MentionsContext.js
var MentionsContextKey = Symbol("MentionsContextKey");
var MentionsContext_default = MentionsContextKey;

// node_modules/ant-design-vue/es/vc-mentions/src/DropdownMenu.js
function noop4() {
}
var DropdownMenu_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DropdownMenu",
  props: {
    prefixCls: String,
    options: {
      type: Array,
      default: () => []
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      activeIndex,
      setActiveIndex,
      selectOption,
      onFocus = noop4,
      loading
    } = inject(MentionsContext_default, {
      activeIndex: shallowRef(),
      loading: shallowRef(false)
    });
    let timeoutId;
    const onMousedown = (e) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        onFocus(e);
      });
    };
    onBeforeUnmount(() => {
      clearTimeout(timeoutId);
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        options
      } = props2;
      const activeOption = options[activeIndex.value] || {};
      return createVNode(menu_default, {
        "prefixCls": `${prefixCls}-menu`,
        "activeKey": activeOption.value,
        "onSelect": (_ref2) => {
          let {
            key
          } = _ref2;
          const option = options.find((_ref3) => {
            let {
              value
            } = _ref3;
            return value === key;
          });
          selectOption(option);
        },
        "onMousedown": onMousedown
      }, {
        default: () => [!loading.value && options.map((option, index2) => {
          var _a3, _b;
          const {
            value,
            disabled,
            label = option.value,
            class: className,
            style
          } = option;
          return createVNode(MenuItem_default, {
            "key": value,
            "disabled": disabled,
            "onMouseenter": () => {
              setActiveIndex(index2);
            },
            "class": className,
            "style": style
          }, {
            default: () => [(_b = (_a3 = slots.option) === null || _a3 === void 0 ? void 0 : _a3.call(slots, option)) !== null && _b !== void 0 ? _b : typeof label === "function" ? label(option) : label]
          });
        }), !loading.value && options.length === 0 ? createVNode(MenuItem_default, {
          "key": "notFoundContent",
          "disabled": true
        }, {
          default: () => [(_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
        }) : null, loading.value && createVNode(MenuItem_default, {
          "key": "loading",
          "disabled": true
        }, {
          default: () => [createVNode(spin_default, {
            "size": "small"
          }, null)]
        })]
      });
    };
  }
});

// node_modules/ant-design-vue/es/vc-mentions/src/KeywordTrigger.js
var BUILT_IN_PLACEMENTS2 = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
var KeywordTrigger_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "KeywordTrigger",
  props: {
    loading: {
      type: Boolean,
      default: void 0
    },
    options: {
      type: Array,
      default: () => []
    },
    prefixCls: String,
    placement: String,
    visible: {
      type: Boolean,
      default: void 0
    },
    transitionName: String,
    getPopupContainer: Function,
    direction: String,
    dropdownClassName: String
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const getDropdownPrefix = () => {
      return `${props2.prefixCls}-dropdown`;
    };
    const getDropdownElement = () => {
      const {
        options
      } = props2;
      return createVNode(DropdownMenu_default, {
        "prefixCls": getDropdownPrefix(),
        "options": options
      }, {
        notFoundContent: slots.notFoundContent,
        option: slots.option
      });
    };
    const popupPlacement = computed(() => {
      const {
        placement,
        direction
      } = props2;
      let popupPlacement2 = "topRight";
      if (direction === "rtl") {
        popupPlacement2 = placement === "top" ? "topLeft" : "bottomLeft";
      } else {
        popupPlacement2 = placement === "top" ? "topRight" : "bottomRight";
      }
      return popupPlacement2;
    });
    return () => {
      const {
        visible,
        transitionName,
        getPopupContainer
      } = props2;
      return createVNode(vc_trigger_default, {
        "prefixCls": getDropdownPrefix(),
        "popupVisible": visible,
        "popup": getDropdownElement(),
        "popupClassName": props2.dropdownClassName,
        "popupPlacement": popupPlacement.value,
        "popupTransitionName": transitionName,
        "builtinPlacements": BUILT_IN_PLACEMENTS2,
        "getPopupContainer": getPopupContainer
      }, {
        default: slots.default
      });
    };
  }
});

// node_modules/ant-design-vue/es/vc-mentions/src/mentionsProps.js
var PlaceMent = tuple("top", "bottom");
var mentionsProps = {
  autofocus: {
    type: Boolean,
    default: void 0
  },
  prefix: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.arrayOf(vue_types_default.string)]),
  prefixCls: String,
  value: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  split: String,
  transitionName: String,
  placement: vue_types_default.oneOf(PlaceMent),
  character: vue_types_default.any,
  characterRender: Function,
  filterOption: {
    type: [Boolean, Function]
  },
  validateSearch: Function,
  getPopupContainer: {
    type: Function
  },
  options: arrayType(),
  loading: {
    type: Boolean,
    default: void 0
  },
  rows: [Number, String],
  direction: {
    type: String
  }
};
var vcMentionsProps = _extends(_extends({}, mentionsProps), {
  dropdownClassName: String
});
var defaultProps2 = {
  prefix: "@",
  split: " ",
  rows: 1,
  validateSearch,
  filterOption: () => filterOption
};
var mentionsProps_default = initDefaultProps_default(vcMentionsProps, defaultProps2);

// node_modules/ant-design-vue/es/vc-mentions/src/Mentions.js
var __rest20 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function noop5() {
}
var Mentions_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Mentions",
  inheritAttrs: false,
  props: initDefaultProps_default(vcMentionsProps, defaultProps2),
  emits: ["change", "select", "search", "focus", "blur", "pressenter"],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      expose,
      slots
    } = _ref;
    const measure = ref(null);
    const textarea = ref(null);
    const focusId = ref();
    const state = reactive({
      value: props2.value || "",
      measuring: false,
      measureLocation: 0,
      measureText: null,
      measurePrefix: "",
      activeIndex: 0,
      isFocus: false
    });
    watchEffect(() => {
      state.value = props2.value;
    });
    const triggerChange = (val) => {
      emit("change", val);
    };
    const onChange = (_ref2) => {
      let {
        target: {
          value
        }
      } = _ref2;
      triggerChange(value);
    };
    const startMeasure = (measureText, measurePrefix, measureLocation) => {
      _extends(state, {
        measuring: true,
        measureText,
        measurePrefix,
        measureLocation,
        activeIndex: 0
      });
    };
    const stopMeasure = (callback) => {
      _extends(state, {
        measuring: false,
        measureLocation: 0,
        measureText: null
      });
      callback === null || callback === void 0 ? void 0 : callback();
    };
    const onKeyDown = (event) => {
      const {
        which
      } = event;
      if (!state.measuring) {
        return;
      }
      if (which === KeyCode_default.UP || which === KeyCode_default.DOWN) {
        const optionLen = options.value.length;
        const offset = which === KeyCode_default.UP ? -1 : 1;
        const newActiveIndex = (state.activeIndex + offset + optionLen) % optionLen;
        state.activeIndex = newActiveIndex;
        event.preventDefault();
      } else if (which === KeyCode_default.ESC) {
        stopMeasure();
      } else if (which === KeyCode_default.ENTER) {
        event.preventDefault();
        if (!options.value.length) {
          stopMeasure();
          return;
        }
        const option = options.value[state.activeIndex];
        selectOption(option);
      }
    };
    const onKeyUp = (event) => {
      const {
        key,
        which
      } = event;
      const {
        measureText: prevMeasureText,
        measuring
      } = state;
      const {
        prefix,
        validateSearch: validateSearch2
      } = props2;
      const target = event.target;
      if (target.composing) {
        return;
      }
      const selectionStartText = getBeforeSelectionText(target);
      const {
        location: measureIndex,
        prefix: measurePrefix
      } = getLastMeasureIndex(selectionStartText, prefix);
      if ([KeyCode_default.ESC, KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.ENTER].indexOf(which) !== -1) {
        return;
      }
      if (measureIndex !== -1) {
        const measureText = selectionStartText.slice(measureIndex + measurePrefix.length);
        const validateMeasure = validateSearch2(measureText, props2);
        const matchOption = !!getOptions(measureText).length;
        if (validateMeasure) {
          if (key === measurePrefix || key === "Shift" || measuring || measureText !== prevMeasureText && matchOption) {
            startMeasure(measureText, measurePrefix, measureIndex);
          }
        } else if (measuring) {
          stopMeasure();
        }
        if (validateMeasure) {
          emit("search", measureText, measurePrefix);
        }
      } else if (measuring) {
        stopMeasure();
      }
    };
    const onPressEnter = (event) => {
      if (!state.measuring) {
        emit("pressenter", event);
      }
    };
    const onInputFocus = (event) => {
      onFocus(event);
    };
    const onInputBlur = (event) => {
      onBlur(event);
    };
    const onFocus = (event) => {
      clearTimeout(focusId.value);
      const {
        isFocus
      } = state;
      if (!isFocus && event) {
        emit("focus", event);
      }
      state.isFocus = true;
    };
    const onBlur = (event) => {
      focusId.value = setTimeout(() => {
        state.isFocus = false;
        stopMeasure();
        emit("blur", event);
      }, 100);
    };
    const selectOption = (option) => {
      const {
        split
      } = props2;
      const {
        value: mentionValue = ""
      } = option;
      const {
        text,
        selectionLocation
      } = replaceWithMeasure(state.value, {
        measureLocation: state.measureLocation,
        targetText: mentionValue,
        prefix: state.measurePrefix,
        selectionStart: textarea.value.getSelectionStart(),
        split
      });
      triggerChange(text);
      stopMeasure(() => {
        setInputSelection(textarea.value.input, selectionLocation);
      });
      emit("select", option, state.measurePrefix);
    };
    const setActiveIndex = (activeIndex) => {
      state.activeIndex = activeIndex;
    };
    const getOptions = (measureText) => {
      const targetMeasureText = measureText || state.measureText || "";
      const {
        filterOption: filterOption2
      } = props2;
      const list = props2.options.filter((option) => {
        if (!!filterOption2 === false) {
          return true;
        }
        return filterOption2(targetMeasureText, option);
      });
      return list;
    };
    const options = computed(() => {
      return getOptions();
    });
    const focus = () => {
      textarea.value.focus();
    };
    const blur = () => {
      textarea.value.blur();
    };
    expose({
      blur,
      focus
    });
    provide(MentionsContext_default, {
      activeIndex: toRef(state, "activeIndex"),
      setActiveIndex,
      selectOption,
      onFocus,
      onBlur,
      loading: toRef(props2, "loading")
    });
    onUpdated(() => {
      nextTick(() => {
        if (state.measuring) {
          measure.value.scrollTop = textarea.value.getScrollTop();
        }
      });
    });
    return () => {
      const {
        measureLocation,
        measurePrefix,
        measuring
      } = state;
      const {
        prefixCls,
        placement,
        transitionName,
        getPopupContainer,
        direction
      } = props2, restProps = __rest20(props2, ["prefixCls", "placement", "transitionName", "getPopupContainer", "direction"]);
      const {
        class: className,
        style
      } = attrs, otherAttrs = __rest20(attrs, ["class", "style"]);
      const inputProps = omit_default(restProps, ["value", "prefix", "split", "validateSearch", "filterOption", "options", "loading"]);
      const textareaProps = _extends(_extends(_extends({}, inputProps), otherAttrs), {
        onChange: noop5,
        onSelect: noop5,
        value: state.value,
        onInput: onChange,
        onBlur: onInputBlur,
        onKeydown: onKeyDown,
        onKeyup: onKeyUp,
        onFocus: onInputFocus,
        onPressenter: onPressEnter
      });
      return createVNode("div", {
        "class": classNames_default(prefixCls, className),
        "style": style
      }, [createVNode(BaseInput_default, _objectSpread2(_objectSpread2({}, textareaProps), {}, {
        "ref": textarea,
        "tag": "textarea"
      }), null), measuring && createVNode("div", {
        "ref": measure,
        "class": `${prefixCls}-measure`
      }, [state.value.slice(0, measureLocation), createVNode(KeywordTrigger_default, {
        "prefixCls": prefixCls,
        "transitionName": transitionName,
        "dropdownClassName": props2.dropdownClassName,
        "placement": placement,
        "options": measuring ? options.value : [],
        "visible": true,
        "direction": direction,
        "getPopupContainer": getPopupContainer
      }, {
        default: () => [createVNode("span", null, [measurePrefix])],
        notFoundContent: slots.notFoundContent,
        option: slots.option
      }), state.value.slice(measureLocation + measurePrefix.length)])]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-mentions/src/Option.js
var baseOptionsProps = {
  value: String,
  disabled: Boolean,
  payload: objectType()
};
var optionProps = _extends(_extends({}, baseOptionsProps), {
  label: anyType([])
});
var optionOptions = {
  name: "Option",
  props: optionProps,
  render(_props, _ref) {
    let {
      slots
    } = _ref;
    var _a2;
    return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
  }
};
var Option_default2 = defineComponent(_extends({
  compatConfig: {
    MODE: 3
  }
}, optionOptions));

// node_modules/ant-design-vue/es/vc-mentions/index.js
var vc_mentions_default = Mentions_default;

// node_modules/ant-design-vue/es/mentions/style/index.js
var genMentionsStyle = (token) => {
  const {
    componentCls,
    colorTextDisabled,
    controlItemBgHover,
    controlPaddingHorizontal,
    colorText,
    motionDurationSlow,
    lineHeight,
    controlHeight,
    inputPaddingHorizontal,
    inputPaddingVertical,
    fontSize,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary
  } = token;
  const itemPaddingVertical = Math.round((token.controlHeight - token.fontSize * token.lineHeight) / 2);
  return {
    [componentCls]: _extends(_extends(_extends(_extends(_extends({}, resetComponent(token)), genBasicInputStyle(token)), {
      position: "relative",
      display: "inline-block",
      height: "auto",
      padding: 0,
      overflow: "hidden",
      lineHeight,
      whiteSpace: "pre-wrap",
      verticalAlign: "bottom"
    }), genStatusStyle(token, componentCls)), {
      "&-disabled": {
        "> textarea": _extends({}, genDisabledStyle(token))
      },
      "&-focused": _extends({}, genActiveStyle(token)),
      [`&-affix-wrapper ${componentCls}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: inputPaddingHorizontal,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      // ================= Input Area =================
      [`> textarea, ${componentCls}-measure`]: {
        color: colorText,
        boxSizing: "border-box",
        minHeight: controlHeight - 2,
        margin: 0,
        padding: `${inputPaddingVertical}px ${inputPaddingHorizontal}px`,
        overflow: "inherit",
        overflowX: "hidden",
        overflowY: "auto",
        fontWeight: "inherit",
        fontSize: "inherit",
        fontFamily: "inherit",
        fontStyle: "inherit",
        fontVariant: "inherit",
        fontSizeAdjust: "inherit",
        fontStretch: "inherit",
        lineHeight: "inherit",
        direction: "inherit",
        letterSpacing: "inherit",
        whiteSpace: "inherit",
        textAlign: "inherit",
        verticalAlign: "top",
        wordWrap: "break-word",
        wordBreak: "inherit",
        tabSize: "inherit"
      },
      "> textarea": _extends({
        width: "100%",
        border: "none",
        outline: "none",
        resize: "none",
        backgroundColor: "inherit"
      }, genPlaceholderStyle(token.colorTextPlaceholder)),
      [`${componentCls}-measure`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: -1,
        color: "transparent",
        pointerEvents: "none",
        "> span": {
          display: "inline-block",
          minHeight: "1em"
        }
      },
      // ================== Dropdown ==================
      "&-dropdown": _extends(_extends({}, resetComponent(token)), {
        position: "absolute",
        top: -9999,
        insetInlineStart: -9999,
        zIndex: token.zIndexPopup,
        boxSizing: "border-box",
        fontSize,
        fontVariant: "initial",
        backgroundColor: colorBgElevated,
        borderRadius: borderRadiusLG,
        outline: "none",
        boxShadow: boxShadowSecondary,
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-dropdown-menu`]: {
          maxHeight: token.dropdownHeight,
          marginBottom: 0,
          paddingInlineStart: 0,
          overflow: "auto",
          listStyle: "none",
          outline: "none",
          "&-item": _extends(_extends({}, textEllipsis), {
            position: "relative",
            display: "block",
            minWidth: token.controlItemWidth,
            padding: `${itemPaddingVertical}px ${controlPaddingHorizontal}px`,
            color: colorText,
            fontWeight: "normal",
            lineHeight,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&:hover": {
              backgroundColor: controlItemBgHover
            },
            "&:first-child": {
              borderStartStartRadius: borderRadiusLG,
              borderStartEndRadius: borderRadiusLG,
              borderEndStartRadius: 0,
              borderEndEndRadius: 0
            },
            "&:last-child": {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0,
              borderEndStartRadius: borderRadiusLG,
              borderEndEndRadius: borderRadiusLG
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: controlItemBgHover,
                cursor: "not-allowed"
              }
            },
            "&-selected": {
              color: colorText,
              fontWeight: token.fontWeightStrong,
              backgroundColor: controlItemBgHover
            },
            "&-active": {
              backgroundColor: controlItemBgHover
            }
          })
        }
      })
    })
  };
};
var style_default24 = genComponentStyleHook("Mentions", (token) => {
  const mentionsToken = initInputToken(token);
  return [genMentionsStyle(mentionsToken)];
}, (token) => ({
  dropdownHeight: 250,
  controlItemWidth: 100,
  zIndexPopup: token.zIndexPopupBase + 50
}));

// node_modules/ant-design-vue/es/mentions/index.js
var __rest21 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function loadingFilterOption() {
  return true;
}
var getMentions = function() {
  let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    prefix = "@",
    split = " "
  } = config;
  const prefixList = Array.isArray(prefix) ? prefix : [prefix];
  return value.split(split).map(function() {
    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let hitPrefix = null;
    prefixList.some((prefixStr) => {
      const startStr = str.slice(0, prefixStr.length);
      if (startStr === prefixStr) {
        hitPrefix = prefixStr;
        return true;
      }
      return false;
    });
    if (hitPrefix !== null) {
      return {
        prefix: hitPrefix,
        value: str.slice(hitPrefix.length)
      };
    }
    return null;
  }).filter((entity) => !!entity && !!entity.value);
};
var mentionsProps2 = () => _extends(_extends({}, mentionsProps), {
  loading: {
    type: Boolean,
    default: void 0
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPressenter: {
    type: Function
  },
  "onUpdate:value": {
    type: Function
  },
  notFoundContent: vue_types_default.any,
  defaultValue: String,
  id: String,
  status: String
});
var Mentions = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMentions",
  inheritAttrs: false,
  props: mentionsProps2(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs,
      expose
    } = _ref;
    var _a2, _b, _c;
    if (true) {
      devWarning_default(!flattenChildren(((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || []).length, "Mentions", "`Mentions.Option` is deprecated. Please use `options` instead.");
    }
    const {
      prefixCls,
      renderEmpty,
      direction
    } = useConfigInject_default("mentions", props2);
    const [wrapSSR, hashId] = style_default24(prefixCls);
    const focused = shallowRef(false);
    const vcMentions = shallowRef(null);
    const value = shallowRef((_c = (_b = props2.value) !== null && _b !== void 0 ? _b : props2.defaultValue) !== null && _c !== void 0 ? _c : "");
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    useProvideOverride({
      prefixCls: computed(() => `${prefixCls.value}-menu`),
      mode: computed(() => "vertical"),
      selectable: computed(() => false),
      onClick: () => {
      },
      validator: (_ref2) => {
        let {
          mode
        } = _ref2;
        warning_default2(!mode || mode === "vertical", "Mentions", `mode="${mode}" is not supported for Mentions's Menu.`);
      }
    });
    watch(() => props2.value, (val) => {
      value.value = val;
    });
    const handleFocus = (e) => {
      focused.value = true;
      emit("focus", e);
    };
    const handleBlur = (e) => {
      focused.value = false;
      emit("blur", e);
      formItemContext.onFieldBlur();
    };
    const handleSelect = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      emit("select", ...args);
      focused.value = true;
    };
    const handleChange = (val) => {
      if (props2.value === void 0) {
        value.value = val;
      }
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    const getNotFoundContent = () => {
      const notFoundContent = props2.notFoundContent;
      if (notFoundContent !== void 0) {
        return notFoundContent;
      }
      if (slots.notFoundContent) {
        return slots.notFoundContent();
      }
      return renderEmpty("Select");
    };
    const getOptions = () => {
      var _a3;
      return flattenChildren(((_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots)) || []).map((item) => {
        var _a4, _b2;
        return _extends(_extends({}, getOptionProps(item)), {
          label: (_b2 = (_a4 = item.children) === null || _a4 === void 0 ? void 0 : _a4.default) === null || _b2 === void 0 ? void 0 : _b2.call(_a4)
        });
      });
    };
    const focus = () => {
      vcMentions.value.focus();
    };
    const blur = () => {
      vcMentions.value.blur();
    };
    expose({
      focus,
      blur
    });
    const mentionsfilterOption = computed(() => props2.loading ? loadingFilterOption : props2.filterOption);
    return () => {
      const {
        disabled,
        getPopupContainer,
        rows = 1,
        id = formItemContext.id.value
      } = props2, restProps = __rest21(props2, ["disabled", "getPopupContainer", "rows", "id"]);
      const {
        hasFeedback,
        feedbackIcon
      } = formItemInputContext;
      const {
        class: className
      } = attrs, otherAttrs = __rest21(attrs, ["class"]);
      const otherProps = omit_default(restProps, ["defaultValue", "onUpdate:value", "prefixCls"]);
      const mergedClassName = classNames_default({
        [`${prefixCls.value}-disabled`]: disabled,
        [`${prefixCls.value}-focused`]: focused.value,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, getStatusClassNames(prefixCls.value, mergedStatus.value), !hasFeedback && className, hashId.value);
      const mentionsProps3 = _extends(_extends(_extends(_extends({
        prefixCls: prefixCls.value
      }, otherProps), {
        disabled,
        direction: direction.value,
        filterOption: mentionsfilterOption.value,
        getPopupContainer,
        options: props2.loading ? [{
          value: "ANTDV_SEARCHING",
          disabled: true,
          label: createVNode(spin_default, {
            "size": "small"
          }, null)
        }] : props2.options || getOptions(),
        class: mergedClassName
      }), otherAttrs), {
        rows,
        onChange: handleChange,
        onSelect: handleSelect,
        onFocus: handleFocus,
        onBlur: handleBlur,
        ref: vcMentions,
        value: value.value,
        id
      });
      const mentions = createVNode(vc_mentions_default, _objectSpread2(_objectSpread2({}, mentionsProps3), {}, {
        "dropdownClassName": hashId.value
      }), {
        notFoundContent: getNotFoundContent,
        option: slots.option
      });
      if (hasFeedback) {
        return wrapSSR(createVNode("div", {
          "class": classNames_default(`${prefixCls.value}-affix-wrapper`, getStatusClassNames(`${prefixCls.value}-affix-wrapper`, mergedStatus.value, hasFeedback), className, hashId.value)
        }, [mentions, createVNode("span", {
          "class": `${prefixCls.value}-suffix`
        }, [feedbackIcon])]));
      }
      return wrapSSR(mentions);
    };
  }
});
var MentionsOption = defineComponent(_extends(_extends({
  compatConfig: {
    MODE: 3
  }
}, optionOptions), {
  name: "AMentionsOption",
  props: optionProps
}));
var mentions_default = _extends(Mentions, {
  Option: MentionsOption,
  getMentions,
  install: (app) => {
    app.component(Mentions.name, Mentions);
    app.component(MentionsOption.name, MentionsOption);
    return app;
  }
});

// node_modules/ant-design-vue/es/statistic/Number.js
var StatisticNumber = (props2) => {
  const {
    value,
    formatter,
    precision,
    decimalSeparator,
    groupSeparator = "",
    prefixCls
  } = props2;
  let valueNode;
  if (typeof formatter === "function") {
    valueNode = formatter({
      value
    });
  } else {
    const val = String(value);
    const cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
    if (!cells) {
      valueNode = val;
    } else {
      const negative = cells[1];
      let int = cells[2] || "0";
      let decimal = cells[4] || "";
      int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
      if (typeof precision === "number") {
        decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
      }
      if (decimal) {
        decimal = `${decimalSeparator}${decimal}`;
      }
      valueNode = [createVNode("span", {
        "key": "int",
        "class": `${prefixCls}-content-value-int`
      }, [negative, int]), decimal && createVNode("span", {
        "key": "decimal",
        "class": `${prefixCls}-content-value-decimal`
      }, [decimal])];
    }
  }
  return createVNode("span", {
    "class": `${prefixCls}-content-value`
  }, [valueNode]);
};
StatisticNumber.displayName = "StatisticNumber";
var Number_default = StatisticNumber;

// node_modules/ant-design-vue/es/statistic/style/index.js
var genStatisticStyle = (token) => {
  const {
    componentCls,
    marginXXS,
    padding,
    colorTextDescription,
    statisticTitleFontSize,
    colorTextHeading,
    statisticContentFontSize,
    statisticFontFamily
  } = token;
  return {
    [`${componentCls}`]: _extends(_extends({}, resetComponent(token)), {
      [`${componentCls}-title`]: {
        marginBottom: marginXXS,
        color: colorTextDescription,
        fontSize: statisticTitleFontSize
      },
      [`${componentCls}-skeleton`]: {
        paddingTop: padding
      },
      [`${componentCls}-content`]: {
        color: colorTextHeading,
        fontSize: statisticContentFontSize,
        fontFamily: statisticFontFamily,
        [`${componentCls}-content-value`]: {
          display: "inline-block",
          direction: "ltr"
        },
        [`${componentCls}-content-prefix, ${componentCls}-content-suffix`]: {
          display: "inline-block"
        },
        [`${componentCls}-content-prefix`]: {
          marginInlineEnd: marginXXS
        },
        [`${componentCls}-content-suffix`]: {
          marginInlineStart: marginXXS
        }
      }
    })
  };
};
var style_default25 = genComponentStyleHook("Statistic", (token) => {
  const {
    fontSizeHeading3,
    fontSize,
    fontFamily
  } = token;
  const statisticToken = merge(token, {
    statisticTitleFontSize: fontSize,
    statisticContentFontSize: fontSizeHeading3,
    statisticFontFamily: fontFamily
  });
  return [genStatisticStyle(statisticToken)];
});

// node_modules/ant-design-vue/es/statistic/Statistic.js
var statisticProps = () => ({
  prefixCls: String,
  decimalSeparator: String,
  groupSeparator: String,
  format: String,
  value: someType([Number, String, Object]),
  valueStyle: {
    type: Object,
    default: void 0
  },
  valueRender: functionType(),
  formatter: anyType(),
  precision: Number,
  prefix: vNodeType(),
  suffix: vNodeType(),
  title: vNodeType(),
  loading: booleanType()
});
var Statistic_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AStatistic",
  inheritAttrs: false,
  props: initDefaultProps_default(statisticProps(), {
    decimalSeparator: ".",
    groupSeparator: ",",
    loading: false
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("statistic", props2);
    const [wrapSSR, hashId] = style_default25(prefixCls);
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g;
      const {
        value = 0,
        valueStyle,
        valueRender
      } = props2;
      const pre = prefixCls.value;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      const prefix = (_c = props2.prefix) !== null && _c !== void 0 ? _c : (_d = slots.prefix) === null || _d === void 0 ? void 0 : _d.call(slots);
      const suffix = (_e = props2.suffix) !== null && _e !== void 0 ? _e : (_f = slots.suffix) === null || _f === void 0 ? void 0 : _f.call(slots);
      const formatter = (_g = props2.formatter) !== null && _g !== void 0 ? _g : slots.formatter;
      let valueNode = createVNode(Number_default, _objectSpread2({
        "data-for-update": Date.now()
      }, _extends(_extends({}, props2), {
        prefixCls: pre,
        value,
        formatter
      })), null);
      if (valueRender) {
        valueNode = valueRender(valueNode);
      }
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": [pre, {
          [`${pre}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value]
      }), [title && createVNode("div", {
        "class": `${pre}-title`
      }, [title]), createVNode(Skeleton_default, {
        "paragraph": false,
        "loading": props2.loading
      }, {
        default: () => [createVNode("div", {
          "style": valueStyle,
          "class": `${pre}-content`
        }, [prefix && createVNode("span", {
          "class": `${pre}-content-prefix`
        }, [prefix]), valueNode, suffix && createVNode("span", {
          "class": `${pre}-content-suffix`
        }, [suffix])])]
      })]));
    };
  }
});

// node_modules/ant-design-vue/es/statistic/utils.js
var timeUnits = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
  // million seconds
];
function formatTimeStr(duration, format2) {
  let leftDuration = duration;
  const escapeRegex = /\[[^\]]*]/g;
  const keepList = (format2.match(escapeRegex) || []).map((str) => str.slice(1, -1));
  const templateText = format2.replace(escapeRegex, "[]");
  const replacedText = timeUnits.reduce((current, _ref) => {
    let [name, unit] = _ref;
    if (current.includes(name)) {
      const value = Math.floor(leftDuration / unit);
      leftDuration -= value * unit;
      return current.replace(new RegExp(`${name}+`, "g"), (match) => {
        const len = match.length;
        return value.toString().padStart(len, "0");
      });
    }
    return current;
  }, templateText);
  let index2 = 0;
  return replacedText.replace(escapeRegex, () => {
    const match = keepList[index2];
    index2 += 1;
    return match;
  });
}
function formatCountdown(value, config) {
  const {
    format: format2 = ""
  } = config;
  const target = new Date(value).getTime();
  const current = Date.now();
  const diff = Math.max(target - current, 0);
  return formatTimeStr(diff, format2);
}

// node_modules/ant-design-vue/es/statistic/Countdown.js
var REFRESH_INTERVAL2 = 1e3 / 30;
function getTime(value) {
  return new Date(value).getTime();
}
var countdownProps = () => {
  return _extends(_extends({}, statisticProps()), {
    value: someType([Number, String, Object]),
    format: String,
    onFinish: Function,
    onChange: Function
  });
};
var Countdown_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AStatisticCountdown",
  props: initDefaultProps_default(countdownProps(), {
    format: "HH:mm:ss"
  }),
  // emits: ['finish', 'change'],
  setup(props2, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const countdownId = ref();
    const statistic = ref();
    const syncTimer = () => {
      const {
        value
      } = props2;
      const timestamp = getTime(value);
      if (timestamp >= Date.now()) {
        startTimer();
      } else {
        stopTimer();
      }
    };
    const startTimer = () => {
      if (countdownId.value)
        return;
      const timestamp = getTime(props2.value);
      countdownId.value = setInterval(() => {
        statistic.value.$forceUpdate();
        if (timestamp > Date.now()) {
          emit("change", timestamp - Date.now());
        }
        syncTimer();
      }, REFRESH_INTERVAL2);
    };
    const stopTimer = () => {
      const {
        value
      } = props2;
      if (countdownId.value) {
        clearInterval(countdownId.value);
        countdownId.value = void 0;
        const timestamp = getTime(value);
        if (timestamp < Date.now()) {
          emit("finish");
        }
      }
    };
    const formatCountdown2 = (_ref2) => {
      let {
        value,
        config
      } = _ref2;
      const {
        format: format2
      } = props2;
      return formatCountdown(value, _extends(_extends({}, config), {
        format: format2
      }));
    };
    const valueRenderHtml = (node) => node;
    onMounted(() => {
      syncTimer();
    });
    onUpdated(() => {
      syncTimer();
    });
    onBeforeUnmount(() => {
      stopTimer();
    });
    return () => {
      const value = props2.value;
      return createVNode(Statistic_default, _objectSpread2({
        "ref": statistic
      }, _extends(_extends({}, omit_default(props2, ["onFinish", "onChange"])), {
        value,
        valueRender: valueRenderHtml,
        formatter: formatCountdown2
      })), slots);
    };
  }
});

// node_modules/ant-design-vue/es/statistic/index.js
Statistic_default.Countdown = Countdown_default;
Statistic_default.install = function(app) {
  app.component(Statistic_default.name, Statistic_default);
  app.component(Statistic_default.Countdown.name, Statistic_default.Countdown);
  return app;
};
var StatisticCountdown = Statistic_default.Countdown;
var statistic_default = Statistic_default;

// node_modules/ant-design-vue/es/_util/transButton.js
var __rest22 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var inlineStyle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
};
var TransButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TransButton",
  inheritAttrs: false,
  props: {
    noStyle: {
      type: Boolean,
      default: void 0
    },
    onClick: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs,
      expose
    } = _ref;
    const domRef = shallowRef();
    const onKeyDown = (event) => {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode_default.ENTER) {
        event.preventDefault();
      }
    };
    const onKeyUp = (event) => {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode_default.ENTER) {
        emit("click", event);
      }
    };
    const onClick = (e) => {
      emit("click", e);
    };
    const focus = () => {
      if (domRef.value) {
        domRef.value.focus();
      }
    };
    const blur = () => {
      if (domRef.value) {
        domRef.value.blur();
      }
    };
    onMounted(() => {
      if (props2.autofocus) {
        focus();
      }
    });
    expose({
      focus,
      blur
    });
    return () => {
      var _a2;
      const {
        noStyle,
        disabled
      } = props2, restProps = __rest22(props2, ["noStyle", "disabled"]);
      let mergedStyle = {};
      if (!noStyle) {
        mergedStyle = _extends({}, inlineStyle);
      }
      if (disabled) {
        mergedStyle.pointerEvents = "none";
      }
      return createVNode("div", _objectSpread2(_objectSpread2(_objectSpread2({
        "role": "button",
        "tabindex": 0,
        "ref": domRef
      }, restProps), attrs), {}, {
        "onClick": onClick,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp,
        "style": _extends(_extends({}, mergedStyle), attrs.style || {})
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
var transButton_default = TransButton;

// node_modules/ant-design-vue/es/page-header/style/index.js
var genPageHeaderStyle = (token) => {
  const {
    componentCls,
    antCls
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      position: "relative",
      padding: `${token.pageHeaderPaddingVertical}px ${token.pageHeaderPadding}px`,
      backgroundColor: token.colorBgContainer,
      [`&${componentCls}-ghost`]: {
        backgroundColor: token.pageHeaderGhostBg
      },
      [`&.has-footer`]: {
        paddingBottom: 0
      },
      [`${componentCls}-back`]: {
        marginRight: token.marginMD,
        fontSize: token.fontSizeLG,
        lineHeight: 1,
        [`&-button`]: _extends(_extends({}, operationUnit(token)), {
          color: token.pageHeaderBackColor,
          cursor: "pointer"
        })
      },
      [`${antCls}-divider-vertical`]: {
        height: "14px",
        margin: `0 ${token.marginSM}`,
        verticalAlign: "middle"
      },
      [`${antCls}-breadcrumb + &-heading`]: {
        marginTop: token.marginXS
      },
      [`${componentCls}-heading`]: {
        display: "flex",
        justifyContent: "space-between",
        [`&-left`]: {
          display: "flex",
          alignItems: "center",
          margin: `${token.marginXS / 2}px 0`,
          overflow: "hidden"
        },
        [`&-title`]: _extends({
          marginRight: token.marginSM,
          marginBottom: 0,
          color: token.colorTextHeading,
          fontWeight: 600,
          fontSize: token.pageHeaderHeadingTitle,
          lineHeight: `${token.controlHeight}px`
        }, textEllipsis),
        [`${antCls}-avatar`]: {
          marginRight: token.marginSM
        },
        [`&-sub-title`]: _extends({
          marginRight: token.marginSM,
          color: token.colorTextDescription,
          fontSize: token.pageHeaderHeadingSubTitle,
          lineHeight: token.lineHeight
        }, textEllipsis),
        [`&-extra`]: {
          margin: `${token.marginXS / 2}px 0`,
          whiteSpace: "nowrap",
          [`> *`]: {
            marginLeft: token.marginSM,
            whiteSpace: "unset"
          },
          [`> *:first-child`]: {
            marginLeft: 0
          }
        }
      },
      [`${componentCls}-content`]: {
        paddingTop: token.pageHeaderContentPaddingVertical
      },
      [`${componentCls}-footer`]: {
        marginTop: token.marginMD,
        [`${antCls}-tabs`]: {
          [`> ${antCls}-tabs-nav`]: {
            margin: 0,
            [`&::before`]: {
              border: "none"
            }
          },
          [`${antCls}-tabs-tab`]: {
            paddingTop: token.paddingXS,
            paddingBottom: token.paddingXS,
            fontSize: token.pageHeaderTabFontSize
          }
        }
      },
      [`${componentCls}-compact ${componentCls}-heading`]: {
        flexWrap: "wrap"
      },
      // rtl style
      [`&${token.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
};
var style_default26 = genComponentStyleHook("PageHeader", (token) => {
  const PageHeaderToken = merge(token, {
    pageHeaderPadding: token.paddingLG,
    pageHeaderPaddingVertical: token.paddingMD,
    pageHeaderPaddingBreadcrumb: token.paddingSM,
    pageHeaderContentPaddingVertical: token.paddingSM,
    pageHeaderBackColor: token.colorTextBase,
    pageHeaderGhostBg: "transparent",
    pageHeaderHeadingTitle: token.fontSizeHeading4,
    pageHeaderHeadingSubTitle: token.fontSize,
    pageHeaderTabFontSize: token.fontSizeLG
  });
  return [genPageHeaderStyle(PageHeaderToken)];
});

// node_modules/ant-design-vue/es/page-header/index.js
var pageHeaderProps = () => ({
  backIcon: vNodeType(),
  prefixCls: String,
  title: vNodeType(),
  subTitle: vNodeType(),
  breadcrumb: vue_types_default.object,
  tags: vNodeType(),
  footer: vNodeType(),
  extra: vNodeType(),
  avatar: objectType(),
  ghost: {
    type: Boolean,
    default: void 0
  },
  onBack: Function
});
var PageHeader = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APageHeader",
  inheritAttrs: false,
  props: pageHeaderProps(),
  // emits: ['back'],
  slots: Object,
  setup(props2, _ref) {
    let {
      emit,
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction,
      pageHeader
    } = useConfigInject_default("page-header", props2);
    const [wrapSSR, hashId] = style_default26(prefixCls);
    const compact = shallowRef(false);
    const isDestroyed = useDestroyed_default();
    const onResize = (_ref2) => {
      let {
        width
      } = _ref2;
      if (!isDestroyed.value) {
        compact.value = width < 768;
      }
    };
    const ghost = computed(() => {
      var _a2, _b, _c;
      return (_c = (_a2 = props2.ghost) !== null && _a2 !== void 0 ? _a2 : (_b = pageHeader === null || pageHeader === void 0 ? void 0 : pageHeader.value) === null || _b === void 0 ? void 0 : _b.ghost) !== null && _c !== void 0 ? _c : true;
    });
    const getBackIcon = () => {
      var _a2, _b, _c;
      return (_c = (_a2 = props2.backIcon) !== null && _a2 !== void 0 ? _a2 : (_b = slots.backIcon) === null || _b === void 0 ? void 0 : _b.call(slots)) !== null && _c !== void 0 ? _c : direction.value === "rtl" ? createVNode(ArrowRightOutlined_default, null, null) : createVNode(ArrowLeftOutlined_default, null, null);
    };
    const renderBack = (backIcon) => {
      if (!backIcon || !props2.onBack) {
        return null;
      }
      return createVNode(LocaleReceiver_default2, {
        "componentName": "PageHeader",
        "children": (_ref3) => {
          let {
            back
          } = _ref3;
          return createVNode("div", {
            "class": `${prefixCls.value}-back`
          }, [createVNode(transButton_default, {
            "onClick": (e) => {
              emit("back", e);
            },
            "class": `${prefixCls.value}-back-button`,
            "aria-label": back
          }, {
            default: () => [backIcon]
          })]);
        }
      }, null);
    };
    const renderBreadcrumb = () => {
      var _a2;
      return props2.breadcrumb ? createVNode(breadcrumb_default, props2.breadcrumb, null) : (_a2 = slots.breadcrumb) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
    const renderTitle = () => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
      const {
        avatar
      } = props2;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      const subTitle = (_c = props2.subTitle) !== null && _c !== void 0 ? _c : (_d = slots.subTitle) === null || _d === void 0 ? void 0 : _d.call(slots);
      const tags = (_e = props2.tags) !== null && _e !== void 0 ? _e : (_f = slots.tags) === null || _f === void 0 ? void 0 : _f.call(slots);
      const extra = (_g = props2.extra) !== null && _g !== void 0 ? _g : (_h = slots.extra) === null || _h === void 0 ? void 0 : _h.call(slots);
      const headingPrefixCls = `${prefixCls.value}-heading`;
      const hasHeading = title || subTitle || tags || extra;
      if (!hasHeading) {
        return null;
      }
      const backIcon = getBackIcon();
      const backIconDom = renderBack(backIcon);
      const hasTitle = backIconDom || avatar || hasHeading;
      return createVNode("div", {
        "class": headingPrefixCls
      }, [hasTitle && createVNode("div", {
        "class": `${headingPrefixCls}-left`
      }, [backIconDom, avatar ? createVNode(avatar_default, avatar, null) : (_j = slots.avatar) === null || _j === void 0 ? void 0 : _j.call(slots), title && createVNode("span", {
        "class": `${headingPrefixCls}-title`,
        "title": typeof title === "string" ? title : void 0
      }, [title]), subTitle && createVNode("span", {
        "class": `${headingPrefixCls}-sub-title`,
        "title": typeof subTitle === "string" ? subTitle : void 0
      }, [subTitle]), tags && createVNode("span", {
        "class": `${headingPrefixCls}-tags`
      }, [tags])]), extra && createVNode("span", {
        "class": `${headingPrefixCls}-extra`
      }, [createVNode(space_default, null, {
        default: () => [extra]
      })])]);
    };
    const renderFooter = () => {
      var _a2, _b;
      const footer = (_a2 = props2.footer) !== null && _a2 !== void 0 ? _a2 : filterEmpty((_b = slots.footer) === null || _b === void 0 ? void 0 : _b.call(slots));
      return isEmptyContent(footer) ? null : createVNode("div", {
        "class": `${prefixCls.value}-footer`
      }, [footer]);
    };
    const renderChildren = (children) => {
      return createVNode("div", {
        "class": `${prefixCls.value}-content`
      }, [children]);
    };
    return () => {
      var _a2, _b;
      const hasBreadcrumb = ((_a2 = props2.breadcrumb) === null || _a2 === void 0 ? void 0 : _a2.routes) || slots.breadcrumb;
      const hasFooter = props2.footer || slots.footer;
      const children = flattenChildren((_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots));
      const className = classNames_default(prefixCls.value, {
        "has-breadcrumb": hasBreadcrumb,
        "has-footer": hasFooter,
        [`${prefixCls.value}-ghost`]: ghost.value,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-compact`]: compact.value
      }, attrs.class, hashId.value);
      return wrapSSR(createVNode(vc_resize_observer_default, {
        "onResize": onResize
      }, {
        default: () => [createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
          "class": className
        }), [renderBreadcrumb(), renderTitle(), children.length ? renderChildren(children) : null, renderFooter()])]
      }));
    };
  }
});
var page_header_default = withInstall(PageHeader);

// node_modules/ant-design-vue/es/progress/props.js
var progressStatuses = ["normal", "exception", "active", "success"];
var progressProps = () => ({
  prefixCls: String,
  type: stringType(),
  percent: Number,
  format: functionType(),
  status: stringType(),
  showInfo: booleanType(),
  strokeWidth: Number,
  strokeLinecap: stringType(),
  strokeColor: anyType(),
  trailColor: String,
  /** @deprecated Use `size` instead */
  width: Number,
  success: objectType(),
  gapDegree: Number,
  gapPosition: stringType(),
  size: someType([String, Number, Array]),
  steps: Number,
  /** @deprecated Use `success` instead */
  successPercent: Number,
  title: String,
  progressStatus: stringType()
});

// node_modules/ant-design-vue/es/progress/utils.js
function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent(_ref) {
  let {
    success,
    successPercent
  } = _ref;
  let percent = successPercent;
  if (success && "progress" in success) {
    devWarning_default(false, "Progress", "`success.progress` is deprecated. Please use `success.percent` instead.");
    percent = success.progress;
  }
  if (success && "percent" in success) {
    percent = success.percent;
  }
  return percent;
}
function getPercentage(_ref2) {
  let {
    percent,
    success,
    successPercent
  } = _ref2;
  const realSuccessPercent = validProgress(getSuccessPercent({
    success,
    successPercent
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
}
function getStrokeColor(_ref3) {
  let {
    success = {},
    strokeColor
  } = _ref3;
  const {
    strokeColor: successColor
  } = success;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
}
var getSize = (size, type, extra) => {
  var _a2, _b, _c, _d;
  let width = -1;
  let height = -1;
  if (type === "step") {
    const steps = extra.steps;
    const strokeWidth = extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      width = size === "small" ? 2 : 14;
      height = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 8;
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = 14, height = 8] = size;
    }
    width *= steps;
  } else if (type === "line") {
    const strokeWidth = extra === null || extra === void 0 ? void 0 : extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      height = strokeWidth || (size === "small" ? 6 : 8);
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = -1, height = 8] = size;
    }
  } else if (type === "circle" || type === "dashboard") {
    if (typeof size === "string" || typeof size === "undefined") {
      [width, height] = size === "small" ? [60, 60] : [120, 120];
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      if (true) {
        devWarning_default(false, "Progress", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.');
      }
      width = (_b = (_a2 = size[0]) !== null && _a2 !== void 0 ? _a2 : size[1]) !== null && _b !== void 0 ? _b : 120;
      height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120;
    }
  }
  return {
    width,
    height
  };
};

// node_modules/ant-design-vue/es/progress/Line.js
var __rest23 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var lineProps = () => _extends(_extends({}, progressProps()), {
  strokeColor: anyType(),
  direction: stringType()
});
var sortGradient = (gradients) => {
  let tempArr = [];
  Object.keys(gradients).forEach((key) => {
    const formattedKey = parseFloat(key.replace(/%/g, ""));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key]
      });
    }
  });
  tempArr = tempArr.sort((a, b) => a.key - b.key);
  return tempArr.map((_ref) => {
    let {
      key,
      value
    } = _ref;
    return `${value} ${key}%`;
  }).join(", ");
};
var handleGradient = (strokeColor, directionConfig) => {
  const {
    from = presetPrimaryColors.blue,
    to = presetPrimaryColors.blue,
    direction = directionConfig === "rtl" ? "to left" : "to right"
  } = strokeColor, rest = __rest23(strokeColor, ["from", "to", "direction"]);
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest);
    return {
      backgroundImage: `linear-gradient(${direction}, ${sortedGradients})`
    };
  }
  return {
    backgroundImage: `linear-gradient(${direction}, ${from}, ${to})`
  };
};
var Line_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressLine",
  inheritAttrs: false,
  props: lineProps(),
  setup(props2, _ref2) {
    let {
      slots,
      attrs
    } = _ref2;
    const backgroundProps = computed(() => {
      const {
        strokeColor,
        direction
      } = props2;
      return strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, direction) : {
        backgroundColor: strokeColor
      };
    });
    const borderRadius = computed(() => props2.strokeLinecap === "square" || props2.strokeLinecap === "butt" ? 0 : void 0);
    const trailStyle = computed(() => props2.trailColor ? {
      backgroundColor: props2.trailColor
    } : void 0);
    const mergedSize = computed(() => {
      var _a2;
      return (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : [-1, props2.strokeWidth || (props2.size === "small" ? 6 : 8)];
    });
    const sizeRef = computed(() => getSize(mergedSize.value, "line", {
      strokeWidth: props2.strokeWidth
    }));
    if (true) {
      devWarning_default("strokeWidth" in props2, "Progress", "`strokeWidth` is deprecated. Please use `size` instead.");
    }
    const percentStyle = computed(() => {
      const {
        percent
      } = props2;
      return _extends({
        width: `${validProgress(percent)}%`,
        height: `${sizeRef.value.height}px`,
        borderRadius: borderRadius.value
      }, backgroundProps.value);
    });
    const successPercent = computed(() => {
      return getSuccessPercent(props2);
    });
    const successPercentStyle = computed(() => {
      const {
        success
      } = props2;
      return {
        width: `${validProgress(successPercent.value)}%`,
        height: `${sizeRef.value.height}px`,
        borderRadius: borderRadius.value,
        backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
      };
    });
    const outerStyle = {
      width: sizeRef.value.width < 0 ? "100%" : sizeRef.value.width,
      height: `${sizeRef.value.height}px`
    };
    return () => {
      var _a2;
      return createVNode(Fragment, null, [createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": [`${props2.prefixCls}-outer`, attrs.class],
        "style": [attrs.style, outerStyle]
      }), [createVNode("div", {
        "class": `${props2.prefixCls}-inner`,
        "style": trailStyle.value
      }, [createVNode("div", {
        "class": `${props2.prefixCls}-bg`,
        "style": percentStyle.value
      }, null), successPercent.value !== void 0 ? createVNode("div", {
        "class": `${props2.prefixCls}-success-bg`,
        "style": successPercentStyle.value
      }, null) : null])]), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-progress/src/common.js
var defaultProps3 = {
  percent: 0,
  prefixCls: "vc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1
};
var useTransitionDuration = (paths) => {
  const prevTimeStamp = ref(null);
  onUpdated(() => {
    const now2 = Date.now();
    let updated = false;
    paths.value.forEach((val) => {
      const path2 = (val === null || val === void 0 ? void 0 : val.$el) || val;
      if (!path2) {
        return;
      }
      updated = true;
      const pathStyle = path2.style;
      pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
      if (prevTimeStamp.value && now2 - prevTimeStamp.value < 100) {
        pathStyle.transitionDuration = "0s, 0s";
      }
    });
    if (updated) {
      prevTimeStamp.value = Date.now();
    }
  });
  return paths;
};

// node_modules/ant-design-vue/es/vc-progress/src/types.js
var propTypes = {
  gapDegree: Number,
  gapPosition: {
    type: String
  },
  percent: {
    type: [Array, Number]
  },
  prefixCls: String,
  strokeColor: {
    type: [Object, String, Array]
  },
  strokeLinecap: {
    type: String
  },
  strokeWidth: Number,
  trailColor: String,
  trailWidth: Number,
  transition: String
};

// node_modules/ant-design-vue/es/vc-progress/src/Line.js
var __rest24 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Line_default2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressLine",
  props: initDefaultProps_default(propTypes, defaultProps3),
  setup(props2) {
    const percentList = computed(() => {
      const {
        percent
      } = props2;
      return Array.isArray(percent) ? percent : [percent];
    });
    const percentListProps = computed(() => {
      const {
        prefixCls,
        strokeLinecap,
        strokeWidth,
        transition
      } = props2;
      let stackPtg = 0;
      return percentList.value.map((ptg, index2) => {
        let dashPercent = 1;
        switch (strokeLinecap) {
          case "round":
            dashPercent = 1 - strokeWidth / 100;
            break;
          case "square":
            dashPercent = 1 - strokeWidth / 2 / 100;
            break;
          default:
            dashPercent = 1;
            break;
        }
        const pathStyle = {
          strokeDasharray: `${ptg * dashPercent}px, 100px`,
          strokeDashoffset: `-${stackPtg}px`,
          transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear"
        };
        const color = strokeColorList.value[index2] || strokeColorList.value[strokeColorList.value.length - 1];
        stackPtg += ptg;
        const pathProps = {
          key: index2,
          d: pathString.value,
          "stroke-linecap": strokeLinecap,
          stroke: color,
          "stroke-width": strokeWidth,
          "fill-opacity": "0",
          class: `${prefixCls}-line-path`,
          style: pathStyle
        };
        return pathProps;
      });
    });
    const strokeColorList = computed(() => {
      const {
        strokeColor
      } = props2;
      return Array.isArray(strokeColor) ? strokeColor : [strokeColor];
    });
    const [setRef, paths] = useRefs_default();
    useTransitionDuration(paths);
    const center = computed(() => props2.strokeWidth / 2);
    const right = computed(() => 100 - props2.strokeWidth / 2);
    const pathString = computed(() => `M ${props2.strokeLinecap === "round" ? center.value : 0},${center.value}
    L ${props2.strokeLinecap === "round" ? right.value : 100},${center.value}`);
    const viewBoxString = computed(() => `0 0 100 ${props2.strokeWidth}`);
    const pathFirst = computed(() => ({
      d: pathString.value,
      "stroke-linecap": props2.strokeLinecap,
      stroke: props2.trailColor,
      "stroke-width": props2.trailWidth || props2.strokeWidth,
      "fill-opacity": "0",
      class: `${props2.prefixCls}-line-trail`
    }));
    return () => {
      const {
        percent,
        prefixCls,
        strokeColor,
        strokeLinecap,
        strokeWidth,
        trailColor,
        trailWidth,
        transition
      } = props2, restProps = __rest24(props2, ["percent", "prefixCls", "strokeColor", "strokeLinecap", "strokeWidth", "trailColor", "trailWidth", "transition"]);
      delete restProps.gapPosition;
      return createVNode("svg", _objectSpread2({
        "class": `${prefixCls}-line`,
        "viewBox": viewBoxString.value,
        "preserveAspectRatio": "none"
      }, restProps), [createVNode("path", pathFirst.value, null), percentListProps.value.map((pathProps, index2) => {
        return createVNode("path", _objectSpread2({
          "ref": setRef(index2)
        }, pathProps), null);
      })]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-progress/src/Circle.js
var __rest25 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var gradientSeed = 0;
function stripPercentToNumber(percent) {
  return +percent.replace("%", "");
}
function toArray3(value) {
  return Array.isArray(value) ? value : [value];
}
function getPathStyles(offset, percent, strokeColor, strokeWidth) {
  let gapDegree = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  let gapPosition = arguments.length > 5 ? arguments[5] : void 0;
  const radius = 50 - strokeWidth / 2;
  let beginPositionX = 0;
  let beginPositionY = -radius;
  let endPositionX = 0;
  let endPositionY = -2 * radius;
  switch (gapPosition) {
    case "left":
      beginPositionX = -radius;
      beginPositionY = 0;
      endPositionX = 2 * radius;
      endPositionY = 0;
      break;
    case "right":
      beginPositionX = radius;
      beginPositionY = 0;
      endPositionX = -2 * radius;
      endPositionY = 0;
      break;
    case "bottom":
      beginPositionY = radius;
      endPositionY = 2 * radius;
      break;
    default:
  }
  const pathString = `M 50,50 m ${beginPositionX},${beginPositionY}
   a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
   a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
  const len = Math.PI * 2 * radius;
  const pathStyle = {
    stroke: strokeColor,
    strokeDasharray: `${percent / 100 * (len - gapDegree)}px ${len}px`,
    strokeDashoffset: `-${gapDegree / 2 + offset / 100 * (len - gapDegree)}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
    // eslint-disable-line
  };
  return {
    pathString,
    pathStyle
  };
}
var Circle_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "VCCircle",
  props: initDefaultProps_default(propTypes, defaultProps3),
  setup(props2) {
    gradientSeed += 1;
    const gradientId = ref(gradientSeed);
    const percentList = computed(() => toArray3(props2.percent));
    const strokeColorList = computed(() => toArray3(props2.strokeColor));
    const [setRef, paths] = useRefs_default();
    useTransitionDuration(paths);
    const getStokeList = () => {
      const {
        prefixCls,
        strokeWidth,
        strokeLinecap,
        gapDegree,
        gapPosition
      } = props2;
      let stackPtg = 0;
      return percentList.value.map((ptg, index2) => {
        const color = strokeColorList.value[index2] || strokeColorList.value[strokeColorList.value.length - 1];
        const stroke = Object.prototype.toString.call(color) === "[object Object]" ? `url(#${prefixCls}-gradient-${gradientId.value})` : "";
        const {
          pathString,
          pathStyle
        } = getPathStyles(stackPtg, ptg, color, strokeWidth, gapDegree, gapPosition);
        stackPtg += ptg;
        const pathProps = {
          key: index2,
          d: pathString,
          stroke,
          "stroke-linecap": strokeLinecap,
          "stroke-width": strokeWidth,
          opacity: ptg === 0 ? 0 : 1,
          "fill-opacity": "0",
          class: `${prefixCls}-circle-path`,
          style: pathStyle
        };
        return createVNode("path", _objectSpread2({
          "ref": setRef(index2)
        }, pathProps), null);
      });
    };
    return () => {
      const {
        prefixCls,
        strokeWidth,
        trailWidth,
        gapDegree,
        gapPosition,
        trailColor,
        strokeLinecap,
        strokeColor
      } = props2, restProps = __rest25(props2, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"]);
      const {
        pathString,
        pathStyle
      } = getPathStyles(0, 100, trailColor, strokeWidth, gapDegree, gapPosition);
      delete restProps.percent;
      const gradient = strokeColorList.value.find((color) => Object.prototype.toString.call(color) === "[object Object]");
      const pathFirst = {
        d: pathString,
        stroke: trailColor,
        "stroke-linecap": strokeLinecap,
        "stroke-width": trailWidth || strokeWidth,
        "fill-opacity": "0",
        class: `${prefixCls}-circle-trail`,
        style: pathStyle
      };
      return createVNode("svg", _objectSpread2({
        "class": `${prefixCls}-circle`,
        "viewBox": "0 0 100 100"
      }, restProps), [gradient && createVNode("defs", null, [createVNode("linearGradient", {
        "id": `${prefixCls}-gradient-${gradientId.value}`,
        "x1": "100%",
        "y1": "0%",
        "x2": "0%",
        "y2": "0%"
      }, [Object.keys(gradient).sort((a, b) => stripPercentToNumber(a) - stripPercentToNumber(b)).map((key, index2) => createVNode("stop", {
        "key": index2,
        "offset": key,
        "stop-color": gradient[key]
      }, null))])]), createVNode("path", pathFirst, null), getStokeList().reverse()]);
    };
  }
});

// node_modules/ant-design-vue/es/progress/Circle.js
var circleProps = () => _extends(_extends({}, progressProps()), {
  strokeColor: anyType()
});
var CIRCLE_MIN_STROKE_WIDTH = 3;
var getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
var Circle_default2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressCircle",
  inheritAttrs: false,
  props: initDefaultProps_default(circleProps(), {
    trailColor: null
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const originWidth = computed(() => {
      var _a2;
      return (_a2 = props2.width) !== null && _a2 !== void 0 ? _a2 : 120;
    });
    const mergedSize = computed(() => {
      var _a2;
      return (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : [originWidth.value, originWidth.value];
    });
    const sizeRef = computed(() => getSize(mergedSize.value, "circle"));
    const gapDeg = computed(() => {
      if (props2.gapDegree || props2.gapDegree === 0) {
        return props2.gapDegree;
      }
      if (props2.type === "dashboard") {
        return 75;
      }
      return void 0;
    });
    const circleStyle = computed(() => {
      return {
        width: `${sizeRef.value.width}px`,
        height: `${sizeRef.value.height}px`,
        fontSize: `${sizeRef.value.width * 0.15 + 6}px`
      };
    });
    const circleWidth = computed(() => {
      var _a2;
      return (_a2 = props2.strokeWidth) !== null && _a2 !== void 0 ? _a2 : Math.max(getMinPercent(sizeRef.value.width), 6);
    });
    const gapPos = computed(() => props2.gapPosition || props2.type === "dashboard" && "bottom" || void 0);
    const percent = computed(() => getPercentage(props2));
    const isGradient = computed(() => Object.prototype.toString.call(props2.strokeColor) === "[object Object]");
    const strokeColor = computed(() => getStrokeColor({
      success: props2.success,
      strokeColor: props2.strokeColor
    }));
    const wrapperClassName = computed(() => ({
      [`${props2.prefixCls}-inner`]: true,
      [`${props2.prefixCls}-circle-gradient`]: isGradient.value
    }));
    return () => {
      var _a2;
      const circleContent = createVNode(Circle_default, {
        "percent": percent.value,
        "strokeWidth": circleWidth.value,
        "trailWidth": circleWidth.value,
        "strokeColor": strokeColor.value,
        "strokeLinecap": props2.strokeLinecap,
        "trailColor": props2.trailColor,
        "prefixCls": props2.prefixCls,
        "gapDegree": gapDeg.value,
        "gapPosition": gapPos.value
      }, null);
      return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": [wrapperClassName.value, attrs.class],
        "style": [attrs.style, circleStyle.value]
      }), [sizeRef.value.width <= 20 ? createVNode(tooltip_default, null, {
        default: () => [createVNode("span", null, [circleContent])],
        title: slots.default
      }) : createVNode(Fragment, null, [circleContent, (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
    };
  }
});

// node_modules/ant-design-vue/es/progress/Steps.js
var stepsProps = () => _extends(_extends({}, progressProps()), {
  steps: Number,
  strokeColor: someType(),
  trailColor: String
});
var Steps_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: stepsProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const current = computed(() => Math.round(props2.steps * ((props2.percent || 0) / 100)));
    const mergedSize = computed(() => {
      var _a2;
      return (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : [props2.size === "small" ? 2 : 14, props2.strokeWidth || 8];
    });
    const sizeRef = computed(() => getSize(mergedSize.value, "step", {
      steps: props2.steps,
      strokeWidth: props2.strokeWidth || 8
    }));
    const styledSteps = computed(() => {
      const {
        steps,
        strokeColor,
        trailColor,
        prefixCls
      } = props2;
      const temp = [];
      for (let i = 0; i < steps; i += 1) {
        const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
        const cls = {
          [`${prefixCls}-steps-item`]: true,
          [`${prefixCls}-steps-item-active`]: i <= current.value - 1
        };
        temp.push(createVNode("div", {
          "key": i,
          "class": cls,
          "style": {
            backgroundColor: i <= current.value - 1 ? color : trailColor,
            width: `${sizeRef.value.width / steps}px`,
            height: `${sizeRef.value.height}px`
          }
        }, null));
      }
      return temp;
    });
    return () => {
      var _a2;
      return createVNode("div", {
        "class": `${props2.prefixCls}-steps-outer`
      }, [styledSteps.value, (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});

// node_modules/ant-design-vue/es/progress/style/index.js
var antProgressActive = new Keyframes_default("antProgressActive", {
  "0%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.1
  },
  "20%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.5
  },
  to: {
    transform: "translateX(0) scaleX(1)",
    opacity: 0
  }
});
var genBaseStyle8 = (token) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token;
  return {
    [progressCls]: _extends(_extends({}, resetComponent(token)), {
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: token.fontSize,
        marginInlineEnd: token.marginXS,
        marginBottom: token.marginXS
      },
      [`${progressCls}-outer`]: {
        display: "inline-block",
        width: "100%"
      },
      [`&${progressCls}-show-info`]: {
        [`${progressCls}-outer`]: {
          marginInlineEnd: `calc(-2em - ${token.marginXS}px)`,
          paddingInlineEnd: `calc(2em + ${token.paddingXS}px)`
        }
      },
      [`${progressCls}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: token.progressRemainingColor,
        borderRadius: token.progressLineRadius
      },
      [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token.colorInfo
        }
      },
      [`${progressCls}-success-bg, ${progressCls}-bg`]: {
        position: "relative",
        backgroundColor: token.colorInfo,
        borderRadius: token.progressLineRadius,
        transition: `all ${token.motionDurationSlow} ${token.motionEaseInOutCirc}`
      },
      [`${progressCls}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: token.colorSuccess
      },
      [`${progressCls}-text`]: {
        display: "inline-block",
        width: "2em",
        marginInlineStart: token.marginXS,
        color: token.progressInfoTextColor,
        lineHeight: 1,
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [iconPrefixCls]: {
          fontSize: token.fontSize
        }
      },
      [`&${progressCls}-status-active`]: {
        [`${progressCls}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: token.colorBgContainer,
          borderRadius: token.progressLineRadius,
          opacity: 0,
          animationName: antProgressActive,
          animationDuration: token.progressActiveMotionDuration,
          animationTimingFunction: token.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token.colorError
        },
        [`${progressCls}-text`]: {
          color: token.colorError
        }
      },
      [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token.colorError
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token.colorSuccess
        },
        [`${progressCls}-text`]: {
          color: token.colorSuccess
        }
      },
      [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token.colorSuccess
        }
      }
    })
  };
};
var genCircleStyle = (token) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token;
  return {
    [progressCls]: {
      [`${progressCls}-circle-trail`]: {
        stroke: token.progressRemainingColor
      },
      [`&${progressCls}-circle ${progressCls}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${progressCls}-circle ${progressCls}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: token.colorText,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [iconPrefixCls]: {
          fontSize: `${token.fontSize / token.fontSizeSM}em`
        }
      },
      [`${progressCls}-circle&-status-exception`]: {
        [`${progressCls}-text`]: {
          color: token.colorError
        }
      },
      [`${progressCls}-circle&-status-success`]: {
        [`${progressCls}-text`]: {
          color: token.colorSuccess
        }
      }
    },
    [`${progressCls}-inline-circle`]: {
      lineHeight: 1,
      [`${progressCls}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
};
var genStepStyle = (token) => {
  const {
    componentCls: progressCls
  } = token;
  return {
    [progressCls]: {
      [`${progressCls}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: token.progressStepMinWidth,
          marginInlineEnd: token.progressStepMarginInlineEnd,
          backgroundColor: token.progressRemainingColor,
          transition: `all ${token.motionDurationSlow}`,
          "&-active": {
            backgroundColor: token.colorInfo
          }
        }
      }
    }
  };
};
var genSmallLine = (token) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token;
  return {
    [progressCls]: {
      [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {
        fontSize: token.fontSizeSM
      }
    }
  };
};
var style_default27 = genComponentStyleHook("Progress", (token) => {
  const progressStepMarginInlineEnd = token.marginXXS / 2;
  const progressToken = merge(token, {
    progressLineRadius: 100,
    progressInfoTextColor: token.colorText,
    progressDefaultColor: token.colorInfo,
    progressRemainingColor: token.colorFillSecondary,
    progressStepMarginInlineEnd,
    progressStepMinWidth: progressStepMarginInlineEnd,
    progressActiveMotionDuration: "2.4s"
  });
  return [genBaseStyle8(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
});

// node_modules/ant-design-vue/es/progress/progress.js
var __rest26 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var progress_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AProgress",
  inheritAttrs: false,
  props: initDefaultProps_default(progressProps(), {
    type: "line",
    percent: 0,
    showInfo: true,
    // null for different theme definition
    trailColor: null,
    size: "default",
    strokeLinecap: "round"
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("progress", props2);
    const [wrapSSR, hashId] = style_default27(prefixCls);
    if (true) {
      devWarning_default("successPercent" in props2, "Progress", "`successPercent` is deprecated. Please use `success.percent` instead.");
      devWarning_default("width" in props2, "Progress", "`width` is deprecated. Please use `size` instead.");
    }
    const strokeColorNotArray = computed(() => Array.isArray(props2.strokeColor) ? props2.strokeColor[0] : props2.strokeColor);
    const percentNumber = computed(() => {
      const {
        percent = 0
      } = props2;
      const successPercent = getSuccessPercent(props2);
      return parseInt(successPercent !== void 0 ? successPercent.toString() : percent.toString(), 10);
    });
    const progressStatus = computed(() => {
      const {
        status
      } = props2;
      if (!progressStatuses.includes(status) && percentNumber.value >= 100) {
        return "success";
      }
      return status || "normal";
    });
    const classString = computed(() => {
      const {
        type,
        showInfo,
        size
      } = props2;
      const pre = prefixCls.value;
      return {
        [pre]: true,
        [`${pre}-inline-circle`]: type === "circle" && getSize(size, "circle").width <= 20,
        [`${pre}-${type === "dashboard" && "circle" || type}`]: true,
        [`${pre}-status-${progressStatus.value}`]: true,
        [`${pre}-show-info`]: showInfo,
        [`${pre}-${size}`]: size,
        [`${pre}-rtl`]: direction.value === "rtl",
        [hashId.value]: true
      };
    });
    const strokeColorNotGradient = computed(() => typeof props2.strokeColor === "string" || Array.isArray(props2.strokeColor) ? props2.strokeColor : void 0);
    const renderProcessInfo = () => {
      const {
        showInfo,
        format: format2,
        type,
        percent,
        title
      } = props2;
      const successPercent = getSuccessPercent(props2);
      if (!showInfo)
        return null;
      let text;
      const textFormatter = format2 || (slots === null || slots === void 0 ? void 0 : slots.format) || ((val) => `${val}%`);
      const isLineType = type === "line";
      if (format2 || (slots === null || slots === void 0 ? void 0 : slots.format) || progressStatus.value !== "exception" && progressStatus.value !== "success") {
        text = textFormatter(validProgress(percent), validProgress(successPercent));
      } else if (progressStatus.value === "exception") {
        text = isLineType ? createVNode(CloseCircleFilled_default, null, null) : createVNode(CloseOutlined_default, null, null);
      } else if (progressStatus.value === "success") {
        text = isLineType ? createVNode(CheckCircleFilled_default, null, null) : createVNode(CheckOutlined_default, null, null);
      }
      return createVNode("span", {
        "class": `${prefixCls.value}-text`,
        "title": title === void 0 && typeof text === "string" ? text : void 0
      }, [text]);
    };
    return () => {
      const {
        type,
        steps,
        title
      } = props2;
      const {
        class: cls
      } = attrs, restAttrs = __rest26(attrs, ["class"]);
      const progressInfo = renderProcessInfo();
      let progress;
      if (type === "line") {
        progress = steps ? createVNode(Steps_default, _objectSpread2(_objectSpread2({}, props2), {}, {
          "strokeColor": strokeColorNotGradient.value,
          "prefixCls": prefixCls.value,
          "steps": steps
        }), {
          default: () => [progressInfo]
        }) : createVNode(Line_default, _objectSpread2(_objectSpread2({}, props2), {}, {
          "strokeColor": strokeColorNotArray.value,
          "prefixCls": prefixCls.value,
          "direction": direction.value
        }), {
          default: () => [progressInfo]
        });
      } else if (type === "circle" || type === "dashboard") {
        progress = createVNode(Circle_default2, _objectSpread2(_objectSpread2({}, props2), {}, {
          "prefixCls": prefixCls.value,
          "strokeColor": strokeColorNotArray.value,
          "progressStatus": progressStatus.value
        }), {
          default: () => [progressInfo]
        });
      }
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({
        "role": "progressbar"
      }, restAttrs), {}, {
        "class": [classString.value, cls],
        "title": title
      }), [progress]));
    };
  }
});

// node_modules/ant-design-vue/es/progress/index.js
var progress_default2 = withInstall(progress_default);

// node_modules/ant-design-vue/es/rate/util.js
function getScroll2(w) {
  let ret = w.scrollX;
  const method = "scrollLeft";
  if (typeof ret !== "number") {
    const d = w.document;
    ret = d.documentElement[method];
    if (typeof ret !== "number") {
      ret = d.body[method];
    }
  }
  return ret;
}
function getClientPosition(elem) {
  let x;
  let y;
  const doc = elem.ownerDocument;
  const {
    body
  } = doc;
  const docElem = doc && doc.documentElement;
  const box = elem.getBoundingClientRect();
  x = box.left;
  y = box.top;
  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}
function getOffsetLeft(el) {
  const pos = getClientPosition(el);
  const doc = el.ownerDocument;
  const w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll2(w);
  return pos.left;
}

// node_modules/ant-design-vue/es/rate/Star.js
var starProps = {
  value: Number,
  index: Number,
  prefixCls: String,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: vue_types_default.any,
  characterRender: Function,
  focused: {
    type: Boolean,
    default: void 0
  },
  count: Number,
  onClick: Function,
  onHover: Function
};
var Star_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Star",
  inheritAttrs: false,
  props: starProps,
  emits: ["hover", "click"],
  setup(props2, _ref) {
    let {
      emit
    } = _ref;
    const onHover = (e) => {
      const {
        index: index2
      } = props2;
      emit("hover", e, index2);
    };
    const onClick = (e) => {
      const {
        index: index2
      } = props2;
      emit("click", e, index2);
    };
    const onKeyDown = (e) => {
      const {
        index: index2
      } = props2;
      if (e.keyCode === 13) {
        emit("click", e, index2);
      }
    };
    const cls = computed(() => {
      const {
        prefixCls,
        index: index2,
        value,
        allowHalf,
        focused
      } = props2;
      const starValue = index2 + 1;
      let className = prefixCls;
      if (value === 0 && index2 === 0 && focused) {
        className += ` ${prefixCls}-focused`;
      } else if (allowHalf && value + 0.5 >= starValue && value < starValue) {
        className += ` ${prefixCls}-half ${prefixCls}-active`;
        if (focused) {
          className += ` ${prefixCls}-focused`;
        }
      } else {
        className += starValue <= value ? ` ${prefixCls}-full` : ` ${prefixCls}-zero`;
        if (starValue === value && focused) {
          className += ` ${prefixCls}-focused`;
        }
      }
      return className;
    });
    return () => {
      const {
        disabled,
        prefixCls,
        characterRender,
        character,
        index: index2,
        count,
        value
      } = props2;
      const characterNode = typeof character === "function" ? character({
        disabled,
        prefixCls,
        index: index2,
        count,
        value
      }) : character;
      let star = createVNode("li", {
        "class": cls.value
      }, [createVNode("div", {
        "onClick": disabled ? null : onClick,
        "onKeydown": disabled ? null : onKeyDown,
        "onMousemove": disabled ? null : onHover,
        "role": "radio",
        "aria-checked": value > index2 ? "true" : "false",
        "aria-posinset": index2 + 1,
        "aria-setsize": count,
        "tabindex": disabled ? -1 : 0
      }, [createVNode("div", {
        "class": `${prefixCls}-first`
      }, [characterNode]), createVNode("div", {
        "class": `${prefixCls}-second`
      }, [characterNode])])]);
      if (characterRender) {
        star = characterRender(star, props2);
      }
      return star;
    };
  }
});

// node_modules/ant-design-vue/es/rate/style/index.js
var genRateStarStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-star`]: {
      position: "relative",
      display: "inline-block",
      color: "inherit",
      cursor: "pointer",
      "&:not(:last-child)": {
        marginInlineEnd: token.marginXS
      },
      "> div": {
        transition: `all ${token.motionDurationMid}, outline 0s`,
        "&:hover": {
          transform: token.rateStarHoverScale
        },
        "&:focus": {
          outline: 0
        },
        "&:focus-visible": {
          outline: `${token.lineWidth}px dashed ${token.rateStarColor}`,
          transform: token.rateStarHoverScale
        }
      },
      "&-first, &-second": {
        color: token.defaultColor,
        transition: `all ${token.motionDurationMid}`,
        userSelect: "none",
        [token.iconCls]: {
          verticalAlign: "middle"
        }
      },
      "&-first": {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        width: "50%",
        height: "100%",
        overflow: "hidden",
        opacity: 0
      },
      [`&-half ${componentCls}-star-first, &-half ${componentCls}-star-second`]: {
        opacity: 1
      },
      [`&-half ${componentCls}-star-first, &-full ${componentCls}-star-second`]: {
        color: "inherit"
      }
    }
  };
};
var genRateRtlStyle = (token) => ({
  [`&-rtl${token.componentCls}`]: {
    direction: "rtl"
  }
});
var genRateStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: _extends(_extends(_extends(_extends(_extends({}, resetComponent(token)), {
      display: "inline-block",
      margin: 0,
      padding: 0,
      color: token.rateStarColor,
      fontSize: token.rateStarSize,
      lineHeight: "unset",
      listStyle: "none",
      outline: "none",
      // disable styles
      [`&-disabled${componentCls} ${componentCls}-star`]: {
        cursor: "default",
        "&:hover": {
          transform: "scale(1)"
        }
      }
    }), genRateStarStyle(token)), {
      // text styles
      [`+ ${componentCls}-text`]: {
        display: "inline-block",
        marginInlineStart: token.marginXS,
        fontSize: token.fontSize
      }
    }), genRateRtlStyle(token))
  };
};
var style_default28 = genComponentStyleHook("Rate", (token) => {
  const {
    colorFillContent
  } = token;
  const rateToken = merge(token, {
    rateStarColor: token["yellow-6"],
    rateStarSize: token.controlHeightLG * 0.5,
    rateStarHoverScale: "scale(1.1)",
    defaultColor: colorFillContent
  });
  return [genRateStyle(rateToken)];
});

// node_modules/ant-design-vue/es/rate/index.js
var rateProps = () => ({
  prefixCls: String,
  count: Number,
  value: Number,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  allowClear: {
    type: Boolean,
    default: void 0
  },
  tooltips: Array,
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: vue_types_default.any,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  tabindex: vue_types_default.oneOfType([vue_types_default.number, vue_types_default.string]),
  direction: String,
  id: String,
  onChange: Function,
  onHoverChange: Function,
  "onUpdate:value": Function,
  onFocus: Function,
  onBlur: Function,
  onKeydown: Function
});
var Rate = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARate",
  inheritAttrs: false,
  props: initDefaultProps_default(rateProps(), {
    value: 0,
    count: 5,
    allowHalf: false,
    allowClear: true,
    tabindex: 0,
    direction: "ltr"
  }),
  // emits: ['hoverChange', 'update:value', 'change', 'focus', 'blur', 'keydown'],
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit,
      expose
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("rate", props2);
    const [wrapSSR, hashId] = style_default28(prefixCls);
    const formItemContext = useInjectFormItemContext();
    const rateRef = ref();
    const [setRef, starRefs] = useRefs_default();
    const state = reactive({
      value: props2.value,
      focused: false,
      cleanedValue: null,
      hoverValue: void 0
    });
    watch(() => props2.value, () => {
      state.value = props2.value;
    });
    const getStarDOM = (index2) => {
      return findDOMNode(starRefs.value.get(index2));
    };
    const getStarValue = (index2, x) => {
      const reverse = direction.value === "rtl";
      let value = index2 + 1;
      if (props2.allowHalf) {
        const starEle = getStarDOM(index2);
        const leftDis = getOffsetLeft(starEle);
        const width = starEle.clientWidth;
        if (reverse && x - leftDis > width / 2) {
          value -= 0.5;
        } else if (!reverse && x - leftDis < width / 2) {
          value -= 0.5;
        }
      }
      return value;
    };
    const changeValue = (value) => {
      if (props2.value === void 0) {
        state.value = value;
      }
      emit("update:value", value);
      emit("change", value);
      formItemContext.onFieldChange();
    };
    const onHover = (e, index2) => {
      const hoverValue = getStarValue(index2, e.pageX);
      if (hoverValue !== state.cleanedValue) {
        state.hoverValue = hoverValue;
        state.cleanedValue = null;
      }
      emit("hoverChange", hoverValue);
    };
    const onMouseLeave = () => {
      state.hoverValue = void 0;
      state.cleanedValue = null;
      emit("hoverChange", void 0);
    };
    const onClick = (event, index2) => {
      const {
        allowClear
      } = props2;
      const newValue = getStarValue(index2, event.pageX);
      let isReset = false;
      if (allowClear) {
        isReset = newValue === state.value;
      }
      onMouseLeave();
      changeValue(isReset ? 0 : newValue);
      state.cleanedValue = isReset ? newValue : null;
    };
    const onFocus = (e) => {
      state.focused = true;
      emit("focus", e);
    };
    const onBlur = (e) => {
      state.focused = false;
      emit("blur", e);
      formItemContext.onFieldBlur();
    };
    const onKeyDown = (event) => {
      const {
        keyCode
      } = event;
      const {
        count,
        allowHalf
      } = props2;
      const reverse = direction.value === "rtl";
      if (keyCode === KeyCode_default.RIGHT && state.value < count && !reverse) {
        if (allowHalf) {
          state.value += 0.5;
        } else {
          state.value += 1;
        }
        changeValue(state.value);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.LEFT && state.value > 0 && !reverse) {
        if (allowHalf) {
          state.value -= 0.5;
        } else {
          state.value -= 1;
        }
        changeValue(state.value);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.RIGHT && state.value > 0 && reverse) {
        if (allowHalf) {
          state.value -= 0.5;
        } else {
          state.value -= 1;
        }
        changeValue(state.value);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.LEFT && state.value < count && reverse) {
        if (allowHalf) {
          state.value += 0.5;
        } else {
          state.value += 1;
        }
        changeValue(state.value);
        event.preventDefault();
      }
      emit("keydown", event);
    };
    const focus = () => {
      if (!props2.disabled) {
        rateRef.value.focus();
      }
    };
    const blur = () => {
      if (!props2.disabled) {
        rateRef.value.blur();
      }
    };
    expose({
      focus,
      blur
    });
    onMounted(() => {
      const {
        autofocus,
        disabled
      } = props2;
      if (autofocus && !disabled) {
        focus();
      }
    });
    const characterRender = (node, _ref2) => {
      let {
        index: index2
      } = _ref2;
      const {
        tooltips
      } = props2;
      if (!tooltips)
        return node;
      return createVNode(tooltip_default, {
        "title": tooltips[index2]
      }, {
        default: () => [node]
      });
    };
    return () => {
      const {
        count,
        allowHalf,
        disabled,
        tabindex,
        id = formItemContext.id.value
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const stars = [];
      const disabledClass = disabled ? `${prefixCls.value}-disabled` : "";
      const character = props2.character || slots.character || (() => createVNode(StarFilled_default, null, null));
      for (let index2 = 0; index2 < count; index2++) {
        stars.push(createVNode(Star_default, {
          "ref": setRef(index2),
          "key": index2,
          "index": index2,
          "count": count,
          "disabled": disabled,
          "prefixCls": `${prefixCls.value}-star`,
          "allowHalf": allowHalf,
          "value": state.hoverValue === void 0 ? state.value : state.hoverValue,
          "onClick": onClick,
          "onHover": onHover,
          "character": character,
          "characterRender": characterRender,
          "focused": state.focused
        }, null));
      }
      const rateClassName = classNames_default(prefixCls.value, disabledClass, className, {
        [hashId.value]: true,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      });
      return wrapSSR(createVNode("ul", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "id": id,
        "class": rateClassName,
        "style": style,
        "onMouseleave": disabled ? null : onMouseLeave,
        "tabindex": disabled ? -1 : tabindex,
        "onFocus": disabled ? null : onFocus,
        "onBlur": disabled ? null : onBlur,
        "onKeydown": disabled ? null : onKeyDown,
        "ref": rateRef,
        "role": "radiogroup"
      }), [stars]));
    };
  }
});
var rate_default = withInstall(Rate);

// node_modules/ant-design-vue/es/result/noFound.js
var NoFound = () => {
  return createVNode("svg", {
    "width": "252",
    "height": "294"
  }, [createVNode("defs", null, [createVNode("path", {
    "d": "M0 .387h251.772v251.772H0z"
  }, null)]), createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", {
    "transform": "translate(0 .012)"
  }, [createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "d": "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), createVNode("path", {
    "d": "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
  }, null), createVNode("path", {
    "d": "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
    "fill": "#1890FF"
  }, null), createVNode("path", {
    "d": "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M107.275 222.1s2.773-1.11 6.102-3.884",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
    "fill": "#520038"
  }, null), createVNode("path", {
    "d": "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
    "fill": "#552950"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
  }, null), createVNode("path", {
    "d": "M110.846 74.481s1.79-.716 2.506.537",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M103.287 72.93s1.83 1.113 4.137.954",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M129.405 122.865s-5.272 7.403-9.422 10.768",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M119.306 107.329s.452 4.366-2.127 32.062",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
    "fill": "#F4D19D"
  }, null), createVNode("path", {
    "d": "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
  }, null), createVNode("path", {
    "d": "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
    "fill": "#F4D19D"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
  }, null), createVNode("path", {
    "d": "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#5BA02E"
  }, null), createVNode("path", {
    "d": "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#92C110"
  }, null), createVNode("path", {
    "d": "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M88.979 89.48s7.776 5.384 16.6 2.842",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
var noFound_default = NoFound;

// node_modules/ant-design-vue/es/result/serverError.js
var ServerError = () => {
  return createVNode("svg", {
    "width": "254",
    "height": "294"
  }, [createVNode("defs", null, [createVNode("path", {
    "d": "M0 .335h253.49v253.49H0z"
  }, null), createVNode("path", {
    "d": "M0 293.665h253.49V.401H0z"
  }, null)]), createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", {
    "transform": "translate(0 .067)"
  }, [createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "d": "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), createVNode("path", {
    "d": "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
    "fill": "#FF603B"
  }, null), createVNode("path", {
    "d": "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
    "fill": "#520038"
  }, null), createVNode("path", {
    "d": "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
    "fill": "#552950"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
  }, null), createVNode("path", {
    "d": "M99.926 73.284s1.8-.72 2.52.54",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
    "stroke": "#DB836E",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.326 71.724s1.84 1.12 4.16.96",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
    "stroke": "#E4EBF7",
    "stroke-width": "1.136",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M96.973 219.373s2.882-1.153 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.032",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
    "stroke": "#DB836E",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M109.278 112.533s3.38-3.613 7.575-4.662",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M107.375 123.006s9.697-2.745 11.445-.88",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
    "stroke": "#BFCDDD",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
    "fill": "#A3B4C6"
  }, null), createVNode("path", {
    "d": "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
    "fill": "#A3B4C6"
  }, null), createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "fill": "#A3B4C6",
    "mask": "url(#d)",
    "d": "M154.098 190.096h70.513v-84.617h-70.513z"
  }, null), createVNode("path", {
    "d": "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
    "stroke": "#7C90A5",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M177.259 207.217v11.52M201.05 207.217v11.52",
    "stroke": "#A3B4C6",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
    "fill": "#5BA02E",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
    "fill": "#92C110",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
    "fill": "#F2D7AD",
    "mask": "url(#d)"
  }, null)])]);
};
var serverError_default = ServerError;

// node_modules/ant-design-vue/es/result/unauthorized.js
var Unauthorized = () => {
  return createVNode("svg", {
    "width": "251",
    "height": "294"
  }, [createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
    "fill": "#E4EBF7"
  }, null), createVNode("path", {
    "d": "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
  }, null), createVNode("path", {
    "d": "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
    "fill": "#A26EF4"
  }, null), createVNode("path", {
    "d": "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
    "fill": "#5BA02E"
  }, null), createVNode("path", {
    "d": "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
    "fill": "#92C110"
  }, null), createVNode("path", {
    "d": "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M78.18 94.656s.911 7.41-4.914 13.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
    "stroke": "#E4EBF7",
    "stroke-width": ".932",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
    "fill": "#5C2552"
  }, null), createVNode("path", {
    "d": "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
  }, null), createVNode("path", {
    "d": "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
    "fill": "#552950"
  }, null), createVNode("path", {
    "d": "M91.132 86.786s5.269 4.957 12.679 2.327",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
    "fill": "#DB836E"
  }, null), createVNode("path", {
    "d": "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
    "stroke": "#5C2552",
    "stroke-width": "1.526",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M66.508 86.763s-1.598 8.83-6.697 14.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.114",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M128.31 87.934s3.013 4.121 4.06 11.785",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M64.09 84.816s-6.03 9.912-13.607 9.903",
    "stroke": "#DB836E",
    "stroke-width": ".795",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M130.532 85.488s4.588 5.757 11.619 6.214",
    "stroke": "#DB836E",
    "stroke-width": ".75",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M121.708 105.73s-.393 8.564-1.34 13.612",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M115.784 161.512s-3.57-1.488-2.678-7.14",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M108.459 220.905s2.759-1.104 6.07-3.863",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
var unauthorized_default = Unauthorized;

// node_modules/ant-design-vue/es/result/style/index.js
var genBaseStyle9 = (token) => {
  const {
    componentCls,
    lineHeightHeading3,
    iconCls,
    padding,
    paddingXL,
    paddingXS,
    paddingLG,
    marginXS,
    lineHeight
  } = token;
  return {
    // Result
    [componentCls]: {
      padding: `${paddingLG * 2}px ${paddingXL}px`,
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // Exception Status image
    [`${componentCls} ${componentCls}-image`]: {
      width: token.imageWidth,
      height: token.imageHeight,
      margin: "auto"
    },
    [`${componentCls} ${componentCls}-icon`]: {
      marginBottom: paddingLG,
      textAlign: "center",
      [`& > ${iconCls}`]: {
        fontSize: token.resultIconFontSize
      }
    },
    [`${componentCls} ${componentCls}-title`]: {
      color: token.colorTextHeading,
      fontSize: token.resultTitleFontSize,
      lineHeight: lineHeightHeading3,
      marginBlock: marginXS,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-subtitle`]: {
      color: token.colorTextDescription,
      fontSize: token.resultSubtitleFontSize,
      lineHeight,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-content`]: {
      marginTop: paddingLG,
      padding: `${paddingLG}px ${padding * 2.5}px`,
      backgroundColor: token.colorFillAlter
    },
    [`${componentCls} ${componentCls}-extra`]: {
      margin: token.resultExtraMargin,
      textAlign: "center",
      "& > *": {
        marginInlineEnd: paddingXS,
        "&:last-child": {
          marginInlineEnd: 0
        }
      }
    }
  };
};
var genStatusIconStyle = (token) => {
  const {
    componentCls,
    iconCls
  } = token;
  return {
    [`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultSuccessIconColor
    },
    [`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultErrorIconColor
    },
    [`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultInfoIconColor
    },
    [`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultWarningIconColor
    }
  };
};
var genResultStyle = (token) => [genBaseStyle9(token), genStatusIconStyle(token)];
var getStyle3 = (token) => genResultStyle(token);
var style_default29 = genComponentStyleHook("Result", (token) => {
  const {
    paddingLG,
    fontSizeHeading3
  } = token;
  const resultSubtitleFontSize = token.fontSize;
  const resultExtraMargin = `${paddingLG}px 0 0 0`;
  const resultInfoIconColor = token.colorInfo;
  const resultErrorIconColor = token.colorError;
  const resultSuccessIconColor = token.colorSuccess;
  const resultWarningIconColor = token.colorWarning;
  const resultToken = merge(token, {
    resultTitleFontSize: fontSizeHeading3,
    resultSubtitleFontSize,
    resultIconFontSize: fontSizeHeading3 * 3,
    resultExtraMargin,
    resultInfoIconColor,
    resultErrorIconColor,
    resultSuccessIconColor,
    resultWarningIconColor
  });
  return [getStyle3(resultToken)];
}, {
  imageWidth: 250,
  imageHeight: 295
});

// node_modules/ant-design-vue/es/result/index.js
var IconMap = {
  success: CheckCircleFilled_default,
  error: CloseCircleFilled_default,
  info: ExclamationCircleFilled_default,
  warning: WarningFilled_default
};
var ExceptionMap = {
  "404": noFound_default,
  "500": serverError_default,
  "403": unauthorized_default
};
var ExceptionStatus = Object.keys(ExceptionMap);
var resultProps = () => ({
  prefixCls: String,
  icon: vue_types_default.any,
  status: {
    type: [Number, String],
    default: "info"
  },
  title: vue_types_default.any,
  subTitle: vue_types_default.any,
  extra: vue_types_default.any
});
var renderIcon = (prefixCls, _ref) => {
  let {
    status,
    icon
  } = _ref;
  if (ExceptionStatus.includes(`${status}`)) {
    const SVGComponent = ExceptionMap[status];
    return createVNode("div", {
      "class": `${prefixCls}-icon ${prefixCls}-image`
    }, [createVNode(SVGComponent, null, null)]);
  }
  const IconComponent = IconMap[status];
  const iconNode = icon || createVNode(IconComponent, null, null);
  return createVNode("div", {
    "class": `${prefixCls}-icon`
  }, [iconNode]);
};
var renderExtra = (prefixCls, extra) => extra && createVNode("div", {
  "class": `${prefixCls}-extra`
}, [extra]);
var Result = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AResult",
  inheritAttrs: false,
  props: resultProps(),
  slots: Object,
  setup(props2, _ref2) {
    let {
      slots,
      attrs
    } = _ref2;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("result", props2);
    const [wrapSSR, hashId] = style_default29(prefixCls);
    const className = computed(() => classNames_default(prefixCls.value, hashId.value, `${prefixCls.value}-${props2.status}`, {
      [`${prefixCls.value}-rtl`]: direction.value === "rtl"
    }));
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      const subTitle = (_c = props2.subTitle) !== null && _c !== void 0 ? _c : (_d = slots.subTitle) === null || _d === void 0 ? void 0 : _d.call(slots);
      const icon = (_e = props2.icon) !== null && _e !== void 0 ? _e : (_f = slots.icon) === null || _f === void 0 ? void 0 : _f.call(slots);
      const extra = (_g = props2.extra) !== null && _g !== void 0 ? _g : (_h = slots.extra) === null || _h === void 0 ? void 0 : _h.call(slots);
      const pre = prefixCls.value;
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": [className.value, attrs.class]
      }), [renderIcon(pre, {
        status: props2.status,
        icon
      }), createVNode("div", {
        "class": `${pre}-title`
      }, [title]), subTitle && createVNode("div", {
        "class": `${pre}-subtitle`
      }, [subTitle]), renderExtra(pre, extra), slots.default && createVNode("div", {
        "class": `${pre}-content`
      }, [slots.default()])]));
    };
  }
});
Result.PRESENTED_IMAGE_403 = ExceptionMap[403];
Result.PRESENTED_IMAGE_404 = ExceptionMap[404];
Result.PRESENTED_IMAGE_500 = ExceptionMap[500];
Result.install = function(app) {
  app.component(Result.name, Result);
  return app;
};
var result_default = Result;

// node_modules/ant-design-vue/es/row/index.js
var row_default = withInstall(Row_default);

// node_modules/ant-design-vue/es/vc-slider/src/common/Track.js
var Track2 = (_, _ref) => {
  let {
    attrs
  } = _ref;
  const {
    included,
    vertical,
    style,
    class: className
  } = attrs;
  let {
    length,
    offset,
    reverse
  } = attrs;
  if (length < 0) {
    reverse = !reverse;
    length = Math.abs(length);
    offset = 100 - offset;
  }
  const positionStyle = vertical ? {
    [reverse ? "top" : "bottom"]: `${offset}%`,
    [reverse ? "bottom" : "top"]: "auto",
    height: `${length}%`
  } : {
    [reverse ? "right" : "left"]: `${offset}%`,
    [reverse ? "left" : "right"]: "auto",
    width: `${length}%`
  };
  const elStyle = _extends(_extends({}, style), positionStyle);
  return included ? createVNode("div", {
    "class": className,
    "style": elStyle
  }, null) : null;
};
Track2.inheritAttrs = false;
var Track_default = Track2;

// node_modules/ant-design-vue/es/vc-slider/src/common/Steps.js
var calcPoints = (_vertical, marks, dots, step, min, max) => {
  warning_default2(dots ? step > 0 : true, "Slider", "`Slider[step]` should be a positive number in order to make Slider[dots] work.");
  const points = Object.keys(marks).map(parseFloat).sort((a, b) => a - b);
  if (dots && step) {
    for (let i = min; i <= max; i += step) {
      if (points.indexOf(i) === -1) {
        points.push(i);
      }
    }
  }
  return points;
};
var Steps = (_, _ref) => {
  let {
    attrs
  } = _ref;
  const {
    prefixCls,
    vertical,
    reverse,
    marks,
    dots,
    step,
    included,
    lowerBound,
    upperBound,
    max,
    min,
    dotStyle,
    activeDotStyle
  } = attrs;
  const range = max - min;
  const elements = calcPoints(vertical, marks, dots, step, min, max).map((point) => {
    const offset = `${Math.abs(point - min) / range * 100}%`;
    const isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    let style = vertical ? _extends(_extends({}, dotStyle), {
      [reverse ? "top" : "bottom"]: offset
    }) : _extends(_extends({}, dotStyle), {
      [reverse ? "right" : "left"]: offset
    });
    if (isActived) {
      style = _extends(_extends({}, style), activeDotStyle);
    }
    const pointClassName = classNames_default({
      [`${prefixCls}-dot`]: true,
      [`${prefixCls}-dot-active`]: isActived,
      [`${prefixCls}-dot-reverse`]: reverse
    });
    return createVNode("span", {
      "class": pointClassName,
      "style": style,
      "key": point
    }, null);
  });
  return createVNode("div", {
    "class": `${prefixCls}-step`
  }, [elements]);
};
Steps.inheritAttrs = false;
var Steps_default2 = Steps;

// node_modules/ant-design-vue/es/vc-slider/src/common/Marks.js
var Marks = (_, _ref) => {
  let {
    attrs,
    slots
  } = _ref;
  const {
    class: className,
    vertical,
    reverse,
    marks,
    included,
    upperBound,
    lowerBound,
    max,
    min,
    onClickLabel
  } = attrs;
  const marksKeys = Object.keys(marks);
  const customMark = slots.mark;
  const range = max - min;
  const elements = marksKeys.map(parseFloat).sort((a, b) => a - b).map((point) => {
    const markPoint = typeof marks[point] === "function" ? marks[point]() : marks[point];
    const markPointIsObject = typeof markPoint === "object" && !isValidElement(markPoint);
    let markLabel = markPointIsObject ? markPoint.label : markPoint;
    if (!markLabel && markLabel !== 0) {
      return null;
    }
    if (customMark) {
      markLabel = customMark({
        point,
        label: markLabel
      });
    }
    const isActive = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    const markClassName = classNames_default({
      [`${className}-text`]: true,
      [`${className}-text-active`]: isActive
    });
    const bottomStyle = {
      marginBottom: "-50%",
      [reverse ? "top" : "bottom"]: `${(point - min) / range * 100}%`
    };
    const leftStyle = {
      transform: `translateX(${reverse ? `50%` : `-50%`})`,
      msTransform: `translateX(${reverse ? `50%` : `-50%`})`,
      [reverse ? "right" : "left"]: `${(point - min) / range * 100}%`
    };
    const style = vertical ? bottomStyle : leftStyle;
    const markStyle = markPointIsObject ? _extends(_extends({}, style), markPoint.style) : style;
    const touchEvents = {
      [supportsPassive_default ? "onTouchstartPassive" : "onTouchstart"]: (e) => onClickLabel(e, point)
    };
    return createVNode("span", _objectSpread2({
      "class": markClassName,
      "style": markStyle,
      "key": point,
      "onMousedown": (e) => onClickLabel(e, point)
    }, touchEvents), [markLabel]);
  });
  return createVNode("div", {
    "class": className
  }, [elements]);
};
Marks.inheritAttrs = false;
var Marks_default = Marks;

// node_modules/ant-design-vue/es/vc-slider/src/Handle.js
var Handle_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Handle",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    vertical: {
      type: Boolean,
      default: void 0
    },
    offset: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    value: Number,
    tabindex: vue_types_default.oneOfType([vue_types_default.number, vue_types_default.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueTextFormatter: Function,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit,
      expose
    } = _ref;
    const clickFocused = shallowRef(false);
    const handle = shallowRef();
    const handleMouseUp = () => {
      if (document.activeElement === handle.value) {
        clickFocused.value = true;
      }
    };
    const handleBlur = (e) => {
      clickFocused.value = false;
      emit("blur", e);
    };
    const handleKeyDown = () => {
      clickFocused.value = false;
    };
    const focus = () => {
      var _a2;
      (_a2 = handle.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = handle.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    const clickFocus = () => {
      clickFocused.value = true;
      focus();
    };
    const handleMousedown = (e) => {
      e.preventDefault();
      focus();
      emit("mousedown", e);
    };
    expose({
      focus,
      blur,
      clickFocus,
      ref: handle
    });
    let onMouseUpListener = null;
    onMounted(() => {
      onMouseUpListener = addEventListenerWrap(document, "mouseup", handleMouseUp);
    });
    onBeforeUnmount(() => {
      onMouseUpListener === null || onMouseUpListener === void 0 ? void 0 : onMouseUpListener.remove();
    });
    const positionStyle = computed(() => {
      const {
        vertical,
        offset,
        reverse
      } = props2;
      return vertical ? {
        [reverse ? "top" : "bottom"]: `${offset}%`,
        [reverse ? "bottom" : "top"]: "auto",
        transform: reverse ? null : `translateY(+50%)`
      } : {
        [reverse ? "right" : "left"]: `${offset}%`,
        [reverse ? "left" : "right"]: "auto",
        transform: `translateX(${reverse ? "+" : "-"}50%)`
      };
    });
    return () => {
      const {
        prefixCls,
        disabled,
        min,
        max,
        value,
        tabindex,
        ariaLabel,
        ariaLabelledBy,
        ariaValueTextFormatter,
        onMouseenter,
        onMouseleave
      } = props2;
      const className = classNames_default(attrs.class, {
        [`${prefixCls}-handle-click-focused`]: clickFocused.value
      });
      const ariaProps = {
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": value,
        "aria-disabled": !!disabled
      };
      const elStyle = [attrs.style, positionStyle.value];
      let mergedTabIndex = tabindex || 0;
      if (disabled || tabindex === null) {
        mergedTabIndex = null;
      }
      let ariaValueText;
      if (ariaValueTextFormatter) {
        ariaValueText = ariaValueTextFormatter(value);
      }
      const handleProps = _extends(_extends(_extends(_extends({}, attrs), {
        role: "slider",
        tabindex: mergedTabIndex
      }), ariaProps), {
        class: className,
        onBlur: handleBlur,
        onKeydown: handleKeyDown,
        onMousedown: handleMousedown,
        onMouseenter,
        onMouseleave,
        ref: handle,
        style: elStyle
      });
      return createVNode("div", _objectSpread2(_objectSpread2({}, handleProps), {}, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-valuetext": ariaValueText
      }), null);
    };
  }
});

// node_modules/ant-design-vue/es/vc-slider/src/utils.js
function isEventFromHandle(e, handles) {
  try {
    return Object.keys(handles).some((key) => e.target === handles[key].ref);
  } catch (error) {
    return false;
  }
}
function isValueOutOfRange(value, _ref) {
  let {
    min,
    max
  } = _ref;
  return value < min || value > max;
}
function isNotTouchEvent(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === "touchend" && e.touches.length > 0;
}
function getClosestPoint(val, _ref2) {
  let {
    marks,
    step,
    min,
    max
  } = _ref2;
  const points = Object.keys(marks).map(parseFloat);
  if (step !== null) {
    const baseNum = Math.pow(10, getPrecision(step));
    const maxSteps = Math.floor((max * baseNum - min * baseNum) / (step * baseNum));
    const steps = Math.min((val - min) / step, maxSteps);
    const closestStep = Math.round(steps) * step + min;
    points.push(closestStep);
  }
  const diffs = points.map((point) => Math.abs(val - point));
  return points[diffs.indexOf(Math.min(...diffs))];
}
function getPrecision(step) {
  const stepString = step.toString();
  let precision = 0;
  if (stepString.indexOf(".") >= 0) {
    precision = stepString.length - stepString.indexOf(".") - 1;
  }
  return precision;
}
function getMousePosition(vertical, e) {
  let zoom = 1;
  if (window.visualViewport) {
    zoom = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2);
  }
  return (vertical ? e.clientY : e.pageX) / zoom;
}
function getTouchPosition(vertical, e) {
  let zoom = 1;
  if (window.visualViewport) {
    zoom = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2);
  }
  return (vertical ? e.touches[0].clientY : e.touches[0].pageX) / zoom;
}
function getHandleCenterPosition(vertical, handle) {
  const coords = handle.getBoundingClientRect();
  return vertical ? coords.top + coords.height * 0.5 : window.scrollX + coords.left + coords.width * 0.5;
}
function ensureValueInRange(val, _ref3) {
  let {
    max,
    min
  } = _ref3;
  if (val <= min) {
    return min;
  }
  if (val >= max) {
    return max;
  }
  return val;
}
function ensureValuePrecision(val, props2) {
  const {
    step
  } = props2;
  const closestPoint = isFinite(getClosestPoint(val, props2)) ? getClosestPoint(val, props2) : 0;
  return step === null ? closestPoint : parseFloat(closestPoint.toFixed(getPrecision(step)));
}
function pauseEvent(e) {
  e.stopPropagation();
  e.preventDefault();
}
function calculateNextValue(func, value, props2) {
  const operations = {
    increase: (a, b) => a + b,
    decrease: (a, b) => a - b
  };
  const indexToGet = operations[func](Object.keys(props2.marks).indexOf(JSON.stringify(value)), 1);
  const keyToGet = Object.keys(props2.marks)[indexToGet];
  if (props2.step) {
    return operations[func](value, props2.step);
  }
  if (!!Object.keys(props2.marks).length && !!props2.marks[keyToGet]) {
    return props2.marks[keyToGet];
  }
  return value;
}
function getKeyboardValueMutator(e, vertical, reverse) {
  const increase = "increase";
  const decrease = "decrease";
  let method = increase;
  switch (e.keyCode) {
    case KeyCode_default.UP:
      method = vertical && reverse ? decrease : increase;
      break;
    case KeyCode_default.RIGHT:
      method = !vertical && reverse ? decrease : increase;
      break;
    case KeyCode_default.DOWN:
      method = vertical && reverse ? increase : decrease;
      break;
    case KeyCode_default.LEFT:
      method = !vertical && reverse ? increase : decrease;
      break;
    case KeyCode_default.END:
      return (_value, props2) => props2.max;
    case KeyCode_default.HOME:
      return (_value, props2) => props2.min;
    case KeyCode_default.PAGE_UP:
      return (value, props2) => value + props2.step * 2;
    case KeyCode_default.PAGE_DOWN:
      return (value, props2) => value - props2.step * 2;
    default:
      return void 0;
  }
  return (value, props2) => calculateNextValue(method, value, props2);
}

// node_modules/ant-design-vue/es/vc-slider/src/common/createSlider.js
var __rest27 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function noop6() {
}
function createSlider(Component) {
  const propTypes2 = {
    id: String,
    min: Number,
    max: Number,
    step: Number,
    marks: vue_types_default.object,
    included: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    handle: Function,
    dots: {
      type: Boolean,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    reverse: {
      type: Boolean,
      default: void 0
    },
    minimumTrackStyle: vue_types_default.object,
    maximumTrackStyle: vue_types_default.object,
    handleStyle: vue_types_default.oneOfType([vue_types_default.object, vue_types_default.arrayOf(vue_types_default.object)]),
    trackStyle: vue_types_default.oneOfType([vue_types_default.object, vue_types_default.arrayOf(vue_types_default.object)]),
    railStyle: vue_types_default.object,
    dotStyle: vue_types_default.object,
    activeDotStyle: vue_types_default.object,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    draggableTrack: {
      type: Boolean,
      default: void 0
    }
  };
  return defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "CreateSlider",
    mixins: [BaseMixin_default, Component],
    inheritAttrs: false,
    props: initDefaultProps_default(propTypes2, {
      prefixCls: "rc-slider",
      min: 0,
      max: 100,
      step: 1,
      marks: {},
      included: true,
      disabled: false,
      dots: false,
      vertical: false,
      reverse: false,
      trackStyle: [{}],
      handleStyle: [{}],
      railStyle: {},
      dotStyle: {},
      activeDotStyle: {}
    }),
    emits: ["change", "blur", "focus"],
    data() {
      const {
        step,
        max,
        min
      } = this;
      const isPointDiffEven = isFinite(max - min) ? (max - min) % step === 0 : true;
      warning_default2(step && Math.floor(step) === step ? isPointDiffEven : true, `Slider[max] - Slider[min] (${max - min}) should be a multiple of Slider[step] (${step})`);
      this.handlesRefs = {};
      return {};
    },
    mounted() {
      this.$nextTick(() => {
        this.document = this.sliderRef && this.sliderRef.ownerDocument;
        const {
          autofocus,
          disabled
        } = this;
        if (autofocus && !disabled) {
          this.focus();
        }
      });
    },
    beforeUnmount() {
      this.$nextTick(() => {
        this.removeDocumentEvents();
      });
    },
    methods: {
      defaultHandle(_a2) {
        var {
          index: index2,
          directives,
          className,
          style
        } = _a2, restProps = __rest27(_a2, ["index", "directives", "className", "style"]);
        delete restProps.dragging;
        if (restProps.value === null) {
          return null;
        }
        const handleProps = _extends(_extends({}, restProps), {
          class: className,
          style,
          key: index2
        });
        return createVNode(Handle_default, handleProps, null);
      },
      onDown(e, position) {
        let p = position;
        const {
          draggableTrack,
          vertical: isVertical
        } = this.$props;
        const {
          bounds
        } = this.$data;
        const value = draggableTrack && this.positionGetValue ? this.positionGetValue(p) || [] : [];
        const inPoint = isEventFromHandle(e, this.handlesRefs);
        this.dragTrack = draggableTrack && bounds.length >= 2 && !inPoint && !value.map((n, i) => {
          const v = !i ? n >= bounds[i] : true;
          return i === value.length - 1 ? n <= bounds[i] : v;
        }).some((c) => !c);
        if (this.dragTrack) {
          this.dragOffset = p;
          this.startBounds = [...bounds];
        } else {
          if (!inPoint) {
            this.dragOffset = 0;
          } else {
            const handlePosition = getHandleCenterPosition(isVertical, e.target);
            this.dragOffset = p - handlePosition;
            p = handlePosition;
          }
          this.onStart(p);
        }
      },
      onMouseDown(e) {
        if (e.button !== 0) {
          return;
        }
        this.removeDocumentEvents();
        const isVertical = this.$props.vertical;
        const position = getMousePosition(isVertical, e);
        this.onDown(e, position);
        this.addDocumentMouseEvents();
      },
      onTouchStart(e) {
        if (isNotTouchEvent(e))
          return;
        const isVertical = this.vertical;
        const position = getTouchPosition(isVertical, e);
        this.onDown(e, position);
        this.addDocumentTouchEvents();
        pauseEvent(e);
      },
      onFocus(e) {
        const {
          vertical
        } = this;
        if (isEventFromHandle(e, this.handlesRefs) && !this.dragTrack) {
          const handlePosition = getHandleCenterPosition(vertical, e.target);
          this.dragOffset = 0;
          this.onStart(handlePosition);
          pauseEvent(e);
          this.$emit("focus", e);
        }
      },
      onBlur(e) {
        if (!this.dragTrack) {
          this.onEnd();
        }
        this.$emit("blur", e);
      },
      onMouseUp() {
        if (this.handlesRefs[this.prevMovedHandleIndex]) {
          this.handlesRefs[this.prevMovedHandleIndex].clickFocus();
        }
      },
      onMouseMove(e) {
        if (!this.sliderRef) {
          this.onEnd();
          return;
        }
        const position = getMousePosition(this.vertical, e);
        this.onMove(e, position - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onTouchMove(e) {
        if (isNotTouchEvent(e) || !this.sliderRef) {
          this.onEnd();
          return;
        }
        const position = getTouchPosition(this.vertical, e);
        this.onMove(e, position - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onKeyDown(e) {
        if (this.sliderRef && isEventFromHandle(e, this.handlesRefs)) {
          this.onKeyboard(e);
        }
      },
      onClickMarkLabel(e, value) {
        e.stopPropagation();
        this.onChange({
          sValue: value
        });
        this.setState({
          sValue: value
        }, () => this.onEnd(true));
      },
      getSliderStart() {
        const slider = this.sliderRef;
        const {
          vertical,
          reverse
        } = this;
        const rect = slider.getBoundingClientRect();
        if (vertical) {
          return reverse ? rect.bottom : rect.top;
        }
        return window.scrollX + (reverse ? rect.right : rect.left);
      },
      getSliderLength() {
        const slider = this.sliderRef;
        if (!slider) {
          return 0;
        }
        const coords = slider.getBoundingClientRect();
        return this.vertical ? coords.height : coords.width;
      },
      addDocumentTouchEvents() {
        this.onTouchMoveListener = addEventListenerWrap(this.document, "touchmove", this.onTouchMove);
        this.onTouchUpListener = addEventListenerWrap(this.document, "touchend", this.onEnd);
      },
      addDocumentMouseEvents() {
        this.onMouseMoveListener = addEventListenerWrap(this.document, "mousemove", this.onMouseMove);
        this.onMouseUpListener = addEventListenerWrap(this.document, "mouseup", this.onEnd);
      },
      removeDocumentEvents() {
        this.onTouchMoveListener && this.onTouchMoveListener.remove();
        this.onTouchUpListener && this.onTouchUpListener.remove();
        this.onMouseMoveListener && this.onMouseMoveListener.remove();
        this.onMouseUpListener && this.onMouseUpListener.remove();
      },
      focus() {
        var _a2;
        if (this.$props.disabled) {
          return;
        }
        (_a2 = this.handlesRefs[0]) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        if (this.$props.disabled) {
          return;
        }
        Object.keys(this.handlesRefs).forEach((key) => {
          var _a2, _b;
          (_b = (_a2 = this.handlesRefs[key]) === null || _a2 === void 0 ? void 0 : _a2.blur) === null || _b === void 0 ? void 0 : _b.call(_a2);
        });
      },
      calcValue(offset) {
        const {
          vertical,
          min,
          max
        } = this;
        const ratio = Math.abs(Math.max(offset, 0) / this.getSliderLength());
        const value = vertical ? (1 - ratio) * (max - min) + min : ratio * (max - min) + min;
        return value;
      },
      calcValueByPos(position) {
        const sign = this.reverse ? -1 : 1;
        const pixelOffset = sign * (position - this.getSliderStart());
        const nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
        return nextValue;
      },
      calcOffset(value) {
        const {
          min,
          max
        } = this;
        const ratio = (value - min) / (max - min);
        return Math.max(0, ratio * 100);
      },
      saveSlider(slider) {
        this.sliderRef = slider;
      },
      saveHandle(index2, handle) {
        this.handlesRefs[index2] = handle;
      }
    },
    render() {
      const {
        prefixCls,
        marks,
        dots,
        step,
        included,
        disabled,
        vertical,
        reverse,
        min,
        max,
        maximumTrackStyle,
        railStyle,
        dotStyle,
        activeDotStyle,
        id
      } = this;
      const {
        class: className,
        style
      } = this.$attrs;
      const {
        tracks,
        handles
      } = this.renderSlider();
      const sliderClassName = classNames_default(prefixCls, className, {
        [`${prefixCls}-with-marks`]: Object.keys(marks).length,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-vertical`]: vertical,
        [`${prefixCls}-horizontal`]: !vertical
      });
      const markProps = {
        vertical,
        marks,
        included,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max,
        min,
        reverse,
        class: `${prefixCls}-mark`,
        onClickLabel: disabled ? noop6 : this.onClickMarkLabel
      };
      const touchEvents = {
        [supportsPassive_default ? "onTouchstartPassive" : "onTouchstart"]: disabled ? noop6 : this.onTouchStart
      };
      return createVNode("div", _objectSpread2(_objectSpread2({
        "id": id,
        "ref": this.saveSlider,
        "tabindex": "-1",
        "class": sliderClassName
      }, touchEvents), {}, {
        "onMousedown": disabled ? noop6 : this.onMouseDown,
        "onMouseup": disabled ? noop6 : this.onMouseUp,
        "onKeydown": disabled ? noop6 : this.onKeyDown,
        "onFocus": disabled ? noop6 : this.onFocus,
        "onBlur": disabled ? noop6 : this.onBlur,
        "style": style
      }), [createVNode("div", {
        "class": `${prefixCls}-rail`,
        "style": _extends(_extends({}, maximumTrackStyle), railStyle)
      }, null), tracks, createVNode(Steps_default2, {
        "prefixCls": prefixCls,
        "vertical": vertical,
        "reverse": reverse,
        "marks": marks,
        "dots": dots,
        "step": step,
        "included": included,
        "lowerBound": this.getLowerBound(),
        "upperBound": this.getUpperBound(),
        "max": max,
        "min": min,
        "dotStyle": dotStyle,
        "activeDotStyle": activeDotStyle
      }, null), handles, createVNode(Marks_default, markProps, {
        mark: this.$slots.mark
      }), getSlot(this)]);
    }
  });
}

// node_modules/ant-design-vue/es/vc-slider/src/Slider.js
var Slider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Slider",
  mixins: [BaseMixin_default],
  inheritAttrs: false,
  props: {
    defaultValue: Number,
    value: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    tabindex: vue_types_default.oneOfType([vue_types_default.number, vue_types_default.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    ariaLabelForHandle: String,
    ariaLabelledByForHandle: String,
    ariaValueTextFormatterForHandle: String,
    startPoint: Number
  },
  emits: ["beforeChange", "afterChange", "change"],
  data() {
    const defaultValue = this.defaultValue !== void 0 ? this.defaultValue : this.min;
    const value = this.value !== void 0 ? this.value : defaultValue;
    return {
      sValue: this.trimAlignValue(value),
      dragging: false
    };
  },
  watch: {
    value: {
      handler(val) {
        this.setChangeValue(val);
      },
      deep: true
    },
    min() {
      const {
        sValue
      } = this;
      this.setChangeValue(sValue);
    },
    max() {
      const {
        sValue
      } = this;
      this.setChangeValue(sValue);
    }
  },
  methods: {
    setChangeValue(value) {
      const newValue = value !== void 0 ? value : this.sValue;
      const nextValue = this.trimAlignValue(newValue, this.$props);
      if (nextValue === this.sValue)
        return;
      this.setState({
        sValue: nextValue
      });
      if (isValueOutOfRange(newValue, this.$props)) {
        this.$emit("change", nextValue);
      }
    },
    onChange(state) {
      const isNotControlled = !hasProp(this, "value");
      const nextState = state.sValue > this.max ? _extends(_extends({}, state), {
        sValue: this.max
      }) : state;
      if (isNotControlled) {
        this.setState(nextState);
      }
      const changedValue = nextState.sValue;
      this.$emit("change", changedValue);
    },
    onStart(position) {
      this.setState({
        dragging: true
      });
      const {
        sValue
      } = this;
      this.$emit("beforeChange", sValue);
      const value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      if (value === sValue)
        return;
      this.prevMovedHandleIndex = 0;
      this.onChange({
        sValue: value
      });
    },
    onEnd(force) {
      const {
        dragging
      } = this;
      this.removeDocumentEvents();
      if (dragging || force) {
        this.$emit("afterChange", this.sValue);
      }
      this.setState({
        dragging: false
      });
    },
    onMove(e, position) {
      pauseEvent(e);
      const {
        sValue
      } = this;
      const value = this.calcValueByPos(position);
      if (value === sValue)
        return;
      this.onChange({
        sValue: value
      });
    },
    onKeyboard(e) {
      const {
        reverse,
        vertical
      } = this.$props;
      const valueMutator = getKeyboardValueMutator(e, vertical, reverse);
      if (valueMutator) {
        pauseEvent(e);
        const {
          sValue
        } = this;
        const mutatedValue = valueMutator(sValue, this.$props);
        const value = this.trimAlignValue(mutatedValue);
        if (value === sValue)
          return;
        this.onChange({
          sValue: value
        });
        this.$emit("afterChange", value);
        this.onEnd();
      }
    },
    getLowerBound() {
      const minPoint = this.$props.startPoint || this.$props.min;
      return this.$data.sValue > minPoint ? minPoint : this.$data.sValue;
    },
    getUpperBound() {
      if (this.$data.sValue < this.$props.startPoint) {
        return this.$props.startPoint;
      }
      return this.$data.sValue;
    },
    trimAlignValue(v) {
      let nextProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (v === null) {
        return null;
      }
      const mergedProps = _extends(_extends({}, this.$props), nextProps);
      const val = ensureValueInRange(v, mergedProps);
      return ensureValuePrecision(val, mergedProps);
    },
    getTrack(_ref) {
      let {
        prefixCls,
        reverse,
        vertical,
        included,
        minimumTrackStyle,
        mergedTrackStyle,
        length,
        offset
      } = _ref;
      return createVNode(Track_default, {
        "class": `${prefixCls}-track`,
        "vertical": vertical,
        "included": included,
        "offset": offset,
        "reverse": reverse,
        "length": length,
        "style": _extends(_extends({}, minimumTrackStyle), mergedTrackStyle)
      }, null);
    },
    renderSlider() {
      const {
        prefixCls,
        vertical,
        included,
        disabled,
        minimumTrackStyle,
        trackStyle,
        handleStyle,
        tabindex,
        ariaLabelForHandle,
        ariaLabelledByForHandle,
        ariaValueTextFormatterForHandle,
        min,
        max,
        startPoint,
        reverse,
        handle,
        defaultHandle
      } = this;
      const handleGenerator = handle || defaultHandle;
      const {
        sValue,
        dragging
      } = this;
      const offset = this.calcOffset(sValue);
      const handles = handleGenerator({
        class: `${prefixCls}-handle`,
        prefixCls,
        vertical,
        offset,
        value: sValue,
        dragging,
        disabled,
        min,
        max,
        reverse,
        index: 0,
        tabindex,
        ariaLabel: ariaLabelForHandle,
        ariaLabelledBy: ariaLabelledByForHandle,
        ariaValueTextFormatter: ariaValueTextFormatterForHandle,
        style: handleStyle[0] || handleStyle,
        ref: (h) => this.saveHandle(0, h),
        onFocus: this.onFocus,
        onBlur: this.onBlur
      });
      const trackOffset = startPoint !== void 0 ? this.calcOffset(startPoint) : 0;
      const mergedTrackStyle = trackStyle[0] || trackStyle;
      return {
        tracks: this.getTrack({
          prefixCls,
          reverse,
          vertical,
          included,
          offset: trackOffset,
          minimumTrackStyle,
          mergedTrackStyle,
          length: offset - trackOffset
        }),
        handles
      };
    }
  }
});
var Slider_default = createSlider(Slider);

// node_modules/ant-design-vue/es/vc-slider/src/Range.js
var trimAlignValue = (_ref) => {
  let {
    value,
    handle,
    bounds,
    props: props2
  } = _ref;
  const {
    allowCross,
    pushable
  } = props2;
  const thershold = Number(pushable);
  const valInRange = ensureValueInRange(value, props2);
  let valNotConflict = valInRange;
  if (!allowCross && handle != null && bounds !== void 0) {
    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {
      valNotConflict = bounds[handle - 1] + thershold;
    }
    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {
      valNotConflict = bounds[handle + 1] - thershold;
    }
  }
  return ensureValuePrecision(valNotConflict, props2);
};
var rangeProps = {
  defaultValue: vue_types_default.arrayOf(vue_types_default.number),
  value: vue_types_default.arrayOf(vue_types_default.number),
  count: Number,
  pushable: withUndefined(vue_types_default.oneOfType([vue_types_default.looseBool, vue_types_default.number])),
  allowCross: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  reverse: {
    type: Boolean,
    default: void 0
  },
  tabindex: vue_types_default.arrayOf(vue_types_default.number),
  prefixCls: String,
  min: Number,
  max: Number,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  ariaLabelGroupForHandles: Array,
  ariaLabelledByGroupForHandles: Array,
  ariaValueTextFormatterGroupForHandles: Array,
  draggableTrack: {
    type: Boolean,
    default: void 0
  }
};
var Range = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Range",
  mixins: [BaseMixin_default],
  inheritAttrs: false,
  props: initDefaultProps_default(rangeProps, {
    count: 1,
    allowCross: true,
    pushable: false,
    tabindex: [],
    draggableTrack: false,
    ariaLabelGroupForHandles: [],
    ariaLabelledByGroupForHandles: [],
    ariaValueTextFormatterGroupForHandles: []
  }),
  emits: ["beforeChange", "afterChange", "change"],
  displayName: "Range",
  data() {
    const {
      count,
      min,
      max
    } = this;
    const initialValue = Array(...Array(count + 1)).map(() => min);
    const defaultValue = hasProp(this, "defaultValue") ? this.defaultValue : initialValue;
    let {
      value
    } = this;
    if (value === void 0) {
      value = defaultValue;
    }
    const bounds = value.map((v, i) => trimAlignValue({
      value: v,
      handle: i,
      props: this.$props
    }));
    const recent = bounds[0] === max ? 0 : bounds.length - 1;
    return {
      sHandle: null,
      recent,
      bounds
    };
  },
  watch: {
    value: {
      handler(val) {
        const {
          bounds
        } = this;
        this.setChangeValue(val || bounds);
      },
      deep: true
    },
    min() {
      const {
        value
      } = this;
      this.setChangeValue(value || this.bounds);
    },
    max() {
      const {
        value
      } = this;
      this.setChangeValue(value || this.bounds);
    }
  },
  methods: {
    setChangeValue(value) {
      const {
        bounds
      } = this;
      let nextBounds = value.map((v, i) => trimAlignValue({
        value: v,
        handle: i,
        bounds,
        props: this.$props
      }));
      if (bounds.length === nextBounds.length) {
        if (nextBounds.every((v, i) => v === bounds[i])) {
          return null;
        }
      } else {
        nextBounds = value.map((v, i) => trimAlignValue({
          value: v,
          handle: i,
          props: this.$props
        }));
      }
      this.setState({
        bounds: nextBounds
      });
      if (value.some((v) => isValueOutOfRange(v, this.$props))) {
        const newValues = value.map((v) => {
          return ensureValueInRange(v, this.$props);
        });
        this.$emit("change", newValues);
      }
    },
    onChange(state) {
      const isNotControlled = !hasProp(this, "value");
      if (isNotControlled) {
        this.setState(state);
      } else {
        const controlledState = {};
        ["sHandle", "recent"].forEach((item) => {
          if (state[item] !== void 0) {
            controlledState[item] = state[item];
          }
        });
        if (Object.keys(controlledState).length) {
          this.setState(controlledState);
        }
      }
      const data = _extends(_extends({}, this.$data), state);
      const changedValue = data.bounds;
      this.$emit("change", changedValue);
    },
    positionGetValue(position) {
      const bounds = this.getValue();
      const value = this.calcValueByPos(position);
      const closestBound = this.getClosestBound(value);
      const index2 = this.getBoundNeedMoving(value, closestBound);
      const prevValue = bounds[index2];
      if (value === prevValue)
        return null;
      const nextBounds = [...bounds];
      nextBounds[index2] = value;
      return nextBounds;
    },
    onStart(position) {
      const {
        bounds
      } = this;
      this.$emit("beforeChange", bounds);
      const value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      const closestBound = this.getClosestBound(value);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);
      this.setState({
        sHandle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      const prevValue = bounds[this.prevMovedHandleIndex];
      if (value === prevValue)
        return;
      const nextBounds = [...bounds];
      nextBounds[this.prevMovedHandleIndex] = value;
      this.onChange({
        bounds: nextBounds
      });
    },
    onEnd(force) {
      const {
        sHandle
      } = this;
      this.removeDocumentEvents();
      if (!sHandle) {
        this.dragTrack = false;
      }
      if (sHandle !== null || force) {
        this.$emit("afterChange", this.bounds);
      }
      this.setState({
        sHandle: null
      });
    },
    onMove(e, position, dragTrack, startBounds) {
      pauseEvent(e);
      const {
        $data: state,
        $props: props2
      } = this;
      const maxValue = props2.max || 100;
      const minValue = props2.min || 0;
      if (dragTrack) {
        let pos = props2.vertical ? -position : position;
        pos = props2.reverse ? -pos : pos;
        const max = maxValue - Math.max(...startBounds);
        const min = minValue - Math.min(...startBounds);
        const ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);
        const nextBounds = startBounds.map((v) => Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue)));
        if (state.bounds.map((c, i) => c === nextBounds[i]).some((c) => !c)) {
          this.onChange({
            bounds: nextBounds
          });
        }
        return;
      }
      const {
        bounds,
        sHandle
      } = this;
      const value = this.calcValueByPos(position);
      const oldValue = bounds[sHandle];
      if (value === oldValue)
        return;
      this.moveTo(value);
    },
    onKeyboard(e) {
      const {
        reverse,
        vertical
      } = this.$props;
      const valueMutator = getKeyboardValueMutator(e, vertical, reverse);
      if (valueMutator) {
        pauseEvent(e);
        const {
          bounds,
          sHandle
        } = this;
        const oldValue = bounds[sHandle === null ? this.recent : sHandle];
        const mutatedValue = valueMutator(oldValue, this.$props);
        const value = trimAlignValue({
          value: mutatedValue,
          handle: sHandle,
          bounds,
          props: this.$props
        });
        if (value === oldValue)
          return;
        const isFromKeyboardEvent = true;
        this.moveTo(value, isFromKeyboardEvent);
      }
    },
    getClosestBound(value) {
      const {
        bounds
      } = this;
      let closestBound = 0;
      for (let i = 1; i < bounds.length - 1; i += 1) {
        if (value >= bounds[i]) {
          closestBound = i;
        }
      }
      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {
        closestBound += 1;
      }
      return closestBound;
    },
    getBoundNeedMoving(value, closestBound) {
      const {
        bounds,
        recent
      } = this;
      let boundNeedMoving = closestBound;
      const isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];
      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {
        boundNeedMoving = recent;
      }
      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {
        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
      }
      return boundNeedMoving;
    },
    getLowerBound() {
      return this.bounds[0];
    },
    getUpperBound() {
      const {
        bounds
      } = this;
      return bounds[bounds.length - 1];
    },
    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */
    getPoints() {
      const {
        marks,
        step,
        min,
        max
      } = this;
      const cache = this.internalPointsCache;
      if (!cache || cache.marks !== marks || cache.step !== step) {
        const pointsObject = _extends({}, marks);
        if (step !== null) {
          for (let point = min; point <= max; point += step) {
            pointsObject[point] = point;
          }
        }
        const points = Object.keys(pointsObject).map(parseFloat);
        points.sort((a, b) => a - b);
        this.internalPointsCache = {
          marks,
          step,
          points
        };
      }
      return this.internalPointsCache.points;
    },
    moveTo(value, isFromKeyboardEvent) {
      const nextBounds = [...this.bounds];
      const {
        sHandle,
        recent
      } = this;
      const handle = sHandle === null ? recent : sHandle;
      nextBounds[handle] = value;
      let nextHandle = handle;
      if (this.$props.pushable !== false) {
        this.pushSurroundingHandles(nextBounds, nextHandle);
      } else if (this.$props.allowCross) {
        nextBounds.sort((a, b) => a - b);
        nextHandle = nextBounds.indexOf(value);
      }
      this.onChange({
        recent: nextHandle,
        sHandle: nextHandle,
        bounds: nextBounds
      });
      if (isFromKeyboardEvent) {
        this.$emit("afterChange", nextBounds);
        this.setState({}, () => {
          this.handlesRefs[nextHandle].focus();
        });
        this.onEnd();
      }
    },
    pushSurroundingHandles(bounds, handle) {
      const value = bounds[handle];
      const {
        pushable
      } = this;
      const threshold = Number(pushable);
      let direction = 0;
      if (bounds[handle + 1] - value < threshold) {
        direction = 1;
      }
      if (value - bounds[handle - 1] < threshold) {
        direction = -1;
      }
      if (direction === 0) {
        return;
      }
      const nextHandle = handle + direction;
      const diffToNext = direction * (bounds[nextHandle] - value);
      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        bounds[handle] = bounds[nextHandle] - direction * threshold;
      }
    },
    pushHandle(bounds, handle, direction, amount) {
      const originalValue = bounds[handle];
      let currentValue = bounds[handle];
      while (direction * (currentValue - originalValue) < amount) {
        if (!this.pushHandleOnePoint(bounds, handle, direction)) {
          bounds[handle] = originalValue;
          return false;
        }
        currentValue = bounds[handle];
      }
      return true;
    },
    pushHandleOnePoint(bounds, handle, direction) {
      const points = this.getPoints();
      const pointIndex = points.indexOf(bounds[handle]);
      const nextPointIndex = pointIndex + direction;
      if (nextPointIndex >= points.length || nextPointIndex < 0) {
        return false;
      }
      const nextHandle = handle + direction;
      const nextValue = points[nextPointIndex];
      const {
        pushable
      } = this;
      const threshold = Number(pushable);
      const diffToNext = direction * (bounds[nextHandle] - nextValue);
      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        return false;
      }
      bounds[handle] = nextValue;
      return true;
    },
    trimAlignValue(value) {
      const {
        sHandle,
        bounds
      } = this;
      return trimAlignValue({
        value,
        handle: sHandle,
        bounds,
        props: this.$props
      });
    },
    ensureValueNotConflict(handle, val, _ref2) {
      let {
        allowCross,
        pushable: thershold
      } = _ref2;
      const state = this.$data || {};
      const {
        bounds
      } = state;
      handle = handle === void 0 ? state.sHandle : handle;
      thershold = Number(thershold);
      if (!allowCross && handle != null && bounds !== void 0) {
        if (handle > 0 && val <= bounds[handle - 1] + thershold) {
          return bounds[handle - 1] + thershold;
        }
        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {
          return bounds[handle + 1] - thershold;
        }
      }
      return val;
    },
    getTrack(_ref3) {
      let {
        bounds,
        prefixCls,
        reverse,
        vertical,
        included,
        offsets,
        trackStyle
      } = _ref3;
      return bounds.slice(0, -1).map((_, index2) => {
        const i = index2 + 1;
        const trackClassName = classNames_default({
          [`${prefixCls}-track`]: true,
          [`${prefixCls}-track-${i}`]: true
        });
        return createVNode(Track_default, {
          "class": trackClassName,
          "vertical": vertical,
          "reverse": reverse,
          "included": included,
          "offset": offsets[i - 1],
          "length": offsets[i] - offsets[i - 1],
          "style": trackStyle[index2],
          "key": i
        }, null);
      });
    },
    renderSlider() {
      const {
        sHandle,
        bounds,
        prefixCls,
        vertical,
        included,
        disabled,
        min,
        max,
        reverse,
        handle,
        defaultHandle,
        trackStyle,
        handleStyle,
        tabindex,
        ariaLabelGroupForHandles,
        ariaLabelledByGroupForHandles,
        ariaValueTextFormatterGroupForHandles
      } = this;
      const handleGenerator = handle || defaultHandle;
      const offsets = bounds.map((v) => this.calcOffset(v));
      const handleClassName = `${prefixCls}-handle`;
      const handles = bounds.map((v, i) => {
        let mergedTabIndex = tabindex[i] || 0;
        if (disabled || tabindex[i] === null) {
          mergedTabIndex = null;
        }
        const dragging = sHandle === i;
        return handleGenerator({
          class: classNames_default({
            [handleClassName]: true,
            [`${handleClassName}-${i + 1}`]: true,
            [`${handleClassName}-dragging`]: dragging
          }),
          prefixCls,
          vertical,
          dragging,
          offset: offsets[i],
          value: v,
          index: i,
          tabindex: mergedTabIndex,
          min,
          max,
          reverse,
          disabled,
          style: handleStyle[i],
          ref: (h) => this.saveHandle(i, h),
          onFocus: this.onFocus,
          onBlur: this.onBlur,
          ariaLabel: ariaLabelGroupForHandles[i],
          ariaLabelledBy: ariaLabelledByGroupForHandles[i],
          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]
        });
      });
      return {
        tracks: this.getTrack({
          bounds,
          prefixCls,
          reverse,
          vertical,
          included,
          offsets,
          trackStyle
        }),
        handles
      };
    }
  }
});
var Range_default = createSlider(Range);

// node_modules/ant-design-vue/es/slider/SliderTooltip.js
var SliderTooltip_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SliderTooltip",
  inheritAttrs: false,
  props: tooltipProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const innerRef = ref(null);
    const rafRef = ref(null);
    function cancelKeepAlign() {
      wrapperRaf.cancel(rafRef.value);
      rafRef.value = null;
    }
    function keepAlign() {
      rafRef.value = wrapperRaf(() => {
        var _a2;
        (_a2 = innerRef.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
        rafRef.value = null;
      });
    }
    const align = () => {
      cancelKeepAlign();
      if (props2.open) {
        keepAlign();
      }
    };
    watch([() => props2.open, () => props2.title], () => {
      align();
    }, {
      flush: "post",
      immediate: true
    });
    onActivated(() => {
      align();
    });
    onBeforeUnmount(() => {
      cancelKeepAlign();
    });
    return () => {
      return createVNode(tooltip_default, _objectSpread2(_objectSpread2({
        "ref": innerRef
      }, props2), attrs), slots);
    };
  }
});

// node_modules/ant-design-vue/es/slider/style/index.js
var genBaseStyle10 = (token) => {
  const {
    componentCls,
    controlSize,
    dotSize,
    marginFull,
    marginPart,
    colorFillContentHover
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      position: "relative",
      height: controlSize,
      margin: `${marginPart}px ${marginFull}px`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      [`&-vertical`]: {
        margin: `${marginFull}px ${marginPart}px`
      },
      [`${componentCls}-rail`]: {
        position: "absolute",
        backgroundColor: token.colorFillTertiary,
        borderRadius: token.borderRadiusXS,
        transition: `background-color ${token.motionDurationMid}`
      },
      [`${componentCls}-track`]: {
        position: "absolute",
        backgroundColor: token.colorPrimaryBorder,
        borderRadius: token.borderRadiusXS,
        transition: `background-color ${token.motionDurationMid}`
      },
      "&:hover": {
        [`${componentCls}-rail`]: {
          backgroundColor: token.colorFillSecondary
        },
        [`${componentCls}-track`]: {
          backgroundColor: token.colorPrimaryBorderHover
        },
        [`${componentCls}-dot`]: {
          borderColor: colorFillContentHover
        },
        [`${componentCls}-handle::after`]: {
          boxShadow: `0 0 0 ${token.handleLineWidth}px ${token.colorPrimaryBorderHover}`
        },
        [`${componentCls}-dot-active`]: {
          borderColor: token.colorPrimary
        }
      },
      [`${componentCls}-handle`]: {
        position: "absolute",
        width: token.handleSize,
        height: token.handleSize,
        outline: "none",
        [`${componentCls}-dragging`]: {
          zIndex: 1
        },
        // 扩大选区
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: -token.handleLineWidth,
          insetBlockStart: -token.handleLineWidth,
          width: token.handleSize + token.handleLineWidth * 2,
          height: token.handleSize + token.handleLineWidth * 2,
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: token.handleSize,
          height: token.handleSize,
          backgroundColor: token.colorBgElevated,
          boxShadow: `0 0 0 ${token.handleLineWidth}px ${token.colorPrimaryBorder}`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${token.motionDurationMid},
            inset-block-start ${token.motionDurationMid},
            width ${token.motionDurationMid},
            height ${token.motionDurationMid},
            box-shadow ${token.motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            insetInlineStart: -((token.handleSizeHover - token.handleSize) / 2 + token.handleLineWidthHover),
            insetBlockStart: -((token.handleSizeHover - token.handleSize) / 2 + token.handleLineWidthHover),
            width: token.handleSizeHover + token.handleLineWidthHover * 2,
            height: token.handleSizeHover + token.handleLineWidthHover * 2
          },
          "&::after": {
            boxShadow: `0 0 0 ${token.handleLineWidthHover}px ${token.colorPrimary}`,
            width: token.handleSizeHover,
            height: token.handleSizeHover,
            insetInlineStart: (token.handleSize - token.handleSizeHover) / 2,
            insetBlockStart: (token.handleSize - token.handleSizeHover) / 2
          }
        }
      },
      [`${componentCls}-mark`]: {
        position: "absolute",
        fontSize: token.fontSize
      },
      [`${componentCls}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: token.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: token.colorText
        }
      },
      [`${componentCls}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${componentCls}-dot`]: {
        position: "absolute",
        width: dotSize,
        height: dotSize,
        backgroundColor: token.colorBgElevated,
        border: `${token.handleLineWidth}px solid ${token.colorBorderSecondary}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${token.motionDurationSlow}`,
        "&-active": {
          borderColor: token.colorPrimaryBorder
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`${componentCls}-rail`]: {
          backgroundColor: `${token.colorFillSecondary} !important`
        },
        [`${componentCls}-track`]: {
          backgroundColor: `${token.colorTextDisabled} !important`
        },
        [`
          ${componentCls}-dot
        `]: {
          backgroundColor: token.colorBgElevated,
          borderColor: token.colorTextDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${componentCls}-handle::after`]: {
          backgroundColor: token.colorBgElevated,
          cursor: "not-allowed",
          width: token.handleSize,
          height: token.handleSize,
          boxShadow: `0 0 0 ${token.handleLineWidth}px ${new TinyColor(token.colorTextDisabled).onBackground(token.colorBgContainer).toHexString()}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: {
          cursor: `not-allowed !important`
        }
      }
    })
  };
};
var genDirectionStyle = (token, horizontal) => {
  const {
    componentCls,
    railSize,
    handleSize,
    dotSize
  } = token;
  const railPadding = horizontal ? "paddingBlock" : "paddingInline";
  const full = horizontal ? "width" : "height";
  const part = horizontal ? "height" : "width";
  const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
  const markInset = horizontal ? "top" : "insetInlineStart";
  return {
    [railPadding]: railSize,
    [part]: railSize * 3,
    [`${componentCls}-rail`]: {
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-track`]: {
      [part]: railSize
    },
    [`${componentCls}-handle`]: {
      [handlePos]: (railSize * 3 - handleSize) / 2
    },
    [`${componentCls}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [markInset]: handleSize,
      [full]: "100%"
    },
    [`${componentCls}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [markInset]: railSize,
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-dot`]: {
      position: "absolute",
      [handlePos]: (railSize - dotSize) / 2
    }
  };
};
var genHorizontalStyle = (token) => {
  const {
    componentCls,
    marginPartWithMark
  } = token;
  return {
    [`${componentCls}-horizontal`]: _extends(_extends({}, genDirectionStyle(token, true)), {
      [`&${componentCls}-with-marks`]: {
        marginBottom: marginPartWithMark
      }
    })
  };
};
var genVerticalStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-vertical`]: _extends(_extends({}, genDirectionStyle(token, false)), {
      height: "100%"
    })
  };
};
var style_default30 = genComponentStyleHook("Slider", (token) => {
  const sliderToken = merge(token, {
    marginPart: (token.controlHeight - token.controlSize) / 2,
    marginFull: token.controlSize / 2,
    marginPartWithMark: token.controlHeightLG - token.controlSize
  });
  return [genBaseStyle10(sliderToken), genHorizontalStyle(sliderToken), genVerticalStyle(sliderToken)];
}, (token) => {
  const increaseHandleWidth = 1;
  const controlSize = token.controlHeightLG / 4;
  const controlSizeHover = token.controlHeightSM / 2;
  const handleLineWidth = token.lineWidth + increaseHandleWidth;
  const handleLineWidthHover = token.lineWidth + increaseHandleWidth * 3;
  return {
    controlSize,
    railSize: 4,
    handleSize: controlSize,
    handleSizeHover: controlSizeHover,
    dotSize: 8,
    handleLineWidth,
    handleLineWidthHover
  };
});

// node_modules/ant-design-vue/es/slider/index.js
var __rest28 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var defaultTipFormatter = (value) => typeof value === "number" ? value.toString() : "";
var sliderProps = () => ({
  id: String,
  prefixCls: String,
  tooltipPrefixCls: String,
  range: someType([Boolean, Object]),
  reverse: booleanType(),
  min: Number,
  max: Number,
  step: someType([Object, Number]),
  marks: objectType(),
  dots: booleanType(),
  value: someType([Array, Number]),
  defaultValue: someType([Array, Number]),
  included: booleanType(),
  disabled: booleanType(),
  vertical: booleanType(),
  tipFormatter: someType([Function, Object], () => defaultTipFormatter),
  tooltipOpen: booleanType(),
  /** @deprecated `tooltipVisible` is deprecated. Please use `tooltipOpen` instead. */
  tooltipVisible: booleanType(),
  tooltipPlacement: stringType(),
  getTooltipPopupContainer: functionType(),
  autofocus: booleanType(),
  handleStyle: someType([Array, Object]),
  trackStyle: someType([Array, Object]),
  onChange: functionType(),
  onAfterChange: functionType(),
  onFocus: functionType(),
  onBlur: functionType(),
  "onUpdate:value": functionType()
});
var Slider2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASlider",
  inheritAttrs: false,
  props: sliderProps(),
  // emits: ['update:value', 'change', 'afterChange', 'blur'],
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit,
      expose
    } = _ref;
    if (true) {
      [["tooltipVisible", "tooltipOpen"]].forEach((_ref2) => {
        let [deprecatedName, newName] = _ref2;
        devWarning_default(props2.tooltipVisible === void 0, "Slider", `\`${deprecatedName}\` is deprecated, please use \`${newName}\` instead.`);
      });
    }
    const {
      prefixCls,
      rootPrefixCls,
      direction,
      getPopupContainer,
      configProvider
    } = useConfigInject_default("slider", props2);
    const [wrapSSR, hashId] = style_default30(prefixCls);
    const formItemContext = useInjectFormItemContext();
    const sliderRef = ref();
    const visibles = ref({});
    const toggleTooltipOpen = (index2, visible) => {
      visibles.value[index2] = visible;
    };
    const tooltipPlacement = computed(() => {
      if (props2.tooltipPlacement) {
        return props2.tooltipPlacement;
      }
      if (!props2.vertical) {
        return "top";
      }
      return direction.value === "rtl" ? "left" : "right";
    });
    const focus = () => {
      var _a2;
      (_a2 = sliderRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = sliderRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    const handleChange = (val) => {
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    const handleBlur = (e) => {
      emit("blur", e);
    };
    expose({
      focus,
      blur
    });
    const handleWithTooltip = (_a2) => {
      var {
        tooltipPrefixCls
      } = _a2, _b = _a2.info, {
        value,
        dragging,
        index: index2
      } = _b, restProps = __rest28(_b, ["value", "dragging", "index"]);
      const {
        tipFormatter,
        tooltipOpen = props2.tooltipVisible,
        getTooltipPopupContainer
      } = props2;
      const isTipFormatter = tipFormatter ? visibles.value[index2] || dragging : false;
      const open2 = tooltipOpen || tooltipOpen === void 0 && isTipFormatter;
      return createVNode(SliderTooltip_default, {
        "prefixCls": tooltipPrefixCls,
        "title": tipFormatter ? tipFormatter(value) : "",
        "open": open2,
        "placement": tooltipPlacement.value,
        "transitionName": `${rootPrefixCls.value}-zoom-down`,
        "key": index2,
        "overlayClassName": `${prefixCls.value}-tooltip`,
        "getPopupContainer": getTooltipPopupContainer || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value)
      }, {
        default: () => [createVNode(Handle_default, _objectSpread2(_objectSpread2({}, restProps), {}, {
          "value": value,
          "onMouseenter": () => toggleTooltipOpen(index2, true),
          "onMouseleave": () => toggleTooltipOpen(index2, false)
        }), null)]
      });
    };
    return () => {
      const {
        tooltipPrefixCls: customizeTooltipPrefixCls,
        range,
        id = formItemContext.id.value
      } = props2, restProps = __rest28(props2, ["tooltipPrefixCls", "range", "id"]);
      const tooltipPrefixCls = configProvider.getPrefixCls("tooltip", customizeTooltipPrefixCls);
      const cls = classNames_default(attrs.class, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, hashId.value);
      if (direction.value === "rtl" && !restProps.vertical) {
        restProps.reverse = !restProps.reverse;
      }
      let draggableTrack;
      if (typeof range === "object") {
        draggableTrack = range.draggableTrack;
      }
      if (range) {
        return wrapSSR(createVNode(Range_default, _objectSpread2(_objectSpread2(_objectSpread2({}, attrs), restProps), {}, {
          "step": restProps.step,
          "draggableTrack": draggableTrack,
          "class": cls,
          "ref": sliderRef,
          "handle": (info) => handleWithTooltip({
            tooltipPrefixCls,
            prefixCls: prefixCls.value,
            info
          }),
          "prefixCls": prefixCls.value,
          "onChange": handleChange,
          "onBlur": handleBlur
        }), {
          mark: slots.mark
        }));
      }
      return wrapSSR(createVNode(Slider_default, _objectSpread2(_objectSpread2(_objectSpread2({}, attrs), restProps), {}, {
        "id": id,
        "step": restProps.step,
        "class": cls,
        "ref": sliderRef,
        "handle": (info) => handleWithTooltip({
          tooltipPrefixCls,
          prefixCls: prefixCls.value,
          info
        }),
        "prefixCls": prefixCls.value,
        "onChange": handleChange,
        "onBlur": handleBlur
      }), {
        mark: slots.mark
      }));
    };
  }
});
var slider_default2 = withInstall(Slider2);

// node_modules/ant-design-vue/es/vc-steps/Step.js
function isString(str) {
  return typeof str === "string";
}
function noop7() {
}
var VcStepProps = () => ({
  prefixCls: String,
  itemWidth: String,
  active: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  status: stringType(),
  iconPrefix: String,
  icon: vue_types_default.any,
  adjustMarginRight: String,
  stepNumber: Number,
  stepIndex: Number,
  description: vue_types_default.any,
  title: vue_types_default.any,
  subTitle: vue_types_default.any,
  progressDot: withUndefined(vue_types_default.oneOfType([vue_types_default.looseBool, vue_types_default.func])),
  tailContent: vue_types_default.any,
  icons: vue_types_default.shape({
    finish: vue_types_default.any,
    error: vue_types_default.any
  }).loose,
  onClick: functionType(),
  onStepClick: functionType(),
  stepIcon: functionType(),
  itemRender: functionType(),
  __legacy: booleanType()
});
var Step_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Step",
  inheritAttrs: false,
  props: VcStepProps(),
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs
    } = _ref;
    const onItemClick = (e) => {
      emit("click", e);
      emit("stepClick", props2.stepIndex);
    };
    const renderIconNode = (_ref2) => {
      let {
        icon,
        title,
        description
      } = _ref2;
      const {
        prefixCls,
        stepNumber,
        status,
        iconPrefix,
        icons: icons2,
        progressDot = slots.progressDot,
        stepIcon = slots.stepIcon
      } = props2;
      let iconNode;
      const iconClassName = classNames_default(`${prefixCls}-icon`, `${iconPrefix}icon`, {
        [`${iconPrefix}icon-${icon}`]: icon && isString(icon),
        [`${iconPrefix}icon-check`]: !icon && status === "finish" && (icons2 && !icons2.finish || !icons2),
        [`${iconPrefix}icon-cross`]: !icon && status === "error" && (icons2 && !icons2.error || !icons2)
      });
      const iconDot = createVNode("span", {
        "class": `${prefixCls}-icon-dot`
      }, null);
      if (progressDot) {
        if (typeof progressDot === "function") {
          iconNode = createVNode("span", {
            "class": `${prefixCls}-icon`
          }, [progressDot({
            iconDot,
            index: stepNumber - 1,
            status,
            title,
            description,
            prefixCls
          })]);
        } else {
          iconNode = createVNode("span", {
            "class": `${prefixCls}-icon`
          }, [iconDot]);
        }
      } else if (icon && !isString(icon)) {
        iconNode = createVNode("span", {
          "class": `${prefixCls}-icon`
        }, [icon]);
      } else if (icons2 && icons2.finish && status === "finish") {
        iconNode = createVNode("span", {
          "class": `${prefixCls}-icon`
        }, [icons2.finish]);
      } else if (icons2 && icons2.error && status === "error") {
        iconNode = createVNode("span", {
          "class": `${prefixCls}-icon`
        }, [icons2.error]);
      } else if (icon || status === "finish" || status === "error") {
        iconNode = createVNode("span", {
          "class": iconClassName
        }, null);
      } else {
        iconNode = createVNode("span", {
          "class": `${prefixCls}-icon`
        }, [stepNumber]);
      }
      if (stepIcon) {
        iconNode = stepIcon({
          index: stepNumber - 1,
          status,
          title,
          description,
          node: iconNode
        });
      }
      return iconNode;
    };
    return () => {
      var _a2, _b, _c, _d;
      const {
        prefixCls,
        itemWidth,
        active,
        status = "wait",
        tailContent,
        adjustMarginRight,
        disabled,
        title = (_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        description = (_b = slots.description) === null || _b === void 0 ? void 0 : _b.call(slots),
        subTitle = (_c = slots.subTitle) === null || _c === void 0 ? void 0 : _c.call(slots),
        icon = (_d = slots.icon) === null || _d === void 0 ? void 0 : _d.call(slots),
        onClick,
        onStepClick
      } = props2;
      const mergedStatus = status || "wait";
      const classString = classNames_default(`${prefixCls}-item`, `${prefixCls}-item-${mergedStatus}`, {
        [`${prefixCls}-item-custom`]: icon,
        [`${prefixCls}-item-active`]: active,
        [`${prefixCls}-item-disabled`]: disabled === true
      });
      const stepItemStyle = {};
      if (itemWidth) {
        stepItemStyle.width = itemWidth;
      }
      if (adjustMarginRight) {
        stepItemStyle.marginRight = adjustMarginRight;
      }
      const accessibilityProps = {
        onClick: onClick || noop7
      };
      if (onStepClick && !disabled) {
        accessibilityProps.role = "button";
        accessibilityProps.tabindex = 0;
        accessibilityProps.onClick = onItemClick;
      }
      const stepNode = createVNode("div", _objectSpread2(_objectSpread2({}, omit_default(attrs, ["__legacy"])), {}, {
        "class": [classString, attrs.class],
        "style": [attrs.style, stepItemStyle]
      }), [createVNode("div", _objectSpread2(_objectSpread2({}, accessibilityProps), {}, {
        "class": `${prefixCls}-item-container`
      }), [createVNode("div", {
        "class": `${prefixCls}-item-tail`
      }, [tailContent]), createVNode("div", {
        "class": `${prefixCls}-item-icon`
      }, [renderIconNode({
        icon,
        title,
        description
      })]), createVNode("div", {
        "class": `${prefixCls}-item-content`
      }, [createVNode("div", {
        "class": `${prefixCls}-item-title`
      }, [title, subTitle && createVNode("div", {
        "title": typeof subTitle === "string" ? subTitle : void 0,
        "class": `${prefixCls}-item-subtitle`
      }, [subTitle])]), description && createVNode("div", {
        "class": `${prefixCls}-item-description`
      }, [description])])])]);
      if (props2.itemRender) {
        return props2.itemRender(stepNode);
      }
      return stepNode;
    };
  }
});

// node_modules/ant-design-vue/es/vc-steps/Steps.js
var __rest29 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Steps_default3 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: {
    type: vue_types_default.string.def("default"),
    prefixCls: vue_types_default.string.def("vc-steps"),
    iconPrefix: vue_types_default.string.def("vc"),
    direction: vue_types_default.string.def("horizontal"),
    labelPlacement: vue_types_default.string.def("horizontal"),
    status: stringType("process"),
    size: vue_types_default.string.def(""),
    progressDot: vue_types_default.oneOfType([vue_types_default.looseBool, vue_types_default.func]).def(void 0),
    initial: vue_types_default.number.def(0),
    current: vue_types_default.number.def(0),
    items: vue_types_default.array.def(() => []),
    icons: vue_types_default.shape({
      finish: vue_types_default.any,
      error: vue_types_default.any
    }).loose,
    stepIcon: functionType(),
    isInline: vue_types_default.looseBool,
    itemRender: functionType()
  },
  emits: ["change"],
  setup(props2, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const onStepClick = (next) => {
      const {
        current
      } = props2;
      if (current !== next) {
        emit("change", next);
      }
    };
    const renderStep = (item, index2, legacyRender) => {
      const {
        prefixCls,
        iconPrefix,
        status,
        current,
        initial,
        icons: icons2,
        stepIcon = slots.stepIcon,
        isInline,
        itemRender,
        progressDot = slots.progressDot
      } = props2;
      const mergedProgressDot = isInline || progressDot;
      const mergedItem = _extends(_extends({}, item), {
        class: ""
      });
      const stepNumber = initial + index2;
      const commonProps2 = {
        active: stepNumber === current,
        stepNumber: stepNumber + 1,
        stepIndex: stepNumber,
        key: stepNumber,
        prefixCls,
        iconPrefix,
        progressDot: mergedProgressDot,
        stepIcon,
        icons: icons2,
        onStepClick
      };
      if (status === "error" && index2 === current - 1) {
        mergedItem.class = `${prefixCls}-next-error`;
      }
      if (!mergedItem.status) {
        if (stepNumber === current) {
          mergedItem.status = status;
        } else if (stepNumber < current) {
          mergedItem.status = "finish";
        } else {
          mergedItem.status = "wait";
        }
      }
      if (isInline) {
        mergedItem.icon = void 0;
        mergedItem.subTitle = void 0;
      }
      if (legacyRender) {
        return legacyRender(_extends(_extends({}, mergedItem), commonProps2));
      }
      if (itemRender) {
        mergedItem.itemRender = (stepItem) => itemRender(mergedItem, stepItem);
      }
      return createVNode(Step_default, _objectSpread2(_objectSpread2(_objectSpread2({}, mergedItem), commonProps2), {}, {
        "__legacy": false
      }), null);
    };
    const renderStepWithNode = (node, index2) => {
      return renderStep(_extends({}, node.props), index2, (stepProps) => {
        const stepNode = cloneElement(node, stepProps);
        return stepNode;
      });
    };
    return () => {
      var _a2;
      const {
        prefixCls,
        direction,
        type,
        labelPlacement,
        iconPrefix,
        status,
        size,
        current,
        progressDot = slots.progressDot,
        initial,
        icons: icons2,
        items,
        isInline,
        itemRender
      } = props2, restProps = __rest29(props2, ["prefixCls", "direction", "type", "labelPlacement", "iconPrefix", "status", "size", "current", "progressDot", "initial", "icons", "items", "isInline", "itemRender"]);
      const isNav = type === "navigation";
      const mergedProgressDot = isInline || progressDot;
      const mergedDirection = isInline ? "horizontal" : direction;
      const mergedSize = isInline ? void 0 : size;
      const adjustedLabelPlacement = mergedProgressDot ? "vertical" : labelPlacement;
      const classString = classNames_default(prefixCls, `${prefixCls}-${direction}`, {
        [`${prefixCls}-${mergedSize}`]: mergedSize,
        [`${prefixCls}-label-${adjustedLabelPlacement}`]: mergedDirection === "horizontal",
        [`${prefixCls}-dot`]: !!mergedProgressDot,
        [`${prefixCls}-navigation`]: isNav,
        [`${prefixCls}-inline`]: isInline
      });
      return createVNode("div", _objectSpread2({
        "class": classString
      }, restProps), [items.filter((item) => item).map((item, index2) => renderStep(item, index2)), filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)).map(renderStepWithNode)]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-steps/index.js
var vc_steps_default = Steps_default3;

// node_modules/ant-design-vue/es/steps/style/custom-icon.js
var genStepsCustomIconStyle = (token) => {
  const {
    componentCls,
    stepsIconCustomTop,
    stepsIconCustomSize,
    stepsIconCustomFontSize
  } = token;
  return {
    [`${componentCls}-item-custom`]: {
      [`> ${componentCls}-item-container > ${componentCls}-item-icon`]: {
        height: "auto",
        background: "none",
        border: 0,
        [`> ${componentCls}-icon`]: {
          top: stepsIconCustomTop,
          width: stepsIconCustomSize,
          height: stepsIconCustomSize,
          fontSize: stepsIconCustomFontSize,
          lineHeight: `${stepsIconCustomSize}px`
        }
      }
    },
    // Only adjust horizontal customize icon width
    [`&:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-custom`]: {
        [`${componentCls}-item-icon`]: {
          width: "auto",
          background: "none"
        }
      }
    }
  };
};
var custom_icon_default = genStepsCustomIconStyle;

// node_modules/ant-design-vue/es/steps/style/label-placement.js
var genStepsLabelPlacementStyle = (token) => {
  const {
    componentCls,
    stepsIconSize,
    lineHeight,
    stepsSmallIconSize
  } = token;
  return {
    [`&${componentCls}-label-vertical`]: {
      [`${componentCls}-item`]: {
        overflow: "visible",
        "&-tail": {
          marginInlineStart: stepsIconSize / 2 + token.controlHeightLG,
          padding: `${token.paddingXXS}px ${token.paddingLG}px`
        },
        "&-content": {
          display: "block",
          width: (stepsIconSize / 2 + token.controlHeightLG) * 2,
          marginTop: token.marginSM,
          textAlign: "center"
        },
        "&-icon": {
          display: "inline-block",
          marginInlineStart: token.controlHeightLG
        },
        "&-title": {
          paddingInlineEnd: 0,
          paddingInlineStart: 0,
          "&::after": {
            display: "none"
          }
        },
        "&-subtitle": {
          display: "block",
          marginBottom: token.marginXXS,
          marginInlineStart: 0,
          lineHeight
        }
      },
      [`&${componentCls}-small:not(${componentCls}-dot)`]: {
        [`${componentCls}-item`]: {
          "&-icon": {
            marginInlineStart: token.controlHeightLG + (stepsIconSize - stepsSmallIconSize) / 2
          }
        }
      }
    }
  };
};
var label_placement_default = genStepsLabelPlacementStyle;

// node_modules/ant-design-vue/es/steps/style/nav.js
var genStepsNavStyle = (token) => {
  const {
    componentCls,
    stepsNavContentMaxWidth,
    stepsNavArrowColor,
    stepsNavActiveColor,
    motionDurationSlow
  } = token;
  return {
    [`&${componentCls}-navigation`]: {
      paddingTop: token.paddingSM,
      [`&${componentCls}-small`]: {
        [`${componentCls}-item`]: {
          "&-container": {
            marginInlineStart: -token.marginSM
          }
        }
      },
      [`${componentCls}-item`]: {
        overflow: "visible",
        textAlign: "center",
        "&-container": {
          display: "inline-block",
          height: "100%",
          marginInlineStart: -token.margin,
          paddingBottom: token.paddingSM,
          textAlign: "start",
          transition: `opacity ${motionDurationSlow}`,
          [`${componentCls}-item-content`]: {
            maxWidth: stepsNavContentMaxWidth
          },
          [`${componentCls}-item-title`]: _extends(_extends({
            maxWidth: "100%",
            paddingInlineEnd: 0
          }, textEllipsis), {
            "&::after": {
              display: "none"
            }
          })
        },
        [`&:not(${componentCls}-item-active)`]: {
          [`${componentCls}-item-container[role='button']`]: {
            cursor: "pointer",
            "&:hover": {
              opacity: 0.85
            }
          }
        },
        "&:last-child": {
          flex: 1,
          "&::after": {
            display: "none"
          }
        },
        "&::after": {
          position: "absolute",
          top: `calc(50% - ${token.paddingSM / 2}px)`,
          insetInlineStart: "100%",
          display: "inline-block",
          width: token.fontSizeIcon,
          height: token.fontSizeIcon,
          borderTop: `${token.lineWidth}px ${token.lineType} ${stepsNavArrowColor}`,
          borderBottom: "none",
          borderInlineStart: "none",
          borderInlineEnd: `${token.lineWidth}px ${token.lineType} ${stepsNavArrowColor}`,
          transform: "translateY(-50%) translateX(-50%) rotate(45deg)",
          content: '""'
        },
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: "50%",
          display: "inline-block",
          width: 0,
          height: token.lineWidthBold,
          backgroundColor: stepsNavActiveColor,
          transition: `width ${motionDurationSlow}, inset-inline-start ${motionDurationSlow}`,
          transitionTimingFunction: "ease-out",
          content: '""'
        }
      },
      [`${componentCls}-item${componentCls}-item-active::before`]: {
        insetInlineStart: 0,
        width: "100%"
      }
    },
    [`&${componentCls}-navigation${componentCls}-vertical`]: {
      [`> ${componentCls}-item`]: {
        marginInlineEnd: 0,
        "&::before": {
          display: "none"
        },
        [`&${componentCls}-item-active::before`]: {
          top: 0,
          insetInlineEnd: 0,
          insetInlineStart: "unset",
          display: "block",
          width: token.lineWidth * 3,
          height: `calc(100% - ${token.marginLG}px)`
        },
        "&::after": {
          position: "relative",
          insetInlineStart: "50%",
          display: "block",
          width: token.controlHeight * 0.25,
          height: token.controlHeight * 0.25,
          marginBottom: token.marginXS,
          textAlign: "center",
          transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
        },
        [`> ${componentCls}-item-container > ${componentCls}-item-tail`]: {
          visibility: "hidden"
        }
      }
    },
    [`&${componentCls}-navigation${componentCls}-horizontal`]: {
      [`> ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        visibility: "hidden"
      }
    }
  };
};
var nav_default = genStepsNavStyle;

// node_modules/ant-design-vue/es/steps/style/progress.js
var genStepsProgressStyle = (token) => {
  const {
    antCls,
    componentCls
  } = token;
  return {
    [`&${componentCls}-with-progress`]: {
      [`${componentCls}-item`]: {
        paddingTop: token.paddingXXS,
        [`&-process ${componentCls}-item-container ${componentCls}-item-icon ${componentCls}-icon`]: {
          color: token.processIconColor
        }
      },
      [`&${componentCls}-vertical > ${componentCls}-item `]: {
        paddingInlineStart: token.paddingXXS,
        [`> ${componentCls}-item-container > ${componentCls}-item-tail`]: {
          top: token.marginXXS,
          insetInlineStart: token.stepsIconSize / 2 - token.lineWidth + token.paddingXXS
        }
      },
      [`&, &${componentCls}-small`]: {
        [`&${componentCls}-horizontal ${componentCls}-item:first-child`]: {
          paddingBottom: token.paddingXXS,
          paddingInlineStart: token.paddingXXS
        }
      },
      [`&${componentCls}-small${componentCls}-vertical > ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        insetInlineStart: token.stepsSmallIconSize / 2 - token.lineWidth + token.paddingXXS
      },
      [`&${componentCls}-label-vertical`]: {
        [`${componentCls}-item ${componentCls}-item-tail`]: {
          top: token.margin - 2 * token.lineWidth
        }
      },
      [`${componentCls}-item-icon`]: {
        position: "relative",
        [`${antCls}-progress`]: {
          position: "absolute",
          insetBlockStart: (token.stepsIconSize - token.stepsProgressSize - token.lineWidth * 2) / 2,
          insetInlineStart: (token.stepsIconSize - token.stepsProgressSize - token.lineWidth * 2) / 2
        }
      }
    }
  };
};
var progress_default3 = genStepsProgressStyle;

// node_modules/ant-design-vue/es/steps/style/progress-dot.js
var genStepsProgressDotStyle = (token) => {
  const {
    componentCls,
    descriptionWidth,
    lineHeight,
    stepsCurrentDotSize,
    stepsDotSize,
    motionDurationSlow
  } = token;
  return {
    [`&${componentCls}-dot, &${componentCls}-dot${componentCls}-small`]: {
      [`${componentCls}-item`]: {
        "&-title": {
          lineHeight
        },
        "&-tail": {
          top: Math.floor((token.stepsDotSize - token.lineWidth * 3) / 2),
          width: "100%",
          marginTop: 0,
          marginBottom: 0,
          marginInline: `${descriptionWidth / 2}px 0`,
          padding: 0,
          "&::after": {
            width: `calc(100% - ${token.marginSM * 2}px)`,
            height: token.lineWidth * 3,
            marginInlineStart: token.marginSM
          }
        },
        "&-icon": {
          width: stepsDotSize,
          height: stepsDotSize,
          marginInlineStart: (token.descriptionWidth - stepsDotSize) / 2,
          paddingInlineEnd: 0,
          lineHeight: `${stepsDotSize}px`,
          background: "transparent",
          border: 0,
          [`${componentCls}-icon-dot`]: {
            position: "relative",
            float: "left",
            width: "100%",
            height: "100%",
            borderRadius: 100,
            transition: `all ${motionDurationSlow}`,
            /* expand hover area */
            "&::after": {
              position: "absolute",
              top: -token.marginSM,
              insetInlineStart: (stepsDotSize - token.controlHeightLG * 1.5) / 2,
              width: token.controlHeightLG * 1.5,
              height: token.controlHeight,
              background: "transparent",
              content: '""'
            }
          }
        },
        "&-content": {
          width: descriptionWidth
        },
        [`&-process ${componentCls}-item-icon`]: {
          position: "relative",
          top: (stepsDotSize - stepsCurrentDotSize) / 2,
          width: stepsCurrentDotSize,
          height: stepsCurrentDotSize,
          lineHeight: `${stepsCurrentDotSize}px`,
          background: "none",
          marginInlineStart: (token.descriptionWidth - stepsCurrentDotSize) / 2
        },
        [`&-process ${componentCls}-icon`]: {
          [`&:first-child ${componentCls}-icon-dot`]: {
            insetInlineStart: 0
          }
        }
      }
    },
    [`&${componentCls}-vertical${componentCls}-dot`]: {
      [`${componentCls}-item-icon`]: {
        marginTop: (token.controlHeight - stepsDotSize) / 2,
        marginInlineStart: 0,
        background: "none"
      },
      [`${componentCls}-item-process ${componentCls}-item-icon`]: {
        marginTop: (token.controlHeight - stepsCurrentDotSize) / 2,
        top: 0,
        insetInlineStart: (stepsDotSize - stepsCurrentDotSize) / 2,
        marginInlineStart: 0
      },
      // https://github.com/ant-design/ant-design/issues/18354
      [`${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        top: (token.controlHeight - stepsDotSize) / 2,
        insetInlineStart: 0,
        margin: 0,
        padding: `${stepsDotSize + token.paddingXS}px 0 ${token.paddingXS}px`,
        "&::after": {
          marginInlineStart: (stepsDotSize - token.lineWidth) / 2
        }
      },
      [`&${componentCls}-small`]: {
        [`${componentCls}-item-icon`]: {
          marginTop: (token.controlHeightSM - stepsDotSize) / 2
        },
        [`${componentCls}-item-process ${componentCls}-item-icon`]: {
          marginTop: (token.controlHeightSM - stepsCurrentDotSize) / 2
        },
        [`${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
          top: (token.controlHeightSM - stepsDotSize) / 2
        }
      },
      [`${componentCls}-item:first-child ${componentCls}-icon-dot`]: {
        insetInlineStart: 0
      },
      [`${componentCls}-item-content`]: {
        width: "inherit"
      }
    }
  };
};
var progress_dot_default = genStepsProgressDotStyle;

// node_modules/ant-design-vue/es/steps/style/rtl.js
var genStepsRTLStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`&${componentCls}-rtl`]: {
      direction: "rtl",
      [`${componentCls}-item`]: {
        "&-subtitle": {
          float: "left"
        }
      },
      // nav
      [`&${componentCls}-navigation`]: {
        [`${componentCls}-item::after`]: {
          transform: "rotate(-45deg)"
        }
      },
      // vertical
      [`&${componentCls}-vertical`]: {
        [`> ${componentCls}-item`]: {
          "&::after": {
            transform: "rotate(225deg)"
          },
          [`${componentCls}-item-icon`]: {
            float: "right"
          }
        }
      },
      // progress-dot
      [`&${componentCls}-dot`]: {
        [`${componentCls}-item-icon ${componentCls}-icon-dot, &${componentCls}-small ${componentCls}-item-icon ${componentCls}-icon-dot`]: {
          float: "right"
        }
      }
    }
  };
};
var rtl_default = genStepsRTLStyle;

// node_modules/ant-design-vue/es/steps/style/small.js
var genStepsSmallStyle = (token) => {
  const {
    componentCls,
    stepsSmallIconSize,
    // stepsSmallIconMargin,
    fontSizeSM,
    fontSize,
    colorTextDescription
  } = token;
  return {
    [`&${componentCls}-small`]: {
      [`&${componentCls}-horizontal:not(${componentCls}-label-vertical) ${componentCls}-item`]: {
        paddingInlineStart: token.paddingSM,
        "&:first-child": {
          paddingInlineStart: 0
        }
      },
      [`${componentCls}-item-icon`]: {
        width: stepsSmallIconSize,
        height: stepsSmallIconSize,
        // margin: stepsSmallIconMargin,
        marginTop: 0,
        marginBottom: 0,
        marginInline: `0 ${token.marginXS}px`,
        fontSize: fontSizeSM,
        lineHeight: `${stepsSmallIconSize}px`,
        textAlign: "center",
        borderRadius: stepsSmallIconSize
      },
      [`${componentCls}-item-title`]: {
        paddingInlineEnd: token.paddingSM,
        fontSize,
        lineHeight: `${stepsSmallIconSize}px`,
        "&::after": {
          top: stepsSmallIconSize / 2
        }
      },
      [`${componentCls}-item-description`]: {
        color: colorTextDescription,
        fontSize
      },
      [`${componentCls}-item-tail`]: {
        top: stepsSmallIconSize / 2 - token.paddingXXS
      },
      [`${componentCls}-item-custom ${componentCls}-item-icon`]: {
        width: "inherit",
        height: "inherit",
        lineHeight: "inherit",
        background: "none",
        border: 0,
        borderRadius: 0,
        [`> ${componentCls}-icon`]: {
          fontSize: stepsSmallIconSize,
          lineHeight: `${stepsSmallIconSize}px`,
          transform: "none"
        }
      }
    }
  };
};
var small_default = genStepsSmallStyle;

// node_modules/ant-design-vue/es/steps/style/vertical.js
var genStepsVerticalStyle = (token) => {
  const {
    componentCls,
    stepsSmallIconSize,
    stepsIconSize
  } = token;
  return {
    [`&${componentCls}-vertical`]: {
      display: "flex",
      flexDirection: "column",
      [`> ${componentCls}-item`]: {
        display: "block",
        flex: "1 0 auto",
        paddingInlineStart: 0,
        overflow: "visible",
        [`${componentCls}-item-icon`]: {
          float: "left",
          marginInlineEnd: token.margin
        },
        [`${componentCls}-item-content`]: {
          display: "block",
          minHeight: token.controlHeight * 1.5,
          overflow: "hidden"
        },
        [`${componentCls}-item-title`]: {
          lineHeight: `${stepsIconSize}px`
        },
        [`${componentCls}-item-description`]: {
          paddingBottom: token.paddingSM
        }
      },
      [`> ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: token.stepsIconSize / 2 - token.lineWidth,
        width: token.lineWidth,
        height: "100%",
        padding: `${stepsIconSize + token.marginXXS * 1.5}px 0 ${token.marginXXS * 1.5}px`,
        "&::after": {
          width: token.lineWidth,
          height: "100%"
        }
      },
      [`> ${componentCls}-item:not(:last-child) > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        display: "block"
      },
      [` > ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-content > ${componentCls}-item-title`]: {
        "&::after": {
          display: "none"
        }
      },
      [`&${componentCls}-small ${componentCls}-item-container`]: {
        [`${componentCls}-item-tail`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: token.stepsSmallIconSize / 2 - token.lineWidth,
          padding: `${stepsSmallIconSize + token.marginXXS * 1.5}px 0 ${token.marginXXS * 1.5}px`
        },
        [`${componentCls}-item-title`]: {
          lineHeight: `${stepsSmallIconSize}px`
        }
      }
    }
  };
};
var vertical_default = genStepsVerticalStyle;

// node_modules/ant-design-vue/es/steps/style/inline.js
var genStepsInlineStyle = (token) => {
  const {
    componentCls,
    inlineDotSize,
    inlineTitleColor,
    inlineTailColor
  } = token;
  const containerPaddingTop = token.paddingXS + token.lineWidth;
  const titleStyle = {
    [`${componentCls}-item-container ${componentCls}-item-content ${componentCls}-item-title`]: {
      color: inlineTitleColor
    }
  };
  return {
    [`&${componentCls}-inline`]: {
      width: "auto",
      display: "inline-flex",
      [`${componentCls}-item`]: {
        flex: "none",
        "&-container": {
          padding: `${containerPaddingTop}px ${token.paddingXXS}px 0`,
          margin: `0 ${token.marginXXS / 2}px`,
          borderRadius: token.borderRadiusSM,
          cursor: "pointer",
          transition: `background-color ${token.motionDurationMid}`,
          "&:hover": {
            background: token.controlItemBgHover
          },
          [`&[role='button']:hover`]: {
            opacity: 1
          }
        },
        "&-icon": {
          width: inlineDotSize,
          height: inlineDotSize,
          marginInlineStart: `calc(50% - ${inlineDotSize / 2}px)`,
          [`> ${componentCls}-icon`]: {
            top: 0
          },
          [`${componentCls}-icon-dot`]: {
            borderRadius: token.fontSizeSM / 4
          }
        },
        "&-content": {
          width: "auto",
          marginTop: token.marginXS - token.lineWidth
        },
        "&-title": {
          color: inlineTitleColor,
          fontSize: token.fontSizeSM,
          lineHeight: token.lineHeightSM,
          fontWeight: "normal",
          marginBottom: token.marginXXS / 2
        },
        "&-description": {
          display: "none"
        },
        "&-tail": {
          marginInlineStart: 0,
          top: containerPaddingTop + inlineDotSize / 2,
          transform: `translateY(-50%)`,
          "&:after": {
            width: "100%",
            height: token.lineWidth,
            borderRadius: 0,
            marginInlineStart: 0,
            background: inlineTailColor
          }
        },
        [`&:first-child ${componentCls}-item-tail`]: {
          width: "50%",
          marginInlineStart: "50%"
        },
        [`&:last-child ${componentCls}-item-tail`]: {
          display: "block",
          width: "50%"
        },
        "&-wait": _extends({
          [`${componentCls}-item-icon ${componentCls}-icon ${componentCls}-icon-dot`]: {
            backgroundColor: token.colorBorderBg,
            border: `${token.lineWidth}px ${token.lineType} ${inlineTailColor}`
          }
        }, titleStyle),
        "&-finish": _extends({
          [`${componentCls}-item-tail::after`]: {
            backgroundColor: inlineTailColor
          },
          [`${componentCls}-item-icon ${componentCls}-icon ${componentCls}-icon-dot`]: {
            backgroundColor: inlineTailColor,
            border: `${token.lineWidth}px ${token.lineType} ${inlineTailColor}`
          }
        }, titleStyle),
        "&-error": titleStyle,
        "&-active, &-process": _extends({
          [`${componentCls}-item-icon`]: {
            width: inlineDotSize,
            height: inlineDotSize,
            marginInlineStart: `calc(50% - ${inlineDotSize / 2}px)`,
            top: 0
          }
        }, titleStyle),
        [`&:not(${componentCls}-item-active) > ${componentCls}-item-container[role='button']:hover`]: {
          [`${componentCls}-item-title`]: {
            color: inlineTitleColor
          }
        }
      }
    }
  };
};
var inline_default = genStepsInlineStyle;

// node_modules/ant-design-vue/es/steps/style/index.js
var StepItemStatusEnum;
(function(StepItemStatusEnum2) {
  StepItemStatusEnum2["wait"] = "wait";
  StepItemStatusEnum2["process"] = "process";
  StepItemStatusEnum2["finish"] = "finish";
  StepItemStatusEnum2["error"] = "error";
})(StepItemStatusEnum || (StepItemStatusEnum = {}));
var genStepsItemStatusStyle = (status, token) => {
  const prefix = `${token.componentCls}-item`;
  const iconColorKey = `${status}IconColor`;
  const titleColorKey = `${status}TitleColor`;
  const descriptionColorKey = `${status}DescriptionColor`;
  const tailColorKey = `${status}TailColor`;
  const iconBgColorKey = `${status}IconBgColor`;
  const iconBorderColorKey = `${status}IconBorderColor`;
  const dotColorKey = `${status}DotColor`;
  return {
    [`${prefix}-${status} ${prefix}-icon`]: {
      backgroundColor: token[iconBgColorKey],
      borderColor: token[iconBorderColorKey],
      [`> ${token.componentCls}-icon`]: {
        color: token[iconColorKey],
        [`${token.componentCls}-icon-dot`]: {
          background: token[dotColorKey]
        }
      }
    },
    [`${prefix}-${status}${prefix}-custom ${prefix}-icon`]: {
      [`> ${token.componentCls}-icon`]: {
        color: token[dotColorKey]
      }
    },
    [`${prefix}-${status} > ${prefix}-container > ${prefix}-content > ${prefix}-title`]: {
      color: token[titleColorKey],
      "&::after": {
        backgroundColor: token[tailColorKey]
      }
    },
    [`${prefix}-${status} > ${prefix}-container > ${prefix}-content > ${prefix}-description`]: {
      color: token[descriptionColorKey]
    },
    [`${prefix}-${status} > ${prefix}-container > ${prefix}-tail::after`]: {
      backgroundColor: token[tailColorKey]
    }
  };
};
var genStepsItemStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow
  } = token;
  const stepsItemCls = `${componentCls}-item`;
  return _extends(_extends(_extends(_extends(_extends(_extends({
    [stepsItemCls]: {
      position: "relative",
      display: "inline-block",
      flex: 1,
      overflow: "hidden",
      verticalAlign: "top",
      "&:last-child": {
        flex: "none",
        [`> ${stepsItemCls}-container > ${stepsItemCls}-tail, > ${stepsItemCls}-container >  ${stepsItemCls}-content > ${stepsItemCls}-title::after`]: {
          display: "none"
        }
      }
    },
    [`${stepsItemCls}-container`]: {
      outline: "none"
    },
    [`${stepsItemCls}-icon, ${stepsItemCls}-content`]: {
      display: "inline-block",
      verticalAlign: "top"
    },
    [`${stepsItemCls}-icon`]: {
      width: token.stepsIconSize,
      height: token.stepsIconSize,
      marginTop: 0,
      marginBottom: 0,
      marginInlineStart: 0,
      marginInlineEnd: token.marginXS,
      fontSize: token.stepsIconFontSize,
      fontFamily: token.fontFamily,
      lineHeight: `${token.stepsIconSize}px`,
      textAlign: "center",
      borderRadius: token.stepsIconSize,
      border: `${token.lineWidth}px ${token.lineType} transparent`,
      transition: `background-color ${motionDurationSlow}, border-color ${motionDurationSlow}`,
      [`${componentCls}-icon`]: {
        position: "relative",
        top: token.stepsIconTop,
        color: token.colorPrimary,
        lineHeight: 1
      }
    },
    [`${stepsItemCls}-tail`]: {
      position: "absolute",
      top: token.stepsIconSize / 2 - token.paddingXXS,
      insetInlineStart: 0,
      width: "100%",
      "&::after": {
        display: "inline-block",
        width: "100%",
        height: token.lineWidth,
        background: token.colorSplit,
        borderRadius: token.lineWidth,
        transition: `background ${motionDurationSlow}`,
        content: '""'
      }
    },
    [`${stepsItemCls}-title`]: {
      position: "relative",
      display: "inline-block",
      paddingInlineEnd: token.padding,
      color: token.colorText,
      fontSize: token.fontSizeLG,
      lineHeight: `${token.stepsTitleLineHeight}px`,
      "&::after": {
        position: "absolute",
        top: token.stepsTitleLineHeight / 2,
        insetInlineStart: "100%",
        display: "block",
        width: 9999,
        height: token.lineWidth,
        background: token.processTailColor,
        content: '""'
      }
    },
    [`${stepsItemCls}-subtitle`]: {
      display: "inline",
      marginInlineStart: token.marginXS,
      color: token.colorTextDescription,
      fontWeight: "normal",
      fontSize: token.fontSize
    },
    [`${stepsItemCls}-description`]: {
      color: token.colorTextDescription,
      fontSize: token.fontSize
    }
  }, genStepsItemStatusStyle(StepItemStatusEnum.wait, token)), genStepsItemStatusStyle(StepItemStatusEnum.process, token)), {
    [`${stepsItemCls}-process > ${stepsItemCls}-container > ${stepsItemCls}-title`]: {
      fontWeight: token.fontWeightStrong
    }
  }), genStepsItemStatusStyle(StepItemStatusEnum.finish, token)), genStepsItemStatusStyle(StepItemStatusEnum.error, token)), {
    [`${stepsItemCls}${componentCls}-next-error > ${componentCls}-item-title::after`]: {
      background: token.colorError
    },
    [`${stepsItemCls}-disabled`]: {
      cursor: "not-allowed"
    }
  });
};
var genStepsClickableStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow
  } = token;
  return {
    [`& ${componentCls}-item`]: {
      [`&:not(${componentCls}-item-active)`]: {
        [`& > ${componentCls}-item-container[role='button']`]: {
          cursor: "pointer",
          [`${componentCls}-item`]: {
            [`&-title, &-subtitle, &-description, &-icon ${componentCls}-icon`]: {
              transition: `color ${motionDurationSlow}`
            }
          },
          "&:hover": {
            [`${componentCls}-item`]: {
              [`&-title, &-subtitle, &-description`]: {
                color: token.colorPrimary
              }
            }
          }
        },
        [`&:not(${componentCls}-item-process)`]: {
          [`& > ${componentCls}-item-container[role='button']:hover`]: {
            [`${componentCls}-item`]: {
              "&-icon": {
                borderColor: token.colorPrimary,
                [`${componentCls}-icon`]: {
                  color: token.colorPrimary
                }
              }
            }
          }
        }
      }
    },
    [`&${componentCls}-horizontal:not(${componentCls}-label-vertical)`]: {
      [`${componentCls}-item`]: {
        paddingInlineStart: token.padding,
        whiteSpace: "nowrap",
        "&:first-child": {
          paddingInlineStart: 0
        },
        [`&:last-child ${componentCls}-item-title`]: {
          paddingInlineEnd: 0
        },
        "&-tail": {
          display: "none"
        },
        "&-description": {
          maxWidth: token.descriptionWidth,
          whiteSpace: "normal"
        }
      }
    }
  };
};
var genStepsStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: _extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends({}, resetComponent(token)), {
      display: "flex",
      width: "100%",
      fontSize: 0,
      textAlign: "initial"
    }), genStepsItemStyle(token)), genStepsClickableStyle(token)), custom_icon_default(token)), small_default(token)), vertical_default(token)), label_placement_default(token)), progress_dot_default(token)), nav_default(token)), rtl_default(token)), progress_default3(token)), inline_default(token))
  };
};
var style_default31 = genComponentStyleHook("Steps", (token) => {
  const {
    wireframe,
    colorTextDisabled,
    fontSizeHeading3,
    fontSize,
    controlHeight,
    controlHeightLG,
    colorTextLightSolid,
    colorText,
    colorPrimary,
    colorTextLabel,
    colorTextDescription,
    colorTextQuaternary,
    colorFillContent,
    controlItemBgActive,
    colorError,
    colorBgContainer,
    colorBorderSecondary
  } = token;
  const stepsIconSize = token.controlHeight;
  const processTailColor = token.colorSplit;
  const stepsToken = merge(token, {
    // Steps variable default.less
    processTailColor,
    stepsNavArrowColor: colorTextDisabled,
    stepsIconSize,
    stepsIconCustomSize: stepsIconSize,
    stepsIconCustomTop: 0,
    stepsIconCustomFontSize: controlHeightLG / 2,
    stepsIconTop: -0.5,
    stepsIconFontSize: fontSize,
    stepsTitleLineHeight: controlHeight,
    stepsSmallIconSize: fontSizeHeading3,
    stepsDotSize: controlHeight / 4,
    stepsCurrentDotSize: controlHeightLG / 4,
    stepsNavContentMaxWidth: "auto",
    // Steps component less variable
    processIconColor: colorTextLightSolid,
    processTitleColor: colorText,
    processDescriptionColor: colorText,
    processIconBgColor: colorPrimary,
    processIconBorderColor: colorPrimary,
    processDotColor: colorPrimary,
    waitIconColor: wireframe ? colorTextDisabled : colorTextLabel,
    waitTitleColor: colorTextDescription,
    waitDescriptionColor: colorTextDescription,
    waitTailColor: processTailColor,
    waitIconBgColor: wireframe ? colorBgContainer : colorFillContent,
    waitIconBorderColor: wireframe ? colorTextDisabled : "transparent",
    waitDotColor: colorTextDisabled,
    finishIconColor: colorPrimary,
    finishTitleColor: colorText,
    finishDescriptionColor: colorTextDescription,
    finishTailColor: colorPrimary,
    finishIconBgColor: wireframe ? colorBgContainer : controlItemBgActive,
    finishIconBorderColor: wireframe ? colorPrimary : controlItemBgActive,
    finishDotColor: colorPrimary,
    errorIconColor: colorTextLightSolid,
    errorTitleColor: colorError,
    errorDescriptionColor: colorError,
    errorTailColor: processTailColor,
    errorIconBgColor: colorError,
    errorIconBorderColor: colorError,
    errorDotColor: colorError,
    stepsNavActiveColor: colorPrimary,
    stepsProgressSize: controlHeightLG,
    // Steps inline variable
    inlineDotSize: 6,
    inlineTitleColor: colorTextQuaternary,
    inlineTailColor: colorBorderSecondary
  });
  return [genStepsStyle(stepsToken)];
}, {
  descriptionWidth: 140
});

// node_modules/ant-design-vue/es/steps/index.js
var stepsProps2 = () => ({
  prefixCls: String,
  iconPrefix: String,
  current: Number,
  initial: Number,
  percent: Number,
  responsive: booleanType(),
  items: arrayType(),
  labelPlacement: stringType(),
  status: stringType(),
  size: stringType(),
  direction: stringType(),
  progressDot: someType([Boolean, Function]),
  type: stringType(),
  onChange: functionType(),
  "onUpdate:current": functionType()
});
var Steps2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASteps",
  inheritAttrs: false,
  props: initDefaultProps_default(stepsProps2(), {
    current: 0,
    responsive: true,
    labelPlacement: "horizontal"
  }),
  slots: Object,
  // emits: ['update:current', 'change'],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const {
      prefixCls,
      direction: rtlDirection,
      configProvider
    } = useConfigInject_default("steps", props2);
    const [wrapSSR, hashId] = style_default31(prefixCls);
    const [, token] = useToken();
    const screens = useBreakpoint_default();
    const direction = computed(() => props2.responsive && screens.value.xs ? "vertical" : props2.direction);
    const iconPrefix = computed(() => configProvider.getPrefixCls("", props2.iconPrefix));
    const handleChange = (current) => {
      emit("update:current", current);
      emit("change", current);
    };
    const isInline = computed(() => props2.type === "inline");
    const mergedPercent = computed(() => isInline.value ? void 0 : props2.percent);
    const stepIconRender = (_ref2) => {
      let {
        node,
        status
      } = _ref2;
      if (status === "process" && props2.percent !== void 0) {
        const progressWidth = props2.size === "small" ? token.value.controlHeight : token.value.controlHeightLG;
        const iconWithProgress = createVNode("div", {
          "class": `${prefixCls.value}-progress-icon`
        }, [createVNode(progress_default2, {
          "type": "circle",
          "percent": mergedPercent.value,
          "size": progressWidth,
          "strokeWidth": 4,
          "format": () => null
        }, null), node]);
        return iconWithProgress;
      }
      return node;
    };
    const icons2 = computed(() => ({
      finish: createVNode(CheckOutlined_default, {
        "class": `${prefixCls.value}-finish-icon`
      }, null),
      error: createVNode(CloseOutlined_default, {
        "class": `${prefixCls.value}-error-icon`
      }, null)
    }));
    return () => {
      const stepsClassName = classNames_default({
        [`${prefixCls.value}-rtl`]: rtlDirection.value === "rtl",
        [`${prefixCls.value}-with-progress`]: mergedPercent.value !== void 0
      }, attrs.class, hashId.value);
      const itemRender = (item, stepItem) => item.description ? createVNode(tooltip_default, {
        "title": item.description
      }, {
        default: () => [stepItem]
      }) : stepItem;
      return wrapSSR(createVNode(vc_steps_default, _objectSpread2(_objectSpread2(_objectSpread2({
        "icons": icons2.value
      }, attrs), omit_default(props2, ["percent", "responsive"])), {}, {
        "items": props2.items,
        "direction": direction.value,
        "prefixCls": prefixCls.value,
        "iconPrefix": iconPrefix.value,
        "class": stepsClassName,
        "onChange": handleChange,
        "isInline": isInline.value,
        "itemRender": isInline.value ? itemRender : void 0
      }), _extends({
        stepIcon: stepIconRender
      }, slots)));
    };
  }
});
var Step = defineComponent(_extends(_extends({
  compatConfig: {
    MODE: 3
  }
}, Step_default), {
  name: "AStep",
  props: VcStepProps()
}));
var steps_default = _extends(Steps2, {
  Step,
  install: (app) => {
    app.component(Steps2.name, Steps2);
    app.component(Step.name, Step);
    return app;
  }
});

// node_modules/ant-design-vue/es/switch/style/index.js
var genSwitchSmallStyle = (token) => {
  const {
    componentCls
  } = token;
  const switchInnerCls = `${componentCls}-inner`;
  return {
    [componentCls]: {
      [`&${componentCls}-small`]: {
        minWidth: token.switchMinWidthSM,
        height: token.switchHeightSM,
        lineHeight: `${token.switchHeightSM}px`,
        [`${componentCls}-inner`]: {
          paddingInlineStart: token.switchInnerMarginMaxSM,
          paddingInlineEnd: token.switchInnerMarginMinSM,
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: `calc(-100% + ${token.switchPinSizeSM + token.switchPadding * 2}px - ${token.switchInnerMarginMaxSM * 2}px)`,
            marginInlineEnd: `calc(100% - ${token.switchPinSizeSM + token.switchPadding * 2}px + ${token.switchInnerMarginMaxSM * 2}px)`
          },
          [`${switchInnerCls}-unchecked`]: {
            marginTop: -token.switchHeightSM,
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${componentCls}-handle`]: {
          width: token.switchPinSizeSM,
          height: token.switchPinSizeSM
        },
        [`${componentCls}-loading-icon`]: {
          top: (token.switchPinSizeSM - token.switchLoadingIconSize) / 2,
          fontSize: token.switchLoadingIconSize
        },
        [`&${componentCls}-checked`]: {
          [`${componentCls}-inner`]: {
            paddingInlineStart: token.switchInnerMarginMinSM,
            paddingInlineEnd: token.switchInnerMarginMaxSM,
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: `calc(100% - ${token.switchPinSizeSM + token.switchPadding * 2}px + ${token.switchInnerMarginMaxSM * 2}px)`,
              marginInlineEnd: `calc(-100% + ${token.switchPinSizeSM + token.switchPadding * 2}px - ${token.switchInnerMarginMaxSM * 2}px)`
            }
          },
          [`${componentCls}-handle`]: {
            insetInlineStart: `calc(100% - ${token.switchPinSizeSM + token.switchPadding}px)`
          }
        },
        [`&:not(${componentCls}-disabled):active`]: {
          [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: token.marginXXS / 2,
              marginInlineEnd: -token.marginXXS / 2
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: -token.marginXXS / 2,
              marginInlineEnd: token.marginXXS / 2
            }
          }
        }
      }
    }
  };
};
var genSwitchLoadingStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      [`${componentCls}-loading-icon${token.iconCls}`]: {
        position: "relative",
        top: (token.switchPinSize - token.fontSize) / 2,
        color: token.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
        color: token.switchColor
      }
    }
  };
};
var genSwitchHandleStyle = (token) => {
  const {
    componentCls
  } = token;
  const switchHandleCls = `${componentCls}-handle`;
  return {
    [componentCls]: {
      [switchHandleCls]: {
        position: "absolute",
        top: token.switchPadding,
        insetInlineStart: token.switchPadding,
        width: token.switchPinSize,
        height: token.switchPinSize,
        transition: `all ${token.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: token.colorWhite,
          borderRadius: token.switchPinSize / 2,
          boxShadow: token.switchHandleShadow,
          transition: `all ${token.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${componentCls}-checked ${switchHandleCls}`]: {
        insetInlineStart: `calc(100% - ${token.switchPinSize + token.switchPadding}px)`
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`${switchHandleCls}::before`]: {
          insetInlineEnd: token.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${componentCls}-checked ${switchHandleCls}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: token.switchHandleActiveInset
        }
      }
    }
  };
};
var genSwitchInnerStyle = (token) => {
  const {
    componentCls
  } = token;
  const switchInnerCls = `${componentCls}-inner`;
  return {
    [componentCls]: {
      [switchInnerCls]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: token.switchInnerMarginMax,
        paddingInlineEnd: token.switchInnerMarginMin,
        transition: `padding-inline-start ${token.switchDuration} ease-in-out, padding-inline-end ${token.switchDuration} ease-in-out`,
        [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
          display: "block",
          color: token.colorTextLightSolid,
          fontSize: token.fontSizeSM,
          transition: `margin-inline-start ${token.switchDuration} ease-in-out, margin-inline-end ${token.switchDuration} ease-in-out`,
          pointerEvents: "none"
        },
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: `calc(-100% + ${token.switchPinSize + token.switchPadding * 2}px - ${token.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(100% - ${token.switchPinSize + token.switchPadding * 2}px + ${token.switchInnerMarginMax * 2}px)`
        },
        [`${switchInnerCls}-unchecked`]: {
          marginTop: -token.switchHeight,
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${componentCls}-checked ${switchInnerCls}`]: {
        paddingInlineStart: token.switchInnerMarginMin,
        paddingInlineEnd: token.switchInnerMarginMax,
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${switchInnerCls}-unchecked`]: {
          marginInlineStart: `calc(100% - ${token.switchPinSize + token.switchPadding * 2}px + ${token.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(-100% + ${token.switchPinSize + token.switchPadding * 2}px - ${token.switchInnerMarginMax * 2}px)`
        }
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
          [`${switchInnerCls}-unchecked`]: {
            marginInlineStart: token.switchPadding * 2,
            marginInlineEnd: -token.switchPadding * 2
          }
        },
        [`&${componentCls}-checked ${switchInnerCls}`]: {
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: -token.switchPadding * 2,
            marginInlineEnd: token.switchPadding * 2
          }
        }
      }
    }
  };
};
var genSwitchStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: _extends(_extends(_extends(_extends({}, resetComponent(token)), {
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: token.switchMinWidth,
      height: token.switchHeight,
      lineHeight: `${token.switchHeight}px`,
      verticalAlign: "middle",
      background: token.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${token.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${componentCls}-disabled)`]: {
        background: token.colorTextTertiary
      }
    }), genFocusStyle(token)), {
      [`&${componentCls}-checked`]: {
        background: token.switchColor,
        [`&:hover:not(${componentCls}-disabled)`]: {
          background: token.colorPrimaryHover
        }
      },
      [`&${componentCls}-loading, &${componentCls}-disabled`]: {
        cursor: "not-allowed",
        opacity: token.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
};
var style_default32 = genComponentStyleHook("Switch", (token) => {
  const switchHeight = token.fontSize * token.lineHeight;
  const switchHeightSM = token.controlHeight / 2;
  const switchPadding = 2;
  const switchPinSize = switchHeight - switchPadding * 2;
  const switchPinSizeSM = switchHeightSM - switchPadding * 2;
  const switchToken = merge(token, {
    switchMinWidth: switchPinSize * 2 + switchPadding * 4,
    switchHeight,
    switchDuration: token.motionDurationMid,
    switchColor: token.colorPrimary,
    switchDisabledOpacity: token.opacityLoading,
    switchInnerMarginMin: switchPinSize / 2,
    switchInnerMarginMax: switchPinSize + switchPadding + switchPadding * 2,
    switchPadding,
    switchPinSize,
    switchBg: token.colorBgContainer,
    switchMinWidthSM: switchPinSizeSM * 2 + switchPadding * 2,
    switchHeightSM,
    switchInnerMarginMinSM: switchPinSizeSM / 2,
    switchInnerMarginMaxSM: switchPinSizeSM + switchPadding + switchPadding * 2,
    switchPinSizeSM,
    switchHandleShadow: `0 2px 4px 0 ${new TinyColor("#00230b").setAlpha(0.2).toRgbString()}`,
    switchLoadingIconSize: token.fontSizeIcon * 0.75,
    switchLoadingIconColor: `rgba(0, 0, 0, ${token.opacityLoading})`,
    switchHandleActiveInset: "-30%"
  });
  return [
    genSwitchStyle(switchToken),
    // inner style
    genSwitchInnerStyle(switchToken),
    // handle style
    genSwitchHandleStyle(switchToken),
    // loading style
    genSwitchLoadingStyle(switchToken),
    // small style
    genSwitchSmallStyle(switchToken)
  ];
});

// node_modules/ant-design-vue/es/switch/index.js
var SwitchSizes = tuple("small", "default");
var switchProps = () => ({
  id: String,
  prefixCls: String,
  size: vue_types_default.oneOf(SwitchSizes),
  disabled: {
    type: Boolean,
    default: void 0
  },
  checkedChildren: vue_types_default.any,
  unCheckedChildren: vue_types_default.any,
  tabindex: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number]),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  checked: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number, vue_types_default.looseBool]),
  checkedValue: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number, vue_types_default.looseBool]).def(true),
  unCheckedValue: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.number, vue_types_default.looseBool]).def(false),
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onMouseup: {
    type: Function
  },
  "onUpdate:checked": {
    type: Function
  },
  onBlur: Function,
  onFocus: Function
});
var Switch = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASwitch",
  __ANT_SWITCH: true,
  inheritAttrs: false,
  props: switchProps(),
  slots: Object,
  // emits: ['update:checked', 'mouseup', 'change', 'click', 'keydown', 'blur'],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      expose,
      emit
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = props2.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    onBeforeMount(() => {
      warning_default2(!("defaultChecked" in attrs), "Switch", `'defaultChecked' is deprecated, please use 'v-model:checked'`);
      warning_default2(!("value" in attrs), "Switch", "`value` is not validate prop, do you mean `checked`?");
    });
    const checked = ref(props2.checked !== void 0 ? props2.checked : attrs.defaultChecked);
    const checkedStatus = computed(() => checked.value === props2.checkedValue);
    watch(() => props2.checked, () => {
      checked.value = props2.checked;
    });
    const {
      prefixCls,
      direction,
      size
    } = useConfigInject_default("switch", props2);
    const [wrapSSR, hashId] = style_default32(prefixCls);
    const refSwitchNode = ref();
    const focus = () => {
      var _a2;
      (_a2 = refSwitchNode.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = refSwitchNode.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur
    });
    onMounted(() => {
      nextTick(() => {
        if (props2.autofocus && !mergedDisabled.value) {
          refSwitchNode.value.focus();
        }
      });
    });
    const setChecked = (check, e) => {
      if (mergedDisabled.value) {
        return;
      }
      emit("update:checked", check);
      emit("change", check, e);
      formItemContext.onFieldChange();
    };
    const handleBlur = (e) => {
      emit("blur", e);
    };
    const handleClick = (e) => {
      focus();
      const newChecked = checkedStatus.value ? props2.unCheckedValue : props2.checkedValue;
      setChecked(newChecked, e);
      emit("click", newChecked, e);
    };
    const handleKeyDown = (e) => {
      if (e.keyCode === KeyCode_default.LEFT) {
        setChecked(props2.unCheckedValue, e);
      } else if (e.keyCode === KeyCode_default.RIGHT) {
        setChecked(props2.checkedValue, e);
      }
      emit("keydown", e);
    };
    const handleMouseUp = (e) => {
      var _a2;
      (_a2 = refSwitchNode.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      emit("mouseup", e);
    };
    const classNames = computed(() => ({
      [`${prefixCls.value}-small`]: size.value === "small",
      [`${prefixCls.value}-loading`]: props2.loading,
      [`${prefixCls.value}-checked`]: checkedStatus.value,
      [`${prefixCls.value}-disabled`]: mergedDisabled.value,
      [prefixCls.value]: true,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl",
      [hashId.value]: true
    }));
    return () => {
      var _a2;
      return wrapSSR(createVNode(wave_default, null, {
        default: () => [createVNode("button", _objectSpread2(_objectSpread2(_objectSpread2({}, omit_default(props2, ["prefixCls", "checkedChildren", "unCheckedChildren", "checked", "autofocus", "checkedValue", "unCheckedValue", "id", "onChange", "onUpdate:checked"])), attrs), {}, {
          "id": (_a2 = props2.id) !== null && _a2 !== void 0 ? _a2 : formItemContext.id.value,
          "onKeydown": handleKeyDown,
          "onClick": handleClick,
          "onBlur": handleBlur,
          "onMouseup": handleMouseUp,
          "type": "button",
          "role": "switch",
          "aria-checked": checked.value,
          "disabled": mergedDisabled.value || props2.loading,
          "class": [attrs.class, classNames.value],
          "ref": refSwitchNode
        }), [createVNode("div", {
          "class": `${prefixCls.value}-handle`
        }, [props2.loading ? createVNode(LoadingOutlined_default, {
          "class": `${prefixCls.value}-loading-icon`
        }, null) : null]), createVNode("span", {
          "class": `${prefixCls.value}-inner`
        }, [createVNode("span", {
          "class": `${prefixCls.value}-inner-checked`
        }, [getPropsSlot(slots, props2, "checkedChildren")]), createVNode("span", {
          "class": `${prefixCls.value}-inner-unchecked`
        }, [getPropsSlot(slots, props2, "unCheckedChildren")])])])]
      }));
    };
  }
});
var switch_default = withInstall(Switch);

// node_modules/ant-design-vue/es/transfer/search.js
var transferSearchProps = {
  prefixCls: String,
  placeholder: String,
  value: String,
  handleClear: Function,
  disabled: {
    type: Boolean,
    default: void 0
  },
  onChange: Function
};
var search_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Search",
  inheritAttrs: false,
  props: initDefaultProps_default(transferSearchProps, {
    placeholder: ""
  }),
  emits: ["change"],
  setup(props2, _ref) {
    let {
      emit
    } = _ref;
    const handleChange = (e) => {
      var _a2;
      emit("change", e);
      if (e.target.value === "") {
        (_a2 = props2.handleClear) === null || _a2 === void 0 ? void 0 : _a2.call(props2);
      }
    };
    return () => {
      const {
        placeholder,
        value,
        prefixCls,
        disabled
      } = props2;
      return createVNode(input_default, {
        "placeholder": placeholder,
        "class": prefixCls,
        "value": value,
        "onChange": handleChange,
        "disabled": disabled,
        "allowClear": true
      }, {
        prefix: () => createVNode(SearchOutlined_default, null, null)
      });
    };
  }
});

// node_modules/ant-design-vue/es/transfer/ListItem.js
function noop8() {
}
var transferListItemProps = {
  renderedText: vue_types_default.any,
  renderedEl: vue_types_default.any,
  item: vue_types_default.any,
  checked: booleanType(),
  prefixCls: String,
  disabled: booleanType(),
  showRemove: booleanType(),
  onClick: Function,
  onRemove: Function
};
var ListItem_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: false,
  props: transferListItemProps,
  emits: ["click", "remove"],
  setup(props2, _ref) {
    let {
      emit
    } = _ref;
    return () => {
      const {
        renderedText,
        renderedEl,
        item,
        checked,
        disabled,
        prefixCls,
        showRemove
      } = props2;
      const className = classNames_default({
        [`${prefixCls}-content-item`]: true,
        [`${prefixCls}-content-item-disabled`]: disabled || item.disabled
      });
      let title;
      if (typeof renderedText === "string" || typeof renderedText === "number") {
        title = String(renderedText);
      }
      return createVNode(LocaleReceiver_default2, {
        "componentName": "Transfer",
        "defaultLocale": en_US_default3.Transfer
      }, {
        default: (transferLocale) => {
          const labelNode = createVNode("span", {
            "class": `${prefixCls}-content-item-text`
          }, [renderedEl]);
          if (showRemove) {
            return createVNode("li", {
              "class": className,
              "title": title
            }, [labelNode, createVNode(transButton_default, {
              "disabled": disabled || item.disabled,
              "class": `${prefixCls}-content-item-remove`,
              "aria-label": transferLocale.remove,
              "onClick": () => {
                emit("remove", item);
              }
            }, {
              default: () => [createVNode(DeleteOutlined_default, null, null)]
            })]);
          }
          return createVNode("li", {
            "class": className,
            "title": title,
            "onClick": disabled || item.disabled ? noop8 : () => {
              emit("click", item);
            }
          }, [createVNode(checkbox_default, {
            "class": `${prefixCls}-checkbox`,
            "checked": checked,
            "disabled": disabled || item.disabled
          }, null), labelNode]);
        }
      });
    };
  }
});

// node_modules/ant-design-vue/es/transfer/ListBody.js
var transferListBodyProps = {
  prefixCls: String,
  filteredRenderItems: vue_types_default.array.def([]),
  selectedKeys: vue_types_default.array,
  disabled: booleanType(),
  showRemove: booleanType(),
  pagination: vue_types_default.any,
  onItemSelect: Function,
  onScroll: Function,
  onItemRemove: Function
};
function parsePagination(pagination) {
  if (!pagination) {
    return null;
  }
  const defaultPagination = {
    pageSize: 10,
    simple: true,
    showSizeChanger: false,
    showLessItems: false
  };
  if (typeof pagination === "object") {
    return _extends(_extends({}, defaultPagination), pagination);
  }
  return defaultPagination;
}
var ListBody = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ListBody",
  inheritAttrs: false,
  props: transferListBodyProps,
  emits: ["itemSelect", "itemRemove", "scroll"],
  setup(props2, _ref) {
    let {
      emit,
      expose
    } = _ref;
    const current = ref(1);
    const handleItemSelect = (item) => {
      const {
        selectedKeys
      } = props2;
      const checked = selectedKeys.indexOf(item.key) >= 0;
      emit("itemSelect", item.key, !checked);
    };
    const handleItemRemove = (item) => {
      emit("itemRemove", [item.key]);
    };
    const handleScroll = (e) => {
      emit("scroll", e);
    };
    const mergedPagination = computed(() => parsePagination(props2.pagination));
    watch([mergedPagination, () => props2.filteredRenderItems], () => {
      if (mergedPagination.value) {
        const maxPageCount = Math.ceil(props2.filteredRenderItems.length / mergedPagination.value.pageSize);
        current.value = Math.min(current.value, maxPageCount);
      }
    }, {
      immediate: true
    });
    const items = computed(() => {
      const {
        filteredRenderItems
      } = props2;
      let displayItems = filteredRenderItems;
      if (mergedPagination.value) {
        displayItems = filteredRenderItems.slice((current.value - 1) * mergedPagination.value.pageSize, current.value * mergedPagination.value.pageSize);
      }
      return displayItems;
    });
    const onPageChange = (cur) => {
      current.value = cur;
    };
    expose({
      items
    });
    return () => {
      const {
        prefixCls,
        filteredRenderItems,
        selectedKeys,
        disabled: globalDisabled,
        showRemove
      } = props2;
      let paginationNode = null;
      if (mergedPagination.value) {
        paginationNode = createVNode(pagination_default, {
          "simple": mergedPagination.value.simple,
          "showSizeChanger": mergedPagination.value.showSizeChanger,
          "showLessItems": mergedPagination.value.showLessItems,
          "size": "small",
          "disabled": globalDisabled,
          "class": `${prefixCls}-pagination`,
          "total": filteredRenderItems.length,
          "pageSize": mergedPagination.value.pageSize,
          "current": current.value,
          "onChange": onPageChange
        }, null);
      }
      const itemsList = items.value.map((_ref2) => {
        let {
          renderedEl,
          renderedText,
          item
        } = _ref2;
        const {
          disabled
        } = item;
        const checked = selectedKeys.indexOf(item.key) >= 0;
        return createVNode(ListItem_default, {
          "disabled": globalDisabled || disabled,
          "key": item.key,
          "item": item,
          "renderedText": renderedText,
          "renderedEl": renderedEl,
          "checked": checked,
          "prefixCls": prefixCls,
          "onClick": handleItemSelect,
          "onRemove": handleItemRemove,
          "showRemove": showRemove
        }, null);
      });
      return createVNode(Fragment, null, [createVNode("ul", {
        "class": classNames_default(`${prefixCls}-content`, {
          [`${prefixCls}-content-show-remove`]: showRemove
        }),
        "onScroll": handleScroll
      }, [itemsList]), paginationNode]);
    };
  }
});
var ListBody_default = ListBody;

// node_modules/ant-design-vue/es/_util/transKeys.js
var groupKeysMap = (keys) => {
  const map = /* @__PURE__ */ new Map();
  keys.forEach((key, index2) => {
    map.set(key, index2);
  });
  return map;
};
var groupDisabledKeysMap = (dataSource) => {
  const map = /* @__PURE__ */ new Map();
  dataSource.forEach((_ref, index2) => {
    let {
      disabled,
      key
    } = _ref;
    if (disabled) {
      map.set(key, index2);
    }
  });
  return map;
};

// node_modules/ant-design-vue/es/transfer/list.js
var defaultRender2 = () => null;
function isRenderResultPlainObject(result) {
  return !!(result && !isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
}
function getEnabledItemKeys(items) {
  return items.filter((data) => !data.disabled).map((data) => data.key);
}
var transferListProps = {
  prefixCls: String,
  dataSource: arrayType([]),
  filter: String,
  filterOption: Function,
  checkedKeys: vue_types_default.arrayOf(vue_types_default.string),
  handleFilter: Function,
  handleClear: Function,
  renderItem: Function,
  showSearch: booleanType(false),
  searchPlaceholder: String,
  notFoundContent: vue_types_default.any,
  itemUnit: String,
  itemsUnit: String,
  renderList: vue_types_default.any,
  disabled: booleanType(),
  direction: stringType(),
  showSelectAll: booleanType(),
  remove: String,
  selectAll: String,
  selectCurrent: String,
  selectInvert: String,
  removeAll: String,
  removeCurrent: String,
  selectAllLabel: vue_types_default.any,
  showRemove: booleanType(),
  pagination: vue_types_default.any,
  onItemSelect: Function,
  onItemSelectAll: Function,
  onItemRemove: Function,
  onScroll: Function
};
var list_default2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TransferList",
  inheritAttrs: false,
  props: transferListProps,
  // emits: ['scroll', 'itemSelectAll', 'itemRemove', 'itemSelect'],
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const filterValue = ref("");
    const transferNode = ref();
    const defaultListBodyRef = ref();
    const renderListBody = (renderList, props3) => {
      let bodyContent = renderList ? renderList(props3) : null;
      const customize = !!bodyContent && filterEmpty(bodyContent).length > 0;
      if (!customize) {
        bodyContent = createVNode(ListBody_default, _objectSpread2(_objectSpread2({}, props3), {}, {
          "ref": defaultListBodyRef
        }), null);
      }
      return {
        customize,
        bodyContent
      };
    };
    const renderItemHtml = (item) => {
      const {
        renderItem = defaultRender2
      } = props2;
      const renderResult = renderItem(item);
      const isRenderResultPlain = isRenderResultPlainObject(renderResult);
      return {
        renderedText: isRenderResultPlain ? renderResult.value : renderResult,
        renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
        item
      };
    };
    const filteredItems = ref([]);
    const filteredRenderItems = ref([]);
    watchEffect(() => {
      const fItems = [];
      const fRenderItems = [];
      props2.dataSource.forEach((item) => {
        const renderedItem = renderItemHtml(item);
        const {
          renderedText
        } = renderedItem;
        if (filterValue.value && filterValue.value.trim() && !matchFilter(renderedText, item)) {
          return null;
        }
        fItems.push(item);
        fRenderItems.push(renderedItem);
      });
      filteredItems.value = fItems;
      filteredRenderItems.value = fRenderItems;
    });
    const checkStatus = computed(() => {
      const {
        checkedKeys
      } = props2;
      if (checkedKeys.length === 0) {
        return "none";
      }
      const checkedKeysMap = groupKeysMap(checkedKeys);
      if (filteredItems.value.every((item) => checkedKeysMap.has(item.key) || !!item.disabled)) {
        return "all";
      }
      return "part";
    });
    const enabledItemKeys = computed(() => {
      return getEnabledItemKeys(filteredItems.value);
    });
    const getNewSelectKeys = (keys, unCheckedKeys) => {
      return Array.from(/* @__PURE__ */ new Set([...keys, ...props2.checkedKeys])).filter((key) => unCheckedKeys.indexOf(key) === -1);
    };
    const getCheckBox = (_ref2) => {
      let {
        disabled,
        prefixCls
      } = _ref2;
      var _a2;
      const checkedAll = checkStatus.value === "all";
      const checkAllCheckbox = createVNode(checkbox_default, {
        "disabled": ((_a2 = props2.dataSource) === null || _a2 === void 0 ? void 0 : _a2.length) === 0 || disabled,
        "checked": checkedAll,
        "indeterminate": checkStatus.value === "part",
        "class": `${prefixCls}-checkbox`,
        "onChange": () => {
          const keys = enabledItemKeys.value;
          props2.onItemSelectAll(getNewSelectKeys(!checkedAll ? keys : [], checkedAll ? props2.checkedKeys : []));
        }
      }, null);
      return checkAllCheckbox;
    };
    const handleFilter = (e) => {
      var _a2;
      const {
        target: {
          value: filter
        }
      } = e;
      filterValue.value = filter;
      (_a2 = props2.handleFilter) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
    };
    const handleClear = (e) => {
      var _a2;
      filterValue.value = "";
      (_a2 = props2.handleClear) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
    };
    const matchFilter = (text, item) => {
      const {
        filterOption: filterOption2
      } = props2;
      if (filterOption2) {
        return filterOption2(filterValue.value, item);
      }
      return text.includes(filterValue.value);
    };
    const getSelectAllLabel = (selectedCount, totalCount) => {
      const {
        itemsUnit,
        itemUnit,
        selectAllLabel
      } = props2;
      if (selectAllLabel) {
        return typeof selectAllLabel === "function" ? selectAllLabel({
          selectedCount,
          totalCount
        }) : selectAllLabel;
      }
      const unit = totalCount > 1 ? itemsUnit : itemUnit;
      return createVNode(Fragment, null, [(selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, createTextVNode(" "), unit]);
    };
    const notFoundContentEle = computed(() => Array.isArray(props2.notFoundContent) ? props2.notFoundContent[props2.direction === "left" ? 0 : 1] : props2.notFoundContent);
    const getListBody = (prefixCls, searchPlaceholder, checkedKeys, renderList, showSearch, disabled) => {
      const search = showSearch ? createVNode("div", {
        "class": `${prefixCls}-body-search-wrapper`
      }, [createVNode(search_default, {
        "prefixCls": `${prefixCls}-search`,
        "onChange": handleFilter,
        "handleClear": handleClear,
        "placeholder": searchPlaceholder,
        "value": filterValue.value,
        "disabled": disabled
      }, null)]) : null;
      let bodyNode;
      const {
        onEvents
      } = splitAttrs(attrs);
      const {
        bodyContent,
        customize
      } = renderListBody(renderList, _extends(_extends(_extends({}, props2), {
        filteredItems: filteredItems.value,
        filteredRenderItems: filteredRenderItems.value,
        selectedKeys: checkedKeys
      }), onEvents));
      if (customize) {
        bodyNode = createVNode("div", {
          "class": `${prefixCls}-body-customize-wrapper`
        }, [bodyContent]);
      } else {
        bodyNode = filteredItems.value.length ? bodyContent : createVNode("div", {
          "class": `${prefixCls}-body-not-found`
        }, [notFoundContentEle.value]);
      }
      return createVNode("div", {
        "class": showSearch ? `${prefixCls}-body ${prefixCls}-body-with-search` : `${prefixCls}-body`,
        "ref": transferNode
      }, [search, bodyNode]);
    };
    return () => {
      var _a2, _b;
      const {
        prefixCls,
        checkedKeys,
        disabled,
        showSearch,
        searchPlaceholder,
        selectAll,
        selectCurrent,
        selectInvert,
        removeAll,
        removeCurrent,
        renderList,
        onItemSelectAll,
        onItemRemove,
        showSelectAll = true,
        showRemove,
        pagination
      } = props2;
      const footerDom = (_a2 = slots.footer) === null || _a2 === void 0 ? void 0 : _a2.call(slots, _extends({}, props2));
      const listCls = classNames_default(prefixCls, {
        [`${prefixCls}-with-pagination`]: !!pagination,
        [`${prefixCls}-with-footer`]: !!footerDom
      });
      const listBody = getListBody(prefixCls, searchPlaceholder, checkedKeys, renderList, showSearch, disabled);
      const listFooter = footerDom ? createVNode("div", {
        "class": `${prefixCls}-footer`
      }, [footerDom]) : null;
      const checkAllCheckbox = !showRemove && !pagination && getCheckBox({
        disabled,
        prefixCls
      });
      let menu = null;
      if (showRemove) {
        menu = createVNode(menu_default, null, {
          default: () => [pagination && createVNode(menu_default.Item, {
            "key": "removeCurrent",
            "onClick": () => {
              const pageKeys = getEnabledItemKeys((defaultListBodyRef.value.items || []).map((entity) => entity.item));
              onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(pageKeys);
            }
          }, {
            default: () => [removeCurrent]
          }), createVNode(menu_default.Item, {
            "key": "removeAll",
            "onClick": () => {
              onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(enabledItemKeys.value);
            }
          }, {
            default: () => [removeAll]
          })]
        });
      } else {
        menu = createVNode(menu_default, null, {
          default: () => [createVNode(menu_default.Item, {
            "key": "selectAll",
            "onClick": () => {
              const keys = enabledItemKeys.value;
              onItemSelectAll(getNewSelectKeys(keys, []));
            }
          }, {
            default: () => [selectAll]
          }), pagination && createVNode(menu_default.Item, {
            "onClick": () => {
              const pageKeys = getEnabledItemKeys((defaultListBodyRef.value.items || []).map((entity) => entity.item));
              onItemSelectAll(getNewSelectKeys(pageKeys, []));
            }
          }, {
            default: () => [selectCurrent]
          }), createVNode(menu_default.Item, {
            "key": "selectInvert",
            "onClick": () => {
              let availableKeys;
              if (pagination) {
                availableKeys = getEnabledItemKeys((defaultListBodyRef.value.items || []).map((entity) => entity.item));
              } else {
                availableKeys = enabledItemKeys.value;
              }
              const checkedKeySet = new Set(checkedKeys);
              const newCheckedKeys = [];
              const newUnCheckedKeys = [];
              availableKeys.forEach((key) => {
                if (checkedKeySet.has(key)) {
                  newUnCheckedKeys.push(key);
                } else {
                  newCheckedKeys.push(key);
                }
              });
              onItemSelectAll(getNewSelectKeys(newCheckedKeys, newUnCheckedKeys));
            }
          }, {
            default: () => [selectInvert]
          })]
        });
      }
      const dropdown = createVNode(dropdown_default2, {
        "class": `${prefixCls}-header-dropdown`,
        "overlay": menu,
        "disabled": disabled
      }, {
        default: () => [createVNode(DownOutlined_default, null, null)]
      });
      return createVNode("div", {
        "class": listCls,
        "style": attrs.style
      }, [createVNode("div", {
        "class": `${prefixCls}-header`
      }, [showSelectAll ? createVNode(Fragment, null, [checkAllCheckbox, dropdown]) : null, createVNode("span", {
        "class": `${prefixCls}-header-selected`
      }, [createVNode("span", null, [getSelectAllLabel(checkedKeys.length, filteredItems.value.length)]), createVNode("span", {
        "class": `${prefixCls}-header-title`
      }, [(_b = slots.titleText) === null || _b === void 0 ? void 0 : _b.call(slots)])])]), listBody, listFooter]);
    };
  }
});

// node_modules/ant-design-vue/es/transfer/operation.js
function noop9() {
}
var Operation = (props2) => {
  const {
    disabled,
    moveToLeft = noop9,
    moveToRight = noop9,
    leftArrowText = "",
    rightArrowText = "",
    leftActive,
    rightActive,
    class: className,
    style,
    direction,
    oneWay
  } = props2;
  return createVNode("div", {
    "class": className,
    "style": style
  }, [createVNode(button_default, {
    "type": "primary",
    "size": "small",
    "disabled": disabled || !rightActive,
    "onClick": moveToRight,
    "icon": direction !== "rtl" ? createVNode(RightOutlined_default, null, null) : createVNode(LeftOutlined_default, null, null)
  }, {
    default: () => [rightArrowText]
  }), !oneWay && createVNode(button_default, {
    "type": "primary",
    "size": "small",
    "disabled": disabled || !leftActive,
    "onClick": moveToLeft,
    "icon": direction !== "rtl" ? createVNode(LeftOutlined_default, null, null) : createVNode(RightOutlined_default, null, null)
  }, {
    default: () => [leftArrowText]
  })]);
};
Operation.displayName = "Operation";
Operation.inheritAttrs = false;
var operation_default = Operation;

// node_modules/ant-design-vue/es/transfer/style/index.js
var genTransferCustomizeStyle = (token) => {
  const {
    antCls,
    componentCls,
    listHeight,
    controlHeightLG,
    marginXXS,
    margin
  } = token;
  const tableCls = `${antCls}-table`;
  const inputCls = `${antCls}-input`;
  return {
    [`${componentCls}-customize-list`]: {
      [`${componentCls}-list`]: {
        flex: "1 1 50%",
        width: "auto",
        height: "auto",
        minHeight: listHeight
      },
      // =================== Hook Components ===================
      [`${tableCls}-wrapper`]: {
        [`${tableCls}-small`]: {
          border: 0,
          borderRadius: 0,
          [`${tableCls}-selection-column`]: {
            width: controlHeightLG,
            minWidth: controlHeightLG
          }
        },
        [`${tableCls}-pagination${tableCls}-pagination`]: {
          margin: `${margin}px 0 ${marginXXS}px`
        }
      },
      [`${inputCls}[disabled]`]: {
        backgroundColor: "transparent"
      }
    }
  };
};
var genTransferStatusColor = (token, color) => {
  const {
    componentCls,
    colorBorder
  } = token;
  return {
    [`${componentCls}-list`]: {
      borderColor: color,
      "&-search:not([disabled])": {
        borderColor: colorBorder
      }
    }
  };
};
var genTransferStatusStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-status-error`]: _extends({}, genTransferStatusColor(token, token.colorError)),
    [`${componentCls}-status-warning`]: _extends({}, genTransferStatusColor(token, token.colorWarning))
  };
};
var genTransferListStyle = (token) => {
  const {
    componentCls,
    colorBorder,
    colorSplit,
    lineWidth,
    transferItemHeight,
    transferHeaderHeight,
    transferHeaderVerticalPadding,
    transferItemPaddingVertical,
    controlItemBgActive,
    controlItemBgActiveHover,
    colorTextDisabled,
    listHeight,
    listWidth,
    listWidthLG,
    fontSizeIcon,
    marginXS,
    paddingSM,
    lineType,
    iconCls,
    motionDurationSlow
  } = token;
  return {
    display: "flex",
    flexDirection: "column",
    width: listWidth,
    height: listHeight,
    border: `${lineWidth}px ${lineType} ${colorBorder}`,
    borderRadius: token.borderRadiusLG,
    "&-with-pagination": {
      width: listWidthLG,
      height: "auto"
    },
    "&-search": {
      [`${iconCls}-search`]: {
        color: colorTextDisabled
      }
    },
    "&-header": {
      display: "flex",
      flex: "none",
      alignItems: "center",
      height: transferHeaderHeight,
      // border-top is on the transfer dom. We should minus 1px for this
      padding: `${transferHeaderVerticalPadding - lineWidth}px ${paddingSM}px ${transferHeaderVerticalPadding}px`,
      color: token.colorText,
      background: token.colorBgContainer,
      borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
      borderRadius: `${token.borderRadiusLG}px ${token.borderRadiusLG}px 0 0`,
      "> *:not(:last-child)": {
        marginInlineEnd: 4
        // This is magic and fixed number, DO NOT use token since it may change.
      },
      "> *": {
        flex: "none"
      },
      "&-title": _extends(_extends({}, textEllipsis), {
        flex: "auto",
        textAlign: "end"
      }),
      "&-dropdown": _extends(_extends({}, resetIcon()), {
        fontSize: fontSizeIcon,
        transform: "translateY(10%)",
        cursor: "pointer",
        "&[disabled]": {
          cursor: "not-allowed"
        }
      })
    },
    "&-body": {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      overflow: "hidden",
      fontSize: token.fontSize,
      "&-search-wrapper": {
        position: "relative",
        flex: "none",
        padding: paddingSM
      }
    },
    "&-content": {
      flex: "auto",
      margin: 0,
      padding: 0,
      overflow: "auto",
      listStyle: "none",
      "&-item": {
        display: "flex",
        alignItems: "center",
        minHeight: transferItemHeight,
        padding: `${transferItemPaddingVertical}px ${paddingSM}px`,
        transition: `all ${motionDurationSlow}`,
        "> *:not(:last-child)": {
          marginInlineEnd: marginXS
        },
        "> *": {
          flex: "none"
        },
        "&-text": _extends(_extends({}, textEllipsis), {
          flex: "auto"
        }),
        "&-remove": {
          position: "relative",
          color: colorBorder,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: token.colorLinkHover
          },
          "&::after": {
            position: "absolute",
            insert: `-${transferItemPaddingVertical}px -50%`,
            content: '""'
          }
        },
        [`&:not(${componentCls}-list-content-item-disabled)`]: {
          "&:hover": {
            backgroundColor: token.controlItemBgHover,
            cursor: "pointer"
          },
          [`&${componentCls}-list-content-item-checked:hover`]: {
            backgroundColor: controlItemBgActiveHover
          }
        },
        "&-checked": {
          backgroundColor: controlItemBgActive
        },
        "&-disabled": {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // Do not change hover style when `oneWay` mode
      [`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
        background: "transparent",
        cursor: "default"
      }
    },
    "&-pagination": {
      padding: `${token.paddingXS}px 0`,
      textAlign: "end",
      borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
    },
    "&-body-not-found": {
      flex: "none",
      width: "100%",
      margin: "auto 0",
      color: colorTextDisabled,
      textAlign: "center"
    },
    "&-footer": {
      borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
    },
    "&-checkbox": {
      lineHeight: 1
    }
  };
};
var genTransferStyle = (token) => {
  const {
    antCls,
    iconCls,
    componentCls,
    transferHeaderHeight,
    marginXS,
    marginXXS,
    fontSizeIcon,
    fontSize,
    lineHeight
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      position: "relative",
      display: "flex",
      alignItems: "stretch",
      [`${componentCls}-disabled`]: {
        [`${componentCls}-list`]: {
          background: token.colorBgContainerDisabled
        }
      },
      [`${componentCls}-list`]: genTransferListStyle(token),
      [`${componentCls}-operation`]: {
        display: "flex",
        flex: "none",
        flexDirection: "column",
        alignSelf: "center",
        margin: `0 ${marginXS}px`,
        verticalAlign: "middle",
        [`${antCls}-btn`]: {
          display: "block",
          "&:first-child": {
            marginBottom: marginXXS
          },
          [iconCls]: {
            fontSize: fontSizeIcon
          }
        }
      },
      [`${antCls}-empty-image`]: {
        maxHeight: transferHeaderHeight / 2 - Math.round(fontSize * lineHeight)
      }
    })
  };
};
var genTransferRTLStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var style_default33 = genComponentStyleHook("Transfer", (token) => {
  const {
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightLG,
    controlHeight
  } = token;
  const fontHeight = Math.round(fontSize * lineHeight);
  const transferHeaderHeight = controlHeightLG;
  const transferItemHeight = controlHeight;
  const transferToken = merge(token, {
    transferItemHeight,
    transferHeaderHeight,
    transferHeaderVerticalPadding: Math.ceil((transferHeaderHeight - lineWidth - fontHeight) / 2),
    transferItemPaddingVertical: (transferItemHeight - fontHeight) / 2
  });
  return [genTransferStyle(transferToken), genTransferCustomizeStyle(transferToken), genTransferStatusStyle(transferToken), genTransferRTLStyle(transferToken)];
}, {
  listWidth: 180,
  listHeight: 200,
  listWidthLG: 250
});

// node_modules/ant-design-vue/es/transfer/index.js
var transferProps = () => ({
  id: String,
  prefixCls: String,
  dataSource: arrayType([]),
  disabled: booleanType(),
  targetKeys: arrayType(),
  selectedKeys: arrayType(),
  render: functionType(),
  listStyle: someType([Function, Object], () => ({})),
  operationStyle: objectType(void 0),
  titles: arrayType(),
  operations: arrayType(),
  showSearch: booleanType(false),
  filterOption: functionType(),
  searchPlaceholder: String,
  notFoundContent: vue_types_default.any,
  locale: objectType(),
  rowKey: functionType(),
  showSelectAll: booleanType(),
  selectAllLabels: arrayType(),
  children: functionType(),
  oneWay: booleanType(),
  pagination: someType([Object, Boolean]),
  status: stringType(),
  onChange: functionType(),
  onSelectChange: functionType(),
  onSearch: functionType(),
  onScroll: functionType(),
  "onUpdate:targetKeys": functionType(),
  "onUpdate:selectedKeys": functionType()
});
var Transfer = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATransfer",
  inheritAttrs: false,
  props: transferProps(),
  slots: Object,
  // emits: ['update:targetKeys', 'update:selectedKeys', 'change', 'search', 'scroll', 'selectChange'],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      slots,
      expose
    } = _ref;
    const {
      configProvider,
      prefixCls,
      direction
    } = useConfigInject_default("transfer", props2);
    const [wrapSSR, hashId] = style_default33(prefixCls);
    const sourceSelectedKeys = ref([]);
    const targetSelectedKeys = ref([]);
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    watch(() => props2.selectedKeys, () => {
      var _a2, _b;
      sourceSelectedKeys.value = ((_a2 = props2.selectedKeys) === null || _a2 === void 0 ? void 0 : _a2.filter((key) => props2.targetKeys.indexOf(key) === -1)) || [];
      targetSelectedKeys.value = ((_b = props2.selectedKeys) === null || _b === void 0 ? void 0 : _b.filter((key) => props2.targetKeys.indexOf(key) > -1)) || [];
    }, {
      immediate: true
    });
    const getLocale = (transferLocale, renderEmpty) => {
      const oldLocale = {
        notFoundContent: renderEmpty("Transfer")
      };
      const notFoundContent = getPropsSlot(slots, props2, "notFoundContent");
      if (notFoundContent) {
        oldLocale.notFoundContent = notFoundContent;
      }
      if (props2.searchPlaceholder !== void 0) {
        oldLocale.searchPlaceholder = props2.searchPlaceholder;
      }
      return _extends(_extends(_extends({}, transferLocale), oldLocale), props2.locale);
    };
    const moveTo = (direction2) => {
      const {
        targetKeys = [],
        dataSource = []
      } = props2;
      const moveKeys = direction2 === "right" ? sourceSelectedKeys.value : targetSelectedKeys.value;
      const dataSourceDisabledKeysMap = groupDisabledKeysMap(dataSource);
      const newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key));
      const newMoveKeysMap = groupKeysMap(newMoveKeys);
      const newTargetKeys = direction2 === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey));
      const oppositeDirection = direction2 === "right" ? "left" : "right";
      direction2 === "right" ? sourceSelectedKeys.value = [] : targetSelectedKeys.value = [];
      emit("update:targetKeys", newTargetKeys);
      handleSelectChange(oppositeDirection, []);
      emit("change", newTargetKeys, direction2, newMoveKeys);
      formItemContext.onFieldChange();
    };
    const moveToLeft = () => {
      moveTo("left");
    };
    const moveToRight = () => {
      moveTo("right");
    };
    const onItemSelectAll = (direction2, selectedKeys) => {
      handleSelectChange(direction2, selectedKeys);
    };
    const onLeftItemSelectAll = (selectedKeys) => {
      return onItemSelectAll("left", selectedKeys);
    };
    const onRightItemSelectAll = (selectedKeys) => {
      return onItemSelectAll("right", selectedKeys);
    };
    const handleSelectChange = (direction2, holder) => {
      if (direction2 === "left") {
        if (!props2.selectedKeys) {
          sourceSelectedKeys.value = holder;
        }
        emit("update:selectedKeys", [...holder, ...targetSelectedKeys.value]);
        emit("selectChange", holder, toRaw(targetSelectedKeys.value));
      } else {
        if (!props2.selectedKeys) {
          targetSelectedKeys.value = holder;
        }
        emit("update:selectedKeys", [...holder, ...sourceSelectedKeys.value]);
        emit("selectChange", toRaw(sourceSelectedKeys.value), holder);
      }
    };
    const handleFilter = (direction2, e) => {
      const value = e.target.value;
      emit("search", direction2, value);
    };
    const handleLeftFilter = (e) => {
      handleFilter("left", e);
    };
    const handleRightFilter = (e) => {
      handleFilter("right", e);
    };
    const handleClear = (direction2) => {
      emit("search", direction2, "");
    };
    const handleLeftClear = () => {
      handleClear("left");
    };
    const handleRightClear = () => {
      handleClear("right");
    };
    const onItemSelect = (direction2, selectedKey, checked) => {
      const holder = direction2 === "left" ? [...sourceSelectedKeys.value] : [...targetSelectedKeys.value];
      const index2 = holder.indexOf(selectedKey);
      if (index2 > -1) {
        holder.splice(index2, 1);
      }
      if (checked) {
        holder.push(selectedKey);
      }
      handleSelectChange(direction2, holder);
    };
    const onLeftItemSelect = (selectedKey, checked) => {
      return onItemSelect("left", selectedKey, checked);
    };
    const onRightItemSelect = (selectedKey, checked) => {
      return onItemSelect("right", selectedKey, checked);
    };
    const onRightItemRemove = (targetedKeys) => {
      const {
        targetKeys = []
      } = props2;
      const newTargetKeys = targetKeys.filter((key) => !targetedKeys.includes(key));
      emit("update:targetKeys", newTargetKeys);
      emit("change", newTargetKeys, "left", [...targetedKeys]);
    };
    const handleScroll = (direction2, e) => {
      emit("scroll", direction2, e);
    };
    const handleLeftScroll = (e) => {
      handleScroll("left", e);
    };
    const handleRightScroll = (e) => {
      handleScroll("right", e);
    };
    const handleListStyle = (listStyle, direction2) => {
      if (typeof listStyle === "function") {
        return listStyle({
          direction: direction2
        });
      }
      return listStyle;
    };
    const leftDataSource = ref([]);
    const rightDataSource = ref([]);
    watchEffect(() => {
      const {
        dataSource,
        rowKey,
        targetKeys = []
      } = props2;
      const ld = [];
      const rd = new Array(targetKeys.length);
      const targetKeysMap = groupKeysMap(targetKeys);
      dataSource.forEach((record) => {
        if (rowKey) {
          record.key = rowKey(record);
        }
        if (targetKeysMap.has(record.key)) {
          rd[targetKeysMap.get(record.key)] = record;
        } else {
          ld.push(record);
        }
      });
      leftDataSource.value = ld;
      rightDataSource.value = rd;
    });
    expose({
      handleSelectChange
    });
    const renderTransfer = (transferLocale) => {
      var _a2, _b, _c, _d, _e, _f;
      const {
        disabled,
        operations = [],
        showSearch,
        listStyle,
        operationStyle,
        filterOption: filterOption2,
        showSelectAll,
        selectAllLabels = [],
        oneWay,
        pagination,
        id = formItemContext.id.value
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const children = slots.children;
      const mergedPagination = !children && pagination;
      const renderEmpty = configProvider.renderEmpty;
      const locale = getLocale(transferLocale, renderEmpty);
      const {
        footer
      } = slots;
      const renderItem = props2.render || slots.render;
      const leftActive = targetSelectedKeys.value.length > 0;
      const rightActive = sourceSelectedKeys.value.length > 0;
      const cls = classNames_default(prefixCls.value, className, {
        [`${prefixCls.value}-disabled`]: disabled,
        [`${prefixCls.value}-customize-list`]: !!children,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, getStatusClassNames(prefixCls.value, mergedStatus.value, formItemInputContext.hasFeedback), hashId.value);
      const titles = props2.titles;
      const leftTitle = (_c = (_a2 = titles && titles[0]) !== null && _a2 !== void 0 ? _a2 : (_b = slots.leftTitle) === null || _b === void 0 ? void 0 : _b.call(slots)) !== null && _c !== void 0 ? _c : (locale.titles || ["", ""])[0];
      const rightTitle = (_f = (_d = titles && titles[1]) !== null && _d !== void 0 ? _d : (_e = slots.rightTitle) === null || _e === void 0 ? void 0 : _e.call(slots)) !== null && _f !== void 0 ? _f : (locale.titles || ["", ""])[1];
      return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": cls,
        "style": style,
        "id": id
      }), [createVNode(list_default2, _objectSpread2({
        "key": "leftList",
        "prefixCls": `${prefixCls.value}-list`,
        "dataSource": leftDataSource.value,
        "filterOption": filterOption2,
        "style": handleListStyle(listStyle, "left"),
        "checkedKeys": sourceSelectedKeys.value,
        "handleFilter": handleLeftFilter,
        "handleClear": handleLeftClear,
        "onItemSelect": onLeftItemSelect,
        "onItemSelectAll": onLeftItemSelectAll,
        "renderItem": renderItem,
        "showSearch": showSearch,
        "renderList": children,
        "onScroll": handleLeftScroll,
        "disabled": disabled,
        "direction": direction.value === "rtl" ? "right" : "left",
        "showSelectAll": showSelectAll,
        "selectAllLabel": selectAllLabels[0] || slots.leftSelectAllLabel,
        "pagination": mergedPagination
      }, locale), {
        titleText: () => leftTitle,
        footer
      }), createVNode(operation_default, {
        "key": "operation",
        "class": `${prefixCls.value}-operation`,
        "rightActive": rightActive,
        "rightArrowText": operations[0],
        "moveToRight": moveToRight,
        "leftActive": leftActive,
        "leftArrowText": operations[1],
        "moveToLeft": moveToLeft,
        "style": operationStyle,
        "disabled": disabled,
        "direction": direction.value,
        "oneWay": oneWay
      }, null), createVNode(list_default2, _objectSpread2({
        "key": "rightList",
        "prefixCls": `${prefixCls.value}-list`,
        "dataSource": rightDataSource.value,
        "filterOption": filterOption2,
        "style": handleListStyle(listStyle, "right"),
        "checkedKeys": targetSelectedKeys.value,
        "handleFilter": handleRightFilter,
        "handleClear": handleRightClear,
        "onItemSelect": onRightItemSelect,
        "onItemSelectAll": onRightItemSelectAll,
        "onItemRemove": onRightItemRemove,
        "renderItem": renderItem,
        "showSearch": showSearch,
        "renderList": children,
        "onScroll": handleRightScroll,
        "disabled": disabled,
        "direction": direction.value === "rtl" ? "left" : "right",
        "showSelectAll": showSelectAll,
        "selectAllLabel": selectAllLabels[1] || slots.rightSelectAllLabel,
        "showRemove": oneWay,
        "pagination": mergedPagination
      }, locale), {
        titleText: () => rightTitle,
        footer
      })]);
    };
    return () => wrapSSR(createVNode(LocaleReceiver_default2, {
      "componentName": "Transfer",
      "defaultLocale": en_US_default3.Transfer,
      "children": renderTransfer
    }, null));
  }
});
var transfer_default = withInstall(Transfer);

// node_modules/ant-design-vue/es/vc-tree-select/utils/valueUtil.js
function toArray4(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
function fillFieldNames2(fieldNames) {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  const mergedValue = value || "value";
  return {
    _title: label ? [label] : ["title", "label"],
    value: mergedValue,
    key: mergedValue,
    children: children || "children"
  };
}
function isCheckDisabled(node) {
  return node.disabled || node.disableCheckbox || node.checkable === false;
}
function getAllKeys(treeData, fieldNames) {
  const keys = [];
  function dig(list) {
    list.forEach((item) => {
      keys.push(item[fieldNames.value]);
      const children = item[fieldNames.children];
      if (children) {
        dig(children);
      }
    });
  }
  dig(treeData);
  return keys;
}
function isNil(val) {
  return val === null || val === void 0;
}

// node_modules/ant-design-vue/es/vc-tree-select/TreeSelectContext.js
var TreeSelectContextPropsKey = Symbol("TreeSelectContextPropsKey");
function useProvideSelectContext(props2) {
  return provide(TreeSelectContextPropsKey, props2);
}
function useInjectSelectContext() {
  return inject(TreeSelectContextPropsKey, {});
}

// node_modules/ant-design-vue/es/vc-tree-select/OptionList.js
var HIDDEN_STYLE2 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var OptionList_default2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  setup(_, _ref) {
    let {
      slots,
      expose
    } = _ref;
    const baseProps3 = useBaseProps();
    const legacyContext = useInjectLegacySelectContext();
    const context2 = useInjectSelectContext();
    const treeRef = ref();
    const memoTreeData = useMemo(() => context2.treeData, [() => baseProps3.open, () => context2.treeData], (next) => next[0]);
    const mergedCheckedKeys = computed(() => {
      const {
        checkable,
        halfCheckedKeys,
        checkedKeys
      } = legacyContext;
      if (!checkable) {
        return null;
      }
      return {
        checked: checkedKeys,
        halfChecked: halfCheckedKeys
      };
    });
    watch(() => baseProps3.open, () => {
      nextTick(() => {
        var _a2;
        if (baseProps3.open && !baseProps3.multiple && legacyContext.checkedKeys.length) {
          (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo({
            key: legacyContext.checkedKeys[0]
          });
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    const lowerSearchValue = computed(() => String(baseProps3.searchValue).toLowerCase());
    const filterTreeNode = (treeNode) => {
      if (!lowerSearchValue.value) {
        return false;
      }
      return String(treeNode[legacyContext.treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue.value);
    };
    const expandedKeys = shallowRef(legacyContext.treeDefaultExpandedKeys);
    const searchExpandedKeys = shallowRef(null);
    watch(() => baseProps3.searchValue, () => {
      if (baseProps3.searchValue) {
        searchExpandedKeys.value = getAllKeys(toRaw(context2.treeData), toRaw(context2.fieldNames));
      }
    }, {
      immediate: true
    });
    const mergedExpandedKeys = computed(() => {
      if (legacyContext.treeExpandedKeys) {
        return legacyContext.treeExpandedKeys.slice();
      }
      return baseProps3.searchValue ? searchExpandedKeys.value : expandedKeys.value;
    });
    const onInternalExpand = (keys) => {
      var _a2;
      expandedKeys.value = keys;
      searchExpandedKeys.value = keys;
      (_a2 = legacyContext.onTreeExpand) === null || _a2 === void 0 ? void 0 : _a2.call(legacyContext, keys);
    };
    const onListMouseDown = (event) => {
      event.preventDefault();
    };
    const onInternalSelect = (_2, _ref2) => {
      let {
        node
      } = _ref2;
      var _a2, _b;
      const {
        checkable,
        checkedKeys
      } = legacyContext;
      if (checkable && isCheckDisabled(node)) {
        return;
      }
      (_a2 = context2.onSelect) === null || _a2 === void 0 ? void 0 : _a2.call(context2, node.key, {
        selected: !checkedKeys.includes(node.key)
      });
      if (!baseProps3.multiple) {
        (_b = baseProps3.toggleOpen) === null || _b === void 0 ? void 0 : _b.call(baseProps3, false);
      }
    };
    const activeKey = ref(null);
    const activeEntity = computed(() => legacyContext.keyEntities[activeKey.value]);
    const setActiveKey = (key) => {
      activeKey.value = key;
    };
    expose({
      scrollTo: function() {
        var _a2, _b;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_b = (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
      },
      onKeydown: (event) => {
        var _a2;
        const {
          which
        } = event;
        switch (which) {
          case KeyCode_default.UP:
          case KeyCode_default.DOWN:
          case KeyCode_default.LEFT:
          case KeyCode_default.RIGHT:
            (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.onKeydown(event);
            break;
          case KeyCode_default.ENTER: {
            if (activeEntity.value) {
              const {
                selectable,
                value
              } = activeEntity.value.node || {};
              if (selectable !== false) {
                onInternalSelect(null, {
                  node: {
                    key: activeKey.value
                  },
                  selected: !legacyContext.checkedKeys.includes(value)
                });
              }
            }
            break;
          }
          case KeyCode_default.ESC: {
            baseProps3.toggleOpen(false);
          }
        }
      },
      onKeyup: () => {
      }
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        multiple,
        searchValue,
        open: open2,
        notFoundContent = (_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
      } = baseProps3;
      const {
        listHeight,
        listItemHeight,
        virtual,
        dropdownMatchSelectWidth,
        treeExpandAction
      } = context2;
      const {
        checkable,
        treeDefaultExpandAll,
        treeIcon,
        showTreeIcon,
        switcherIcon,
        treeLine,
        loadData,
        treeLoadedKeys,
        treeMotion,
        onTreeLoad,
        checkedKeys
      } = legacyContext;
      if (memoTreeData.value.length === 0) {
        return createVNode("div", {
          "role": "listbox",
          "class": `${prefixCls}-empty`,
          "onMousedown": onListMouseDown
        }, [notFoundContent]);
      }
      const treeProps = {
        fieldNames: context2.fieldNames
      };
      if (treeLoadedKeys) {
        treeProps.loadedKeys = treeLoadedKeys;
      }
      if (mergedExpandedKeys.value) {
        treeProps.expandedKeys = mergedExpandedKeys.value;
      }
      return createVNode("div", {
        "onMousedown": onListMouseDown
      }, [activeEntity.value && open2 && createVNode("span", {
        "style": HIDDEN_STYLE2,
        "aria-live": "assertive"
      }, [activeEntity.value.node.value]), createVNode(Tree_default, _objectSpread2(_objectSpread2({
        "ref": treeRef,
        "focusable": false,
        "prefixCls": `${prefixCls}-tree`,
        "treeData": memoTreeData.value,
        "height": listHeight,
        "itemHeight": listItemHeight,
        "virtual": virtual !== false && dropdownMatchSelectWidth !== false,
        "multiple": multiple,
        "icon": treeIcon,
        "showIcon": showTreeIcon,
        "switcherIcon": switcherIcon,
        "showLine": treeLine,
        "loadData": searchValue ? null : loadData,
        "motion": treeMotion,
        "activeKey": activeKey.value,
        "checkable": checkable,
        "checkStrictly": true,
        "checkedKeys": mergedCheckedKeys.value,
        "selectedKeys": !checkable ? checkedKeys : [],
        "defaultExpandAll": treeDefaultExpandAll
      }, treeProps), {}, {
        "onActiveChange": setActiveKey,
        "onSelect": onInternalSelect,
        "onCheck": onInternalSelect,
        "onExpand": onInternalExpand,
        "onLoad": onTreeLoad,
        "filterTreeNode": filterTreeNode,
        "expandAction": treeExpandAction
      }), _extends(_extends({}, slots), {
        checkable: legacyContext.customSlots.treeCheckable
      }))]);
    };
  }
});

// node_modules/ant-design-vue/es/vc-tree-select/utils/strategyUtil.js
var SHOW_ALL = "SHOW_ALL";
var SHOW_PARENT2 = "SHOW_PARENT";
var SHOW_CHILD2 = "SHOW_CHILD";
function formatStrategyValues2(values, strategy, keyEntities, fieldNames) {
  const valueSet = new Set(values);
  if (strategy === SHOW_CHILD2) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      if (entity && entity.children && entity.children.some((_ref) => {
        let {
          node
        } = _ref;
        return valueSet.has(node[fieldNames.value]);
      }) && entity.children.every((_ref2) => {
        let {
          node
        } = _ref2;
        return isCheckDisabled(node) || valueSet.has(node[fieldNames.value]);
      })) {
        return false;
      }
      return true;
    });
  }
  if (strategy === SHOW_PARENT2) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      const parent = entity ? entity.parent : null;
      if (parent && !isCheckDisabled(parent.node) && valueSet.has(parent.key)) {
        return false;
      }
      return true;
    });
  }
  return values;
}

// node_modules/ant-design-vue/es/vc-tree-select/TreeNode.js
var TreeNode2 = () => null;
TreeNode2.inheritAttrs = false;
TreeNode2.displayName = "ATreeSelectNode";
TreeNode2.isTreeSelectNode = true;
var TreeNode_default = TreeNode2;

// node_modules/ant-design-vue/es/vc-tree-select/utils/legacyUtil.js
var __rest30 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function isTreeSelectNode(node) {
  return node && node.type && node.type.isTreeSelectNode;
}
function convertChildrenToData(rootNodes) {
  function dig() {
    let treeNodes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return filterEmpty(treeNodes).map((treeNode) => {
      var _a2, _b, _c;
      if (!isTreeSelectNode(treeNode)) {
        warning(!treeNode, "TreeSelect/TreeSelectNode can only accept TreeSelectNode as children.");
        return null;
      }
      const slots = treeNode.children || {};
      const key = treeNode.key;
      const props2 = {};
      for (const [k, v] of Object.entries(treeNode.props)) {
        props2[camelize(k)] = v;
      }
      const {
        isLeaf: isLeaf2,
        checkable,
        selectable,
        disabled,
        disableCheckbox
      } = props2;
      const newProps = {
        isLeaf: isLeaf2 || isLeaf2 === "" || void 0,
        checkable: checkable || checkable === "" || void 0,
        selectable: selectable || selectable === "" || void 0,
        disabled: disabled || disabled === "" || void 0,
        disableCheckbox: disableCheckbox || disableCheckbox === "" || void 0
      };
      const slotsProps = _extends(_extends({}, props2), newProps);
      const {
        title = (_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots, slotsProps),
        switcherIcon = (_b = slots.switcherIcon) === null || _b === void 0 ? void 0 : _b.call(slots, slotsProps)
      } = props2, rest = __rest30(props2, ["title", "switcherIcon"]);
      const children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      const dataNode = _extends(_extends(_extends({}, rest), {
        title,
        switcherIcon,
        key,
        isLeaf: isLeaf2
      }), newProps);
      const parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function fillLegacyProps(dataNode) {
  if (!dataNode) {
    return dataNode;
  }
  const cloneNode = _extends({}, dataNode);
  if (!("props" in cloneNode)) {
    Object.defineProperty(cloneNode, "props", {
      get() {
        warning(false, "New `vc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access.");
        return cloneNode;
      }
    });
  }
  return cloneNode;
}
function fillAdditionalInfo(extra, triggerValue, checkedValues, treeData, showPosition, fieldNames) {
  let triggerNode = null;
  let nodeList = null;
  function generateMap() {
    function dig(list) {
      let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0";
      let parentIncluded = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return list.map((option, index2) => {
        const pos = `${level}-${index2}`;
        const value = option[fieldNames.value];
        const included = checkedValues.includes(value);
        const children = dig(option[fieldNames.children] || [], pos, included);
        const node = createVNode(TreeNode_default, option, {
          default: () => [children.map((child) => child.node)]
        });
        if (triggerValue === value) {
          triggerNode = node;
        }
        if (included) {
          const checkedNode = {
            pos,
            node,
            children
          };
          if (!parentIncluded) {
            nodeList.push(checkedNode);
          }
          return checkedNode;
        }
        return null;
      }).filter((node) => node);
    }
    if (!nodeList) {
      nodeList = [];
      dig(treeData);
      nodeList.sort((_ref, _ref2) => {
        let {
          node: {
            props: {
              value: val1
            }
          }
        } = _ref;
        let {
          node: {
            props: {
              value: val2
            }
          }
        } = _ref2;
        const index1 = checkedValues.indexOf(val1);
        const index2 = checkedValues.indexOf(val2);
        return index1 - index2;
      });
    }
  }
  Object.defineProperty(extra, "triggerNode", {
    get() {
      warning(false, "`triggerNode` is deprecated. Please consider decoupling data with node.");
      generateMap();
      return triggerNode;
    }
  });
  Object.defineProperty(extra, "allCheckedNodes", {
    get() {
      warning(false, "`allCheckedNodes` is deprecated. Please consider decoupling data with node.");
      generateMap();
      if (showPosition) {
        return nodeList;
      }
      return nodeList.map((_ref3) => {
        let {
          node
        } = _ref3;
        return node;
      });
    }
  });
}

// node_modules/ant-design-vue/es/vc-tree-select/hooks/useTreeData.js
function parseSimpleTreeData(treeData, _ref) {
  let {
    id,
    pId,
    rootPId
  } = _ref;
  const keyNodes = {};
  const rootNodeList = [];
  const nodeList = treeData.map((node) => {
    const clone = _extends({}, node);
    const key = clone[id];
    keyNodes[key] = clone;
    clone.key = clone.key || key;
    return clone;
  });
  nodeList.forEach((node) => {
    const parentKey = node[pId];
    const parent = keyNodes[parentKey];
    if (parent) {
      parent.children = parent.children || [];
      parent.children.push(node);
    }
    if (parentKey === rootPId || !parent && rootPId === null) {
      rootNodeList.push(node);
    }
  });
  return rootNodeList;
}
function useTreeData(treeData, children, simpleMode) {
  const mergedTreeData = shallowRef();
  watch([simpleMode, treeData, children], () => {
    const simpleModeValue = simpleMode.value;
    if (treeData.value) {
      mergedTreeData.value = simpleMode.value ? parseSimpleTreeData(toRaw(treeData.value), _extends({
        id: "id",
        pId: "pId",
        rootPId: null
      }, simpleModeValue !== true ? simpleModeValue : {})) : toRaw(treeData.value).slice();
    } else {
      mergedTreeData.value = convertChildrenToData(toRaw(children.value));
    }
  }, {
    immediate: true,
    deep: true
  });
  return mergedTreeData;
}

// node_modules/ant-design-vue/es/vc-tree-select/hooks/useCache.js
var useCache_default = (values) => {
  const cacheRef = shallowRef({
    valueLabels: /* @__PURE__ */ new Map()
  });
  const mergedValues = shallowRef();
  watch(values, () => {
    mergedValues.value = toRaw(values.value);
  }, {
    immediate: true
  });
  const newFilledValues = computed(() => {
    const {
      valueLabels
    } = cacheRef.value;
    const valueLabelsCache = /* @__PURE__ */ new Map();
    const filledValues = mergedValues.value.map((item) => {
      var _a2;
      const {
        value
      } = item;
      const mergedLabel = (_a2 = item.label) !== null && _a2 !== void 0 ? _a2 : valueLabels.get(value);
      valueLabelsCache.set(value, mergedLabel);
      return _extends(_extends({}, item), {
        label: mergedLabel
      });
    });
    cacheRef.value.valueLabels = valueLabelsCache;
    return filledValues;
  });
  return [newFilledValues];
};

// node_modules/ant-design-vue/es/vc-tree-select/hooks/useDataEntities.js
var useDataEntities_default = (treeData, fieldNames) => {
  const valueEntities = shallowRef(/* @__PURE__ */ new Map());
  const keyEntities = shallowRef({});
  watchEffect(() => {
    const fieldNamesValue = fieldNames.value;
    const collection = convertDataToEntities(treeData.value, {
      fieldNames: fieldNamesValue,
      initWrapper: (wrapper) => _extends(_extends({}, wrapper), {
        valueEntities: /* @__PURE__ */ new Map()
      }),
      processEntity: (entity, wrapper) => {
        const val = entity.node[fieldNamesValue.value];
        if (true) {
          const key = entity.node.key;
          warning(!isNil(val), "TreeNode `value` is invalidate: undefined");
          warning(!wrapper.valueEntities.has(val), `Same \`value\` exist in the tree: ${val}`);
          warning(!key || String(key) === String(val), `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${key}, value: ${val}.`);
        }
        wrapper.valueEntities.set(val, entity);
      }
    });
    valueEntities.value = collection.valueEntities;
    keyEntities.value = collection.keyEntities;
  });
  return {
    valueEntities,
    keyEntities
  };
};

// node_modules/ant-design-vue/es/vc-tree-select/hooks/useCheckedKeys.js
var useCheckedKeys_default = (rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities, maxLevel, levelEntities) => {
  const newRawCheckedValues = shallowRef([]);
  const newRawHalfCheckedValues = shallowRef([]);
  watchEffect(() => {
    let checkedKeys = rawLabeledValues.value.map((_ref) => {
      let {
        value
      } = _ref;
      return value;
    });
    let halfCheckedKeys = rawHalfCheckedValues.value.map((_ref2) => {
      let {
        value
      } = _ref2;
      return value;
    });
    const missingValues = checkedKeys.filter((key) => !keyEntities.value[key]);
    if (treeConduction.value) {
      ({
        checkedKeys,
        halfCheckedKeys
      } = conductCheck(checkedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value));
    }
    newRawCheckedValues.value = Array.from(/* @__PURE__ */ new Set([...missingValues, ...checkedKeys]));
    newRawHalfCheckedValues.value = halfCheckedKeys;
  });
  return [newRawCheckedValues, newRawHalfCheckedValues];
};

// node_modules/ant-design-vue/es/vc-tree-select/hooks/useFilterTreeData.js
var useFilterTreeData_default = (treeData, searchValue, _ref) => {
  let {
    treeNodeFilterProp,
    filterTreeNode,
    fieldNames
  } = _ref;
  return computed(() => {
    const {
      children: fieldChildren
    } = fieldNames.value;
    const searchValueVal = searchValue.value;
    const treeNodeFilterPropValue = treeNodeFilterProp === null || treeNodeFilterProp === void 0 ? void 0 : treeNodeFilterProp.value;
    if (!searchValueVal || filterTreeNode.value === false) {
      return treeData.value;
    }
    let filterOptionFunc;
    if (typeof filterTreeNode.value === "function") {
      filterOptionFunc = filterTreeNode.value;
    } else {
      const upperStr = searchValueVal.toUpperCase();
      filterOptionFunc = (_, dataNode) => {
        const value = dataNode[treeNodeFilterPropValue];
        return String(value).toUpperCase().includes(upperStr);
      };
    }
    function dig(list) {
      let keepAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const res = [];
      for (let index2 = 0, len = list.length; index2 < len; index2++) {
        const dataNode = list[index2];
        const children = dataNode[fieldChildren];
        const match = keepAll || filterOptionFunc(searchValueVal, fillLegacyProps(dataNode));
        const childList = dig(children || [], match);
        if (match || childList.length) {
          res.push(_extends(_extends({}, dataNode), {
            [fieldChildren]: childList
          }));
        }
      }
      return res;
    }
    return dig(treeData.value);
  });
};

// node_modules/ant-design-vue/es/vc-tree-select/utils/warningPropsUtil.js
function warningProps(props2) {
  const {
    searchPlaceholder,
    treeCheckStrictly,
    treeCheckable,
    labelInValue,
    value,
    multiple
  } = props2;
  warning(!searchPlaceholder, "`searchPlaceholder` has been removed, please use `placeholder` instead");
  if (treeCheckStrictly && labelInValue === false) {
    warning(false, "`treeCheckStrictly` will force set `labelInValue` to `true`.");
  }
  if (labelInValue || treeCheckStrictly) {
    warning(toArray4(value).every((val) => val && typeof val === "object" && "value" in val), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead.");
  }
  if (treeCheckStrictly || multiple || treeCheckable) {
    warning(!value || Array.isArray(value), "`value` should be an array when `TreeSelect` is checkable or multiple.");
  } else {
    warning(!Array.isArray(value), "`value` should not be array when `TreeSelect` is single mode.");
  }
}
var warningPropsUtil_default = warningProps;

// node_modules/ant-design-vue/es/vc-tree-select/TreeSelect.js
function treeSelectProps() {
  return _extends(_extends({}, omit_default(baseSelectPropsWithoutPrivate(), ["mode"])), {
    prefixCls: String,
    id: String,
    value: {
      type: [String, Number, Object, Array]
    },
    defaultValue: {
      type: [String, Number, Object, Array]
    },
    onChange: {
      type: Function
    },
    searchValue: String,
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    onSearch: {
      type: Function
    },
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    filterTreeNode: {
      type: [Boolean, Function],
      default: void 0
    },
    treeNodeFilterProp: String,
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    showCheckedStrategy: {
      type: String
    },
    treeNodeLabelProp: String,
    fieldNames: {
      type: Object
    },
    // >>> Mode
    multiple: {
      type: Boolean,
      default: void 0
    },
    treeCheckable: {
      type: Boolean,
      default: void 0
    },
    treeCheckStrictly: {
      type: Boolean,
      default: void 0
    },
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Data
    treeData: {
      type: Array
    },
    treeDataSimpleMode: {
      type: [Boolean, Object],
      default: void 0
    },
    loadData: {
      type: Function
    },
    treeLoadedKeys: {
      type: Array
    },
    onTreeLoad: {
      type: Function
    },
    // >>> Expanded
    treeDefaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    treeExpandedKeys: {
      type: Array
    },
    treeDefaultExpandedKeys: {
      type: Array
    },
    onTreeExpand: {
      type: Function
    },
    // >>> Options
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    onDropdownVisibleChange: {
      type: Function
    },
    // >>> Tree
    treeLine: {
      type: [Boolean, Object],
      default: void 0
    },
    treeIcon: vue_types_default.any,
    showTreeIcon: {
      type: Boolean,
      default: void 0
    },
    switcherIcon: vue_types_default.any,
    treeMotion: vue_types_default.any,
    children: Array,
    treeExpandAction: String,
    showArrow: {
      type: Boolean,
      default: void 0
    },
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: vue_types_default.any,
    maxTagPlaceholder: {
      type: Function
    },
    dropdownPopupAlign: vue_types_default.any,
    customSlots: Object
  });
}
function isRawValue(value) {
  return !value || typeof value !== "object";
}
var TreeSelect_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TreeSelect",
  inheritAttrs: false,
  props: initDefaultProps_default(treeSelectProps(), {
    treeNodeFilterProp: "value",
    autoClearSearchValue: true,
    showCheckedStrategy: SHOW_CHILD2,
    listHeight: 200,
    listItemHeight: 20,
    prefixCls: "vc-tree-select"
  }),
  setup(props2, _ref) {
    let {
      attrs,
      expose,
      slots
    } = _ref;
    const mergedId = useId(toRef(props2, "id"));
    const treeConduction = computed(() => props2.treeCheckable && !props2.treeCheckStrictly);
    const mergedCheckable = computed(() => props2.treeCheckable || props2.treeCheckStrictly);
    const mergedLabelInValue = computed(() => props2.treeCheckStrictly || props2.labelInValue);
    const mergedMultiple = computed(() => mergedCheckable.value || props2.multiple);
    if (true) {
      watchEffect(() => {
        warningPropsUtil_default(props2);
      });
    }
    const mergedFieldNames = computed(() => fillFieldNames2(props2.fieldNames));
    const [mergedSearchValue, setSearchValue] = useMergedState("", {
      value: computed(() => props2.searchValue !== void 0 ? props2.searchValue : props2.inputValue),
      postState: (search) => search || ""
    });
    const onInternalSearch = (searchText) => {
      var _a2;
      setSearchValue(searchText);
      (_a2 = props2.onSearch) === null || _a2 === void 0 ? void 0 : _a2.call(props2, searchText);
    };
    const mergedTreeData = useTreeData(toRef(props2, "treeData"), toRef(props2, "children"), toRef(props2, "treeDataSimpleMode"));
    const {
      keyEntities,
      valueEntities
    } = useDataEntities_default(mergedTreeData, mergedFieldNames);
    const splitRawValues = (newRawValues) => {
      const missingRawValues = [];
      const existRawValues = [];
      newRawValues.forEach((val) => {
        if (valueEntities.value.has(val)) {
          existRawValues.push(val);
        } else {
          missingRawValues.push(val);
        }
      });
      return {
        missingRawValues,
        existRawValues
      };
    };
    const filteredTreeData = useFilterTreeData_default(mergedTreeData, mergedSearchValue, {
      fieldNames: mergedFieldNames,
      treeNodeFilterProp: toRef(props2, "treeNodeFilterProp"),
      filterTreeNode: toRef(props2, "filterTreeNode")
    });
    const getLabel = (item) => {
      if (item) {
        if (props2.treeNodeLabelProp) {
          return item[props2.treeNodeLabelProp];
        }
        const {
          _title: titleList
        } = mergedFieldNames.value;
        for (let i = 0; i < titleList.length; i += 1) {
          const title = item[titleList[i]];
          if (title !== void 0) {
            return title;
          }
        }
      }
    };
    const toLabeledValues = (draftValues) => {
      const values = toArray4(draftValues);
      return values.map((val) => {
        if (isRawValue(val)) {
          return {
            value: val
          };
        }
        return val;
      });
    };
    const convert2LabelValues = (draftValues) => {
      const values = toLabeledValues(draftValues);
      return values.map((item) => {
        let {
          label: rawLabel
        } = item;
        const {
          value: rawValue,
          halfChecked: rawHalfChecked
        } = item;
        let rawDisabled;
        const entity = valueEntities.value.get(rawValue);
        if (entity) {
          rawLabel = rawLabel !== null && rawLabel !== void 0 ? rawLabel : getLabel(entity.node);
          rawDisabled = entity.node.disabled;
        }
        return {
          label: rawLabel,
          value: rawValue,
          halfChecked: rawHalfChecked,
          disabled: rawDisabled
        };
      });
    };
    const [internalValue, setInternalValue] = useMergedState(props2.defaultValue, {
      value: toRef(props2, "value")
    });
    const rawMixedLabeledValues = computed(() => toLabeledValues(internalValue.value));
    const rawLabeledValues = shallowRef([]);
    const rawHalfLabeledValues = shallowRef([]);
    watchEffect(() => {
      const fullCheckValues = [];
      const halfCheckValues = [];
      rawMixedLabeledValues.value.forEach((item) => {
        if (item.halfChecked) {
          halfCheckValues.push(item);
        } else {
          fullCheckValues.push(item);
        }
      });
      rawLabeledValues.value = fullCheckValues;
      rawHalfLabeledValues.value = halfCheckValues;
    });
    const rawValues = computed(() => rawLabeledValues.value.map((item) => item.value));
    const {
      maxLevel,
      levelEntities
    } = useMaxLevel(keyEntities);
    const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys_default(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities, maxLevel, levelEntities);
    const displayValues = computed(() => {
      const displayKeys = formatStrategyValues2(rawCheckedValues.value, props2.showCheckedStrategy, keyEntities.value, mergedFieldNames.value);
      const values = displayKeys.map((key) => {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = keyEntities.value[key]) === null || _a2 === void 0 ? void 0 : _a2.node) === null || _b === void 0 ? void 0 : _b[mergedFieldNames.value.value]) !== null && _c !== void 0 ? _c : key;
      });
      const labeledValues = values.map((val) => {
        const targetItem = rawLabeledValues.value.find((item) => item.value === val);
        return {
          value: val,
          label: targetItem === null || targetItem === void 0 ? void 0 : targetItem.label
        };
      });
      const rawDisplayValues = convert2LabelValues(labeledValues);
      const firstVal = rawDisplayValues[0];
      if (!mergedMultiple.value && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {
        return [];
      }
      return rawDisplayValues.map((item) => {
        var _a2;
        return _extends(_extends({}, item), {
          label: (_a2 = item.label) !== null && _a2 !== void 0 ? _a2 : item.value
        });
      });
    });
    const [cachedDisplayValues] = useCache_default(displayValues);
    const triggerChange = (newRawValues, extra, source) => {
      const labeledValues = convert2LabelValues(newRawValues);
      setInternalValue(labeledValues);
      if (props2.autoClearSearchValue) {
        setSearchValue("");
      }
      if (props2.onChange) {
        let eventValues = newRawValues;
        if (treeConduction.value) {
          const formattedKeyList = formatStrategyValues2(newRawValues, props2.showCheckedStrategy, keyEntities.value, mergedFieldNames.value);
          eventValues = formattedKeyList.map((key) => {
            const entity = valueEntities.value.get(key);
            return entity ? entity.node[mergedFieldNames.value.value] : key;
          });
        }
        const {
          triggerValue,
          selected
        } = extra || {
          triggerValue: void 0,
          selected: void 0
        };
        let returnRawValues = eventValues;
        if (props2.treeCheckStrictly) {
          const halfValues = rawHalfLabeledValues.value.filter((item) => !eventValues.includes(item.value));
          returnRawValues = [...returnRawValues, ...halfValues];
        }
        const returnLabeledValues = convert2LabelValues(returnRawValues);
        const additionalInfo = {
          // [Legacy] Always return as array contains label & value
          preValue: rawLabeledValues.value,
          triggerValue
        };
        let showPosition = true;
        if (props2.treeCheckStrictly || source === "selection" && !selected) {
          showPosition = false;
        }
        fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData.value, showPosition, mergedFieldNames.value);
        if (mergedCheckable.value) {
          additionalInfo.checked = selected;
        } else {
          additionalInfo.selected = selected;
        }
        const returnValues = mergedLabelInValue.value ? returnLabeledValues : returnLabeledValues.map((item) => item.value);
        props2.onChange(mergedMultiple.value ? returnValues : returnValues[0], mergedLabelInValue.value ? null : returnLabeledValues.map((item) => item.label), additionalInfo);
      }
    };
    const onOptionSelect = (selectedKey, _ref2) => {
      let {
        selected,
        source
      } = _ref2;
      var _a2, _b, _c;
      const keyEntitiesValue = toRaw(keyEntities.value);
      const valueEntitiesValue = toRaw(valueEntities.value);
      const entity = keyEntitiesValue[selectedKey];
      const node = entity === null || entity === void 0 ? void 0 : entity.node;
      const selectedValue = (_a2 = node === null || node === void 0 ? void 0 : node[mergedFieldNames.value.value]) !== null && _a2 !== void 0 ? _a2 : selectedKey;
      if (!mergedMultiple.value) {
        triggerChange([selectedValue], {
          selected: true,
          triggerValue: selectedValue
        }, "option");
      } else {
        let newRawValues = selected ? [...rawValues.value, selectedValue] : rawCheckedValues.value.filter((v) => v !== selectedValue);
        if (treeConduction.value) {
          const {
            missingRawValues,
            existRawValues
          } = splitRawValues(newRawValues);
          const keyList = existRawValues.map((val) => valueEntitiesValue.get(val).key);
          let checkedKeys;
          if (selected) {
            ({
              checkedKeys
            } = conductCheck(keyList, true, keyEntitiesValue, maxLevel.value, levelEntities.value));
          } else {
            ({
              checkedKeys
            } = conductCheck(keyList, {
              checked: false,
              halfCheckedKeys: rawHalfCheckedValues.value
            }, keyEntitiesValue, maxLevel.value, levelEntities.value));
          }
          newRawValues = [...missingRawValues, ...checkedKeys.map((key) => keyEntitiesValue[key].node[mergedFieldNames.value.value])];
        }
        triggerChange(newRawValues, {
          selected,
          triggerValue: selectedValue
        }, source || "option");
      }
      if (selected || !mergedMultiple.value) {
        (_b = props2.onSelect) === null || _b === void 0 ? void 0 : _b.call(props2, selectedValue, fillLegacyProps(node));
      } else {
        (_c = props2.onDeselect) === null || _c === void 0 ? void 0 : _c.call(props2, selectedValue, fillLegacyProps(node));
      }
    };
    const onInternalDropdownVisibleChange = (open2) => {
      if (props2.onDropdownVisibleChange) {
        const legacyParam = {};
        Object.defineProperty(legacyParam, "documentClickClose", {
          get() {
            warning(false, "Second param of `onDropdownVisibleChange` has been removed.");
            return false;
          }
        });
        props2.onDropdownVisibleChange(open2, legacyParam);
      }
    };
    const onDisplayValuesChange = (newValues, info) => {
      const newRawValues = newValues.map((item) => item.value);
      if (info.type === "clear") {
        triggerChange(newRawValues, {}, "selection");
        return;
      }
      if (info.values.length) {
        onOptionSelect(info.values[0].value, {
          selected: false,
          source: "selection"
        });
      }
    };
    const {
      treeNodeFilterProp,
      // Data
      loadData,
      treeLoadedKeys,
      onTreeLoad,
      // Expanded
      treeDefaultExpandAll,
      treeExpandedKeys,
      treeDefaultExpandedKeys,
      onTreeExpand,
      // Options
      virtual,
      listHeight,
      listItemHeight,
      // Tree
      treeLine,
      treeIcon,
      showTreeIcon,
      switcherIcon,
      treeMotion,
      customSlots,
      dropdownMatchSelectWidth,
      treeExpandAction
    } = toRefs(props2);
    useProvideLegacySelectContext(toReactive({
      checkable: mergedCheckable,
      loadData,
      treeLoadedKeys,
      onTreeLoad,
      checkedKeys: rawCheckedValues,
      halfCheckedKeys: rawHalfCheckedValues,
      treeDefaultExpandAll,
      treeExpandedKeys,
      treeDefaultExpandedKeys,
      onTreeExpand,
      treeIcon,
      treeMotion,
      showTreeIcon,
      switcherIcon,
      treeLine,
      treeNodeFilterProp,
      keyEntities,
      customSlots
    }));
    useProvideSelectContext(toReactive({
      virtual,
      listHeight,
      listItemHeight,
      treeData: filteredTreeData,
      fieldNames: mergedFieldNames,
      onSelect: onOptionSelect,
      dropdownMatchSelectWidth,
      treeExpandAction
    }));
    const selectRef = ref();
    expose({
      focus() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      },
      scrollTo(arg) {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
      }
    });
    return () => {
      var _a2;
      const restProps = omit_default(props2, [
        "id",
        "prefixCls",
        "customSlots",
        // Value
        "value",
        "defaultValue",
        "onChange",
        "onSelect",
        "onDeselect",
        // Search
        "searchValue",
        "inputValue",
        "onSearch",
        "autoClearSearchValue",
        "filterTreeNode",
        "treeNodeFilterProp",
        // Selector
        "showCheckedStrategy",
        "treeNodeLabelProp",
        //  Mode
        "multiple",
        "treeCheckable",
        "treeCheckStrictly",
        "labelInValue",
        // FieldNames
        "fieldNames",
        // Data
        "treeDataSimpleMode",
        "treeData",
        "children",
        "loadData",
        "treeLoadedKeys",
        "onTreeLoad",
        // Expanded
        "treeDefaultExpandAll",
        "treeExpandedKeys",
        "treeDefaultExpandedKeys",
        "onTreeExpand",
        // Options
        "virtual",
        "listHeight",
        "listItemHeight",
        "onDropdownVisibleChange",
        // Tree
        "treeLine",
        "treeIcon",
        "showTreeIcon",
        "switcherIcon",
        "treeMotion"
      ]);
      return createVNode(BaseSelect_default, _objectSpread2(_objectSpread2(_objectSpread2({
        "ref": selectRef
      }, attrs), restProps), {}, {
        "id": mergedId,
        "prefixCls": props2.prefixCls,
        "mode": mergedMultiple.value ? "multiple" : void 0,
        "displayValues": cachedDisplayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "OptionList": OptionList_default2,
        "emptyOptions": !mergedTreeData.value.length,
        "onDropdownVisibleChange": onInternalDropdownVisibleChange,
        "tagRender": props2.tagRender || slots.tagRender,
        "dropdownMatchSelectWidth": (_a2 = props2.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : true
      }), slots);
    };
  }
});

// node_modules/ant-design-vue/es/vc-tree-select/index.js
var vc_tree_select_default = TreeSelect_default;

// node_modules/ant-design-vue/es/tree-select/style/index.js
var genBaseStyle11 = (token) => {
  const {
    componentCls,
    treePrefixCls,
    colorBgElevated
  } = token;
  const treeCls = `.${treePrefixCls}`;
  return [
    // ======================================================
    // ==                     Dropdown                     ==
    // ======================================================
    {
      [`${componentCls}-dropdown`]: [
        {
          padding: `${token.paddingXS}px ${token.paddingXS / 2}px`
        },
        // ====================== Tree ======================
        genTreeStyle(treePrefixCls, merge(token, {
          colorBgContainer: colorBgElevated
        })),
        {
          [treeCls]: {
            borderRadius: 0,
            "&-list-holder-inner": {
              alignItems: "stretch",
              [`${treeCls}-treenode`]: {
                [`${treeCls}-node-content-wrapper`]: {
                  flex: "auto"
                }
              }
            }
          }
        },
        // ==================== Checkbox ====================
        getStyle2(`${treePrefixCls}-checkbox`, token),
        // ====================== RTL =======================
        {
          "&-rtl": {
            direction: "rtl",
            [`${treeCls}-switcher${treeCls}-switcher_close`]: {
              [`${treeCls}-switcher-icon svg`]: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      ]
    }
  ];
};
function useTreeSelectStyle(prefixCls, treePrefixCls) {
  return genComponentStyleHook("TreeSelect", (token) => {
    const treeSelectToken = merge(token, {
      treePrefixCls: treePrefixCls.value
    });
    return [genBaseStyle11(treeSelectToken)];
  })(prefixCls);
}

// node_modules/ant-design-vue/es/tree-select/index.js
var getTransitionName2 = (rootPrefixCls, motion, transitionName) => {
  if (transitionName !== void 0) {
    return transitionName;
  }
  return `${rootPrefixCls}-${motion}`;
};
function treeSelectProps2() {
  return _extends(_extends({}, omit_default(treeSelectProps(), ["showTreeIcon", "treeMotion", "inputIcon", "getInputElement", "treeLine", "customSlots"])), {
    suffixIcon: vue_types_default.any,
    size: stringType(),
    bordered: booleanType(),
    treeLine: someType([Boolean, Object]),
    replaceFields: objectType(),
    placement: stringType(),
    status: stringType(),
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": functionType(),
    "onUpdate:treeExpandedKeys": functionType(),
    "onUpdate:searchValue": functionType()
  });
}
var TreeSelect = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeSelect",
  inheritAttrs: false,
  props: initDefaultProps_default(treeSelectProps2(), {
    choiceTransitionName: "",
    listHeight: 256,
    treeIcon: false,
    listItemHeight: 26,
    bordered: true
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      expose,
      emit
    } = _ref;
    warning(!(props2.treeData === void 0 && slots.default), "`children` of TreeSelect is deprecated. Please use `treeData` instead.");
    devWarning_default(props2.multiple !== false || !props2.treeCheckable, "TreeSelect", "`multiple` will always be `true` when `treeCheckable` is true");
    devWarning_default(props2.replaceFields === void 0, "TreeSelect", "`replaceFields` is deprecated, please use fieldNames instead");
    devWarning_default(!props2.dropdownClassName, "TreeSelect", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const {
      prefixCls,
      renderEmpty,
      direction,
      virtual,
      dropdownMatchSelectWidth,
      size: contextSize,
      getPopupContainer,
      getPrefixCls,
      disabled
    } = useConfigInject_default("select", props2);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = computed(() => compactSize.value || contextSize.value);
    const contextDisabled = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : contextDisabled.value;
    });
    const rootPrefixCls = computed(() => getPrefixCls());
    const placement = computed(() => {
      if (props2.placement !== void 0) {
        return props2.placement;
      }
      return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
    });
    const transitionName = computed(() => getTransitionName2(rootPrefixCls.value, getTransitionDirection(placement.value), props2.transitionName));
    const choiceTransitionName = computed(() => getTransitionName2(rootPrefixCls.value, "", props2.choiceTransitionName));
    const treePrefixCls = computed(() => getPrefixCls("select-tree", props2.prefixCls));
    const treeSelectPrefixCls = computed(() => getPrefixCls("tree-select", props2.prefixCls));
    const [wrapSelectSSR, hashId] = style_default(prefixCls);
    const [wrapTreeSelectSSR] = useTreeSelectStyle(treeSelectPrefixCls, treePrefixCls);
    const mergedDropdownClassName = computed(() => classNames_default(props2.popupClassName || props2.dropdownClassName, `${treeSelectPrefixCls.value}-dropdown`, {
      [`${treeSelectPrefixCls.value}-dropdown-rtl`]: direction.value === "rtl"
    }, hashId.value));
    const isMultiple = computed(() => !!(props2.treeCheckable || props2.multiple));
    const mergedShowArrow = computed(() => props2.showArrow !== void 0 ? props2.showArrow : props2.loading || !isMultiple.value);
    const treeSelectRef = ref();
    expose({
      focus() {
        var _a2, _b;
        (_b = (_a2 = treeSelectRef.value).focus) === null || _b === void 0 ? void 0 : _b.call(_a2);
      },
      blur() {
        var _a2, _b;
        (_b = (_a2 = treeSelectRef.value).blur) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
    });
    const handleChange = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      emit("update:value", args[0]);
      emit("change", ...args);
      formItemContext.onFieldChange();
    };
    const handleTreeExpand = (keys) => {
      emit("update:treeExpandedKeys", keys);
      emit("treeExpand", keys);
    };
    const handleSearch = (value) => {
      emit("update:searchValue", value);
      emit("search", value);
    };
    const handleBlur = (e) => {
      emit("blur", e);
      formItemContext.onFieldBlur();
    };
    return () => {
      var _a2, _b, _c;
      const {
        notFoundContent = (_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        prefixCls: customizePrefixCls,
        bordered,
        listHeight,
        listItemHeight,
        multiple,
        treeIcon,
        treeLine,
        showArrow,
        switcherIcon = (_b = slots.switcherIcon) === null || _b === void 0 ? void 0 : _b.call(slots),
        fieldNames = props2.replaceFields,
        id = formItemContext.id.value,
        placeholder = (_c = slots.placeholder) === null || _c === void 0 ? void 0 : _c.call(slots)
      } = props2;
      const {
        isFormItemInput,
        hasFeedback,
        feedbackIcon
      } = formItemInputContext;
      const {
        suffixIcon,
        removeIcon,
        clearIcon
      } = getIcons(_extends(_extends({}, props2), {
        multiple: isMultiple.value,
        showArrow: mergedShowArrow.value,
        hasFeedback,
        feedbackIcon,
        prefixCls: prefixCls.value
      }), slots);
      let mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else {
        mergedNotFound = renderEmpty("Select");
      }
      const selectProps2 = omit_default(props2, ["suffixIcon", "itemIcon", "removeIcon", "clearIcon", "switcherIcon", "bordered", "status", "onUpdate:value", "onUpdate:treeExpandedKeys", "onUpdate:searchValue"]);
      const mergedClassName = classNames_default(!customizePrefixCls && treeSelectPrefixCls.value, {
        [`${prefixCls.value}-lg`]: mergedSize.value === "large",
        [`${prefixCls.value}-sm`]: mergedSize.value === "small",
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-borderless`]: !bordered,
        [`${prefixCls.value}-in-form-item`]: isFormItemInput
      }, getStatusClassNames(prefixCls.value, mergedStatus.value, hasFeedback), compactItemClassnames.value, attrs.class, hashId.value);
      const otherProps = {};
      if (props2.treeData === void 0 && slots.default) {
        otherProps.children = flattenChildren(slots.default());
      }
      return wrapSelectSSR(wrapTreeSelectSSR(createVNode(vc_tree_select_default, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, attrs), selectProps2), {}, {
        "disabled": mergedDisabled.value,
        "virtual": virtual.value,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth.value,
        "id": id,
        "fieldNames": fieldNames,
        "ref": treeSelectRef,
        "prefixCls": prefixCls.value,
        "class": mergedClassName,
        "listHeight": listHeight,
        "listItemHeight": listItemHeight,
        "treeLine": !!treeLine,
        "inputIcon": suffixIcon,
        "multiple": multiple,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "switcherIcon": (nodeProps) => renderSwitcherIcon(treePrefixCls.value, switcherIcon, nodeProps, slots.leafIcon, treeLine),
        "showTreeIcon": treeIcon,
        "notFoundContent": mergedNotFound,
        "getPopupContainer": getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        "treeMotion": null,
        "dropdownClassName": mergedDropdownClassName.value,
        "choiceTransitionName": choiceTransitionName.value,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "onSearch": handleSearch,
        "onTreeExpand": handleTreeExpand
      }, otherProps), {}, {
        "transitionName": transitionName.value,
        "customSlots": _extends(_extends({}, slots), {
          treeCheckable: () => createVNode("span", {
            "class": `${prefixCls.value}-tree-checkbox-inner`
          }, null)
        }),
        "maxTagPlaceholder": props2.maxTagPlaceholder || slots.maxTagPlaceholder,
        "placement": placement.value,
        "showArrow": hasFeedback || showArrow,
        "placeholder": placeholder
      }), _extends(_extends({}, slots), {
        treeCheckable: () => createVNode("span", {
          "class": `${prefixCls.value}-tree-checkbox-inner`
        }, null)
      }))));
    };
  }
});
var TreeSelectNode = TreeNode_default;
var tree_select_default = _extends(TreeSelect, {
  TreeNode: TreeNode_default,
  SHOW_ALL,
  SHOW_PARENT: SHOW_PARENT2,
  SHOW_CHILD: SHOW_CHILD2,
  install: (app) => {
    app.component(TreeSelect.name, TreeSelect);
    app.component(TreeSelectNode.displayName, TreeSelectNode);
    return app;
  }
});

// node_modules/ant-design-vue/es/time-picker/time-picker.js
var timePickerProps = () => ({
  format: String,
  showNow: booleanType(),
  showHour: booleanType(),
  showMinute: booleanType(),
  showSecond: booleanType(),
  use12Hours: booleanType(),
  hourStep: Number,
  minuteStep: Number,
  secondStep: Number,
  hideDisabledOptions: booleanType(),
  popupClassName: String,
  status: stringType()
});
function createTimePicker(generateConfig2) {
  const DatePicker2 = generatePicker_default(generateConfig2, _extends(_extends({}, timePickerProps()), {
    order: {
      type: Boolean,
      default: true
    }
  }));
  const {
    TimePicker: InternalTimePicker,
    RangePicker: InternalRangePicker
  } = DatePicker2;
  const TimePicker3 = defineComponent({
    name: "ATimePicker",
    inheritAttrs: false,
    props: _extends(_extends(_extends(_extends({}, commonProps()), datePickerProps()), timePickerProps()), {
      addon: {
        type: Function
      }
    }),
    slots: Object,
    setup(p, _ref) {
      let {
        slots,
        expose,
        emit,
        attrs
      } = _ref;
      const props2 = p;
      const formItemContext = useInjectFormItemContext();
      devWarning_default(!(slots.addon || props2.addon), "TimePicker", "`addon` is deprecated. Please use `v-slot:renderExtraFooter` instead.");
      const pickerRef = ref();
      expose({
        focus: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const onChange = (value, dateString) => {
        emit("update:value", value);
        emit("change", value, dateString);
        formItemContext.onFieldChange();
      };
      const onOpenChange = (open2) => {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      const onFocus = (e) => {
        emit("focus", e);
      };
      const onBlur = (e) => {
        emit("blur", e);
        formItemContext.onFieldBlur();
      };
      const onOk = (value) => {
        emit("ok", value);
      };
      return () => {
        const {
          id = formItemContext.id.value
        } = props2;
        return createVNode(InternalTimePicker, _objectSpread2(_objectSpread2(_objectSpread2({}, attrs), omit_default(props2, ["onUpdate:value", "onUpdate:open"])), {}, {
          "id": id,
          "dropdownClassName": props2.popupClassName,
          "mode": void 0,
          "ref": pickerRef,
          "renderExtraFooter": props2.addon || slots.addon || props2.renderExtraFooter || slots.renderExtraFooter,
          "onChange": onChange,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onOk": onOk
        }), slots);
      };
    }
  });
  const TimeRangePicker2 = defineComponent({
    name: "ATimeRangePicker",
    inheritAttrs: false,
    props: _extends(_extends(_extends(_extends({}, commonProps()), rangePickerProps()), timePickerProps()), {
      order: {
        type: Boolean,
        default: true
      }
    }),
    slots: Object,
    setup(p, _ref2) {
      let {
        slots,
        expose,
        emit,
        attrs
      } = _ref2;
      const props2 = p;
      const pickerRef = ref();
      const formItemContext = useInjectFormItemContext();
      expose({
        focus: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const onChange = (values, dateStrings) => {
        emit("update:value", values);
        emit("change", values, dateStrings);
        formItemContext.onFieldChange();
      };
      const onOpenChange = (open2) => {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      const onFocus = (e) => {
        emit("focus", e);
      };
      const onBlur = (e) => {
        emit("blur", e);
        formItemContext.onFieldBlur();
      };
      const onPanelChange = (values, modes) => {
        emit("panelChange", values, modes);
      };
      const onOk = (values) => {
        emit("ok", values);
      };
      const onCalendarChange = (values, dateStrings, info) => {
        emit("calendarChange", values, dateStrings, info);
      };
      return () => {
        const {
          id = formItemContext.id.value
        } = props2;
        return createVNode(InternalRangePicker, _objectSpread2(_objectSpread2(_objectSpread2({}, attrs), omit_default(props2, ["onUpdate:open", "onUpdate:value"])), {}, {
          "id": id,
          "dropdownClassName": props2.popupClassName,
          "picker": "time",
          "mode": void 0,
          "ref": pickerRef,
          "onChange": onChange,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onPanelChange": onPanelChange,
          "onOk": onOk,
          "onCalendarChange": onCalendarChange
        }), slots);
      };
    }
  });
  return {
    TimePicker: TimePicker3,
    TimeRangePicker: TimeRangePicker2
  };
}
var time_picker_default = createTimePicker;

// node_modules/ant-design-vue/es/time-picker/dayjs.js
var {
  TimePicker: TimePicker2,
  TimeRangePicker
} = time_picker_default(dayjs_default);
var dayjs_default4 = _extends(TimePicker2, {
  TimePicker: TimePicker2,
  TimeRangePicker,
  install: (app) => {
    app.component(TimePicker2.name, TimePicker2);
    app.component(TimeRangePicker.name, TimeRangePicker);
    return app;
  }
});

// node_modules/ant-design-vue/es/time-picker/index.js
var time_picker_default2 = dayjs_default4;

// node_modules/ant-design-vue/es/timeline/TimelineItem.js
var timelineItemProps = () => ({
  prefixCls: String,
  color: String,
  dot: vue_types_default.any,
  pending: booleanType(),
  position: vue_types_default.oneOf(tuple("left", "right", "")).def(""),
  label: vue_types_default.any
});
var TimelineItem_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATimelineItem",
  props: initDefaultProps_default(timelineItemProps(), {
    color: "blue",
    pending: false
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("timeline", props2);
    const itemClassName = computed(() => ({
      [`${prefixCls.value}-item`]: true,
      [`${prefixCls.value}-item-pending`]: props2.pending
    }));
    const customColor = computed(() => /blue|red|green|gray/.test(props2.color || "") ? void 0 : props2.color || "blue");
    const dotClassName = computed(() => ({
      [`${prefixCls.value}-item-head`]: true,
      [`${prefixCls.value}-item-head-${props2.color || "blue"}`]: !customColor.value
    }));
    return () => {
      var _a2, _b, _c;
      const {
        label = (_a2 = slots.label) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        dot = (_b = slots.dot) === null || _b === void 0 ? void 0 : _b.call(slots)
      } = props2;
      return createVNode("li", {
        "class": itemClassName.value
      }, [label && createVNode("div", {
        "class": `${prefixCls.value}-item-label`
      }, [label]), createVNode("div", {
        "class": `${prefixCls.value}-item-tail`
      }, null), createVNode("div", {
        "class": [dotClassName.value, !!dot && `${prefixCls.value}-item-head-custom`],
        "style": {
          borderColor: customColor.value,
          color: customColor.value
        }
      }, [dot]), createVNode("div", {
        "class": `${prefixCls.value}-item-content`
      }, [(_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots)])]);
    };
  }
});

// node_modules/ant-design-vue/es/timeline/style/index.js
var genTimelineStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      margin: 0,
      padding: 0,
      listStyle: "none",
      [`${componentCls}-item`]: {
        position: "relative",
        margin: 0,
        paddingBottom: token.timeLineItemPaddingBottom,
        fontSize: token.fontSize,
        listStyle: "none",
        "&-tail": {
          position: "absolute",
          insetBlockStart: token.timeLineItemHeadSize,
          insetInlineStart: (token.timeLineItemHeadSize - token.timeLineItemTailWidth) / 2,
          height: `calc(100% - ${token.timeLineItemHeadSize}px)`,
          borderInlineStart: `${token.timeLineItemTailWidth}px ${token.lineType} ${token.colorSplit}`
        },
        "&-pending": {
          [`${componentCls}-item-head`]: {
            fontSize: token.fontSizeSM,
            backgroundColor: "transparent"
          },
          [`${componentCls}-item-tail`]: {
            display: "none"
          }
        },
        "&-head": {
          position: "absolute",
          width: token.timeLineItemHeadSize,
          height: token.timeLineItemHeadSize,
          backgroundColor: token.colorBgContainer,
          border: `${token.timeLineHeadBorderWidth}px ${token.lineType} transparent`,
          borderRadius: "50%",
          "&-blue": {
            color: token.colorPrimary,
            borderColor: token.colorPrimary
          },
          "&-red": {
            color: token.colorError,
            borderColor: token.colorError
          },
          "&-green": {
            color: token.colorSuccess,
            borderColor: token.colorSuccess
          },
          "&-gray": {
            color: token.colorTextDisabled,
            borderColor: token.colorTextDisabled
          }
        },
        "&-head-custom": {
          position: "absolute",
          insetBlockStart: token.timeLineItemHeadSize / 2,
          insetInlineStart: token.timeLineItemHeadSize / 2,
          width: "auto",
          height: "auto",
          marginBlockStart: 0,
          paddingBlock: token.timeLineItemCustomHeadPaddingVertical,
          lineHeight: 1,
          textAlign: "center",
          border: 0,
          borderRadius: 0,
          transform: `translate(-50%, -50%)`
        },
        "&-content": {
          position: "relative",
          insetBlockStart: -(token.fontSize * token.lineHeight - token.fontSize) + token.lineWidth,
          marginInlineStart: token.margin + token.timeLineItemHeadSize,
          marginInlineEnd: 0,
          marginBlockStart: 0,
          marginBlockEnd: 0,
          wordBreak: "break-word"
        },
        "&-last": {
          [`> ${componentCls}-item-tail`]: {
            display: "none"
          },
          [`> ${componentCls}-item-content`]: {
            minHeight: token.controlHeightLG * 1.2
          }
        }
      },
      [`&${componentCls}-alternate,
        &${componentCls}-right,
        &${componentCls}-label`]: {
        [`${componentCls}-item`]: {
          "&-tail, &-head, &-head-custom": {
            insetInlineStart: "50%"
          },
          "&-head": {
            marginInlineStart: `-${token.marginXXS}px`,
            "&-custom": {
              marginInlineStart: token.timeLineItemTailWidth / 2
            }
          },
          "&-left": {
            [`${componentCls}-item-content`]: {
              insetInlineStart: `calc(50% - ${token.marginXXS}px)`,
              width: `calc(50% - ${token.marginSM}px)`,
              textAlign: "start"
            }
          },
          "&-right": {
            [`${componentCls}-item-content`]: {
              width: `calc(50% - ${token.marginSM}px)`,
              margin: 0,
              textAlign: "end"
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`${componentCls}-item-right`]: {
          [`${componentCls}-item-tail,
            ${componentCls}-item-head,
            ${componentCls}-item-head-custom`]: {
            insetInlineStart: `calc(100% - ${(token.timeLineItemHeadSize + token.timeLineItemTailWidth) / 2}px)`
          },
          [`${componentCls}-item-content`]: {
            width: `calc(100% - ${token.timeLineItemHeadSize + token.marginXS}px)`
          }
        }
      },
      [`&${componentCls}-pending
        ${componentCls}-item-last
        ${componentCls}-item-tail`]: {
        display: "block",
        height: `calc(100% - ${token.margin}px)`,
        borderInlineStart: `${token.timeLineItemTailWidth}px dotted ${token.colorSplit}`
      },
      [`&${componentCls}-reverse
        ${componentCls}-item-last
        ${componentCls}-item-tail`]: {
        display: "none"
      },
      [`&${componentCls}-reverse ${componentCls}-item-pending`]: {
        [`${componentCls}-item-tail`]: {
          insetBlockStart: token.margin,
          display: "block",
          height: `calc(100% - ${token.margin}px)`,
          borderInlineStart: `${token.timeLineItemTailWidth}px dotted ${token.colorSplit}`
        },
        [`${componentCls}-item-content`]: {
          minHeight: token.controlHeightLG * 1.2
        }
      },
      [`&${componentCls}-label`]: {
        [`${componentCls}-item-label`]: {
          position: "absolute",
          insetBlockStart: -(token.fontSize * token.lineHeight - token.fontSize) + token.timeLineItemTailWidth,
          width: `calc(50% - ${token.marginSM}px)`,
          textAlign: "end"
        },
        [`${componentCls}-item-right`]: {
          [`${componentCls}-item-label`]: {
            insetInlineStart: `calc(50% + ${token.marginSM}px)`,
            width: `calc(50% - ${token.marginSM}px)`,
            textAlign: "start"
          }
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-item-head-custom`]: {
          transform: `translate(50%, -50%)`
        }
      }
    })
  };
};
var style_default34 = genComponentStyleHook("Timeline", (token) => {
  const timeLineToken = merge(token, {
    timeLineItemPaddingBottom: token.padding * 1.25,
    timeLineItemHeadSize: 10,
    timeLineItemCustomHeadPaddingVertical: token.paddingXXS,
    timeLinePaddingInlineEnd: 2,
    timeLineItemTailWidth: token.lineWidthBold,
    timeLineHeadBorderWidth: token.wireframe ? token.lineWidthBold : token.lineWidth * 3
  });
  return [genTimelineStyle(timeLineToken)];
});

// node_modules/ant-design-vue/es/timeline/Timeline.js
var timelineProps = () => ({
  prefixCls: String,
  /** 指定最后一个幽灵节点是否存在或内容 */
  pending: vue_types_default.any,
  pendingDot: vue_types_default.any,
  reverse: booleanType(),
  mode: vue_types_default.oneOf(tuple("left", "alternate", "right", ""))
});
var Timeline_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATimeline",
  inheritAttrs: false,
  props: initDefaultProps_default(timelineProps(), {
    reverse: false,
    mode: ""
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("timeline", props2);
    const [wrapSSR, hashId] = style_default34(prefixCls);
    const getPositionCls = (ele, idx) => {
      const eleProps = ele.props || {};
      if (props2.mode === "alternate") {
        if (eleProps.position === "right")
          return `${prefixCls.value}-item-right`;
        if (eleProps.position === "left")
          return `${prefixCls.value}-item-left`;
        return idx % 2 === 0 ? `${prefixCls.value}-item-left` : `${prefixCls.value}-item-right`;
      }
      if (props2.mode === "left")
        return `${prefixCls.value}-item-left`;
      if (props2.mode === "right")
        return `${prefixCls.value}-item-right`;
      if (eleProps.position === "right")
        return `${prefixCls.value}-item-right`;
      return "";
    };
    return () => {
      var _a2, _b, _c;
      const {
        pending = (_a2 = slots.pending) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        pendingDot = (_b = slots.pendingDot) === null || _b === void 0 ? void 0 : _b.call(slots),
        reverse,
        mode
      } = props2;
      const pendingNode = typeof pending === "boolean" ? null : pending;
      const children = filterEmpty((_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots));
      const pendingItem = pending ? createVNode(TimelineItem_default, {
        "pending": !!pending,
        "dot": pendingDot || createVNode(LoadingOutlined_default, null, null)
      }, {
        default: () => [pendingNode]
      }) : null;
      if (pendingItem) {
        children.push(pendingItem);
      }
      const timeLineItems = reverse ? children.reverse() : children;
      const itemsCount = timeLineItems.length;
      const lastCls = `${prefixCls.value}-item-last`;
      const items = timeLineItems.map((ele, idx) => {
        const pendingClass = idx === itemsCount - 2 ? lastCls : "";
        const readyClass = idx === itemsCount - 1 ? lastCls : "";
        return cloneVNode(ele, {
          class: classNames_default([!reverse && !!pending ? pendingClass : readyClass, getPositionCls(ele, idx)])
        });
      });
      const hasLabelItem = timeLineItems.some((item) => {
        var _a3, _b2;
        return !!(((_a3 = item.props) === null || _a3 === void 0 ? void 0 : _a3.label) || ((_b2 = item.children) === null || _b2 === void 0 ? void 0 : _b2.label));
      });
      const classString = classNames_default(prefixCls.value, {
        [`${prefixCls.value}-pending`]: !!pending,
        [`${prefixCls.value}-reverse`]: !!reverse,
        [`${prefixCls.value}-${mode}`]: !!mode && !hasLabelItem,
        [`${prefixCls.value}-label`]: hasLabelItem,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value);
      return wrapSSR(createVNode("ul", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": classString
      }), [items]));
    };
  }
});

// node_modules/ant-design-vue/es/timeline/index.js
Timeline_default.Item = TimelineItem_default;
Timeline_default.install = function(app) {
  app.component(Timeline_default.name, Timeline_default);
  app.component(TimelineItem_default.name, TimelineItem_default);
  return app;
};
var timeline_default = Timeline_default;

// node_modules/ant-design-vue/es/typography/style/mixins.js
var getTitleStyle = (fontSize, lineHeight, color, token) => {
  const {
    sizeMarginHeadingVerticalEnd,
    fontWeightStrong
  } = token;
  return {
    marginBottom: sizeMarginHeadingVerticalEnd,
    color,
    fontWeight: fontWeightStrong,
    fontSize,
    lineHeight
  };
};
var getTitleStyles = (token) => {
  const headings = [1, 2, 3, 4, 5];
  const styles = {};
  headings.forEach((headingLevel) => {
    styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token[`fontSizeHeading${headingLevel}`], token[`lineHeightHeading${headingLevel}`], token.colorTextHeading, token);
  });
  return styles;
};
var getLinkStyles = (token) => {
  const {
    componentCls
  } = token;
  return {
    "a&, a": _extends(_extends({}, operationUnit(token)), {
      textDecoration: token.linkDecoration,
      "&:active, &:hover": {
        textDecoration: token.linkHoverDecoration
      },
      [`&[disabled], &${componentCls}-disabled`]: {
        color: token.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: token.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
};
var getResetStyles = () => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: gold[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
});
var getEditableStyles = (token) => {
  const {
    componentCls
  } = token;
  const inputToken = initInputToken(token);
  const inputShift = inputToken.inputPaddingVertical + 1;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: -token.paddingSM,
        marginTop: -inputShift,
        marginBottom: `calc(1em - ${inputShift}px)`
      },
      [`${componentCls}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: token.marginXS + 2,
        insetBlockEnd: token.marginXS,
        color: token.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: token.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
};
var getCopiableStyles = (token) => ({
  "&-copy-success": {
    [`
    &,
    &:hover,
    &:focus`]: {
      color: token.colorSuccess
    }
  }
});
var getEllipsisStyles = () => ({
  [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-single-line": {
    whiteSpace: "nowrap"
  },
  "&-ellipsis-single-line": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
});

// node_modules/ant-design-vue/es/typography/style/index.js
var genTypographyStyle = (token) => {
  const {
    componentCls,
    sizeMarginHeadingVerticalStart
  } = token;
  return {
    [componentCls]: _extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends(_extends({
      color: token.colorText,
      wordBreak: "break-word",
      lineHeight: token.lineHeight,
      [`&${componentCls}-secondary`]: {
        color: token.colorTextDescription
      },
      [`&${componentCls}-success`]: {
        color: token.colorSuccess
      },
      [`&${componentCls}-warning`]: {
        color: token.colorWarning
      },
      [`&${componentCls}-danger`]: {
        color: token.colorError,
        "a&:active, a&:focus": {
          color: token.colorErrorActive
        },
        "a&:hover": {
          color: token.colorErrorHover
        }
      },
      [`&${componentCls}-disabled`]: {
        color: token.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      [`
        div&,
        p
      `]: {
        marginBottom: "1em"
      }
    }, getTitleStyles(token)), {
      [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
        marginTop: sizeMarginHeadingVerticalStart
      },
      [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
        [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
          marginTop: sizeMarginHeadingVerticalStart
        }
      }
    }), getResetStyles()), getLinkStyles(token)), {
      // Operation
      [`
        ${componentCls}-expand,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: _extends(_extends({}, operationUnit(token)), {
        marginInlineStart: token.marginXXS
      })
    }), getEditableStyles(token)), getCopiableStyles(token)), getEllipsisStyles()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
};
var style_default35 = genComponentStyleHook("Typography", (token) => [genTypographyStyle(token)], {
  sizeMarginHeadingVerticalStart: "1.2em",
  sizeMarginHeadingVerticalEnd: "0.5em"
});

// node_modules/ant-design-vue/es/typography/Editable.js
var editableProps = () => ({
  prefixCls: String,
  value: String,
  maxlength: Number,
  autoSize: {
    type: [Boolean, Object]
  },
  onSave: Function,
  onCancel: Function,
  onEnd: Function,
  onChange: Function,
  originContent: String,
  direction: String,
  component: String
});
var Editable = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Editable",
  inheritAttrs: false,
  props: editableProps(),
  // emits: ['save', 'cancel', 'end', 'change'],
  setup(props2, _ref) {
    let {
      emit,
      slots,
      attrs
    } = _ref;
    const {
      prefixCls
    } = toRefs(props2);
    const state = reactive({
      current: props2.value || "",
      lastKeyCode: void 0,
      inComposition: false,
      cancelFlag: false
    });
    watch(() => props2.value, (current) => {
      state.current = current;
    });
    const textArea = ref();
    onMounted(() => {
      var _a2;
      if (textArea.value) {
        const resizableTextArea = (_a2 = textArea.value) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea;
        const innerTextArea = resizableTextArea === null || resizableTextArea === void 0 ? void 0 : resizableTextArea.textArea;
        innerTextArea.focus();
        const {
          length
        } = innerTextArea.value;
        innerTextArea.setSelectionRange(length, length);
      }
    });
    function saveTextAreaRef(node) {
      textArea.value = node;
    }
    function onChange(_ref2) {
      let {
        target: {
          value
        }
      } = _ref2;
      state.current = value.replace(/[\r\n]/g, "");
      emit("change", state.current);
    }
    function onCompositionStart() {
      state.inComposition = true;
    }
    function onCompositionEnd() {
      state.inComposition = false;
    }
    function onKeyDown(e) {
      const {
        keyCode
      } = e;
      if (keyCode === KeyCode_default.ENTER) {
        e.preventDefault();
      }
      if (state.inComposition)
        return;
      state.lastKeyCode = keyCode;
    }
    function onKeyUp(e) {
      const {
        keyCode,
        ctrlKey,
        altKey,
        metaKey,
        shiftKey
      } = e;
      if (state.lastKeyCode === keyCode && !state.inComposition && !ctrlKey && !altKey && !metaKey && !shiftKey) {
        if (keyCode === KeyCode_default.ENTER) {
          confirmChange();
          emit("end");
        } else if (keyCode === KeyCode_default.ESC) {
          state.current = props2.originContent;
          emit("cancel");
        }
      }
    }
    function onBlur() {
      confirmChange();
    }
    function confirmChange() {
      emit("save", state.current.trim());
    }
    const [wrapSSR, hashId] = style_default35(prefixCls);
    return () => {
      const textAreaClassName = classNames_default({
        [`${prefixCls.value}`]: true,
        [`${prefixCls.value}-edit-content`]: true,
        [`${prefixCls.value}-rtl`]: props2.direction === "rtl",
        [props2.component ? `${prefixCls.value}-${props2.component}` : ""]: true
      }, attrs.class, hashId.value);
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": textAreaClassName
      }), [createVNode(TextArea_default, {
        "ref": saveTextAreaRef,
        "maxlength": props2.maxlength,
        "value": state.current,
        "onChange": onChange,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp,
        "onCompositionstart": onCompositionStart,
        "onCompositionend": onCompositionEnd,
        "onBlur": onBlur,
        "rows": 1,
        "autoSize": props2.autoSize === void 0 || props2.autoSize
      }, null), slots.enterIcon ? slots.enterIcon({
        className: `${props2.prefixCls}-edit-content-confirm`
      }) : createVNode(EnterOutlined_default, {
        "class": `${props2.prefixCls}-edit-content-confirm`
      }, null)]));
    };
  }
});
var Editable_default = Editable;

// node_modules/ant-design-vue/es/typography/util.js
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var ellipsisContainer;
var wrapperStyle = {
  padding: 0,
  margin: 0,
  display: "inline",
  lineHeight: "inherit"
};
function resetDomStyles(target, origin) {
  target.setAttribute("aria-hidden", "true");
  const originStyle = window.getComputedStyle(origin);
  const originCSS = styleToString(originStyle);
  target.setAttribute("style", originCSS);
  target.style.position = "fixed";
  target.style.left = "0";
  target.style.height = "auto";
  target.style.minHeight = "auto";
  target.style.maxHeight = "auto";
  target.style.paddingTop = "0";
  target.style.paddingBottom = "0";
  target.style.borderTopWidth = "0";
  target.style.borderBottomWidth = "0";
  target.style.top = "-999999px";
  target.style.zIndex = "-1000";
  target.style.textOverflow = "clip";
  target.style.whiteSpace = "normal";
  target.style.webkitLineClamp = "none";
}
function getRealLineHeight(originElement) {
  const heightContainer = document.createElement("div");
  resetDomStyles(heightContainer, originElement);
  heightContainer.appendChild(document.createTextNode("text"));
  document.body.appendChild(heightContainer);
  const realHeight = heightContainer.getBoundingClientRect().height;
  document.body.removeChild(heightContainer);
  return realHeight;
}
var util_default2 = (originElement, option, content, fixedContent, ellipsisStr) => {
  if (!ellipsisContainer) {
    ellipsisContainer = document.createElement("div");
    ellipsisContainer.setAttribute("aria-hidden", "true");
    document.body.appendChild(ellipsisContainer);
  }
  const {
    rows,
    suffix = ""
  } = option;
  const lineHeight = getRealLineHeight(originElement);
  const maxHeight = Math.round(lineHeight * rows * 100) / 100;
  resetDomStyles(ellipsisContainer, originElement);
  const vm = createApp({
    render() {
      return createVNode("div", {
        "style": wrapperStyle
      }, [createVNode("span", {
        "style": wrapperStyle
      }, [content, suffix]), createVNode("span", {
        "style": wrapperStyle
      }, [fixedContent])]);
    }
  });
  vm.mount(ellipsisContainer);
  function inRange() {
    const currentHeight = Math.round(ellipsisContainer.getBoundingClientRect().height * 100) / 100;
    return currentHeight - 0.1 <= maxHeight;
  }
  if (inRange()) {
    vm.unmount();
    return {
      content,
      text: ellipsisContainer.innerHTML,
      ellipsis: false
    };
  }
  const childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter((_ref) => {
    let {
      nodeType,
      data
    } = _ref;
    return nodeType !== COMMENT_NODE && data !== "";
  });
  const fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);
  vm.unmount();
  const ellipsisChildren = [];
  ellipsisContainer.innerHTML = "";
  const ellipsisContentHolder = document.createElement("span");
  ellipsisContainer.appendChild(ellipsisContentHolder);
  const ellipsisTextNode = document.createTextNode(ellipsisStr + suffix);
  ellipsisContentHolder.appendChild(ellipsisTextNode);
  fixedNodes.forEach((childNode) => {
    ellipsisContainer.appendChild(childNode);
  });
  function appendChildNode(node) {
    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);
  }
  function measureText(textNode, fullText) {
    let startLoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let endLoc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fullText.length;
    let lastSuccessLoc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    const midLoc = Math.floor((startLoc + endLoc) / 2);
    const currentText = fullText.slice(0, midLoc);
    textNode.textContent = currentText;
    if (startLoc >= endLoc - 1) {
      for (let step = endLoc; step >= startLoc; step -= 1) {
        const currentStepText = fullText.slice(0, step);
        textNode.textContent = currentStepText;
        if (inRange() || !currentStepText) {
          return step === fullText.length ? {
            finished: false,
            vNode: fullText
          } : {
            finished: true,
            vNode: currentStepText
          };
        }
      }
    }
    if (inRange()) {
      return measureText(textNode, fullText, midLoc, endLoc, midLoc);
    }
    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);
  }
  function measureNode(childNode) {
    const type = childNode.nodeType;
    if (type === TEXT_NODE) {
      const fullText = childNode.textContent || "";
      const textNode = document.createTextNode(fullText);
      appendChildNode(textNode);
      return measureText(textNode, fullText);
    }
    return {
      finished: false,
      vNode: null
    };
  }
  childNodes.some((childNode) => {
    const {
      finished,
      vNode
    } = measureNode(childNode);
    if (vNode) {
      ellipsisChildren.push(vNode);
    }
    return finished;
  });
  return {
    content: ellipsisChildren,
    text: ellipsisContainer.innerHTML,
    ellipsis: true
  };
};

// node_modules/ant-design-vue/es/typography/Typography.js
var __rest31 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var typographyProps = () => ({
  prefixCls: String,
  direction: String,
  // Form Internal use
  component: String
});
var Typography = defineComponent({
  name: "ATypography",
  inheritAttrs: false,
  props: typographyProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("typography", props2);
    const [wrapSSR, hashId] = style_default35(prefixCls);
    return () => {
      var _a2;
      const _b = _extends(_extends({}, props2), attrs), {
        prefixCls: _prefixCls,
        direction: _direction,
        component: Component = "article"
      } = _b, restProps = __rest31(_b, ["prefixCls", "direction", "component"]);
      return wrapSSR(createVNode(Component, _objectSpread2(_objectSpread2({}, restProps), {}, {
        "class": classNames_default(prefixCls.value, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value)
      }), {
        default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
      }));
    };
  }
});
var Typography_default = Typography;

// node_modules/ant-design-vue/es/_util/copy-to-clipboard/toggle-selection.js
var deselectCurrent = () => {
  const selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  let active = document.activeElement;
  const ranges = [];
  for (let i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }
    active && active.focus();
  };
};
var toggle_selection_default = deselectCurrent;

// node_modules/ant-design-vue/es/_util/copy-to-clipboard/index.js
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  const copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text, options) {
  let message, reselectPrevious, range, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  const debug = options.debug || false;
  try {
    reselectPrevious = toggle_selection_default();
    range = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e) {
      e.stopPropagation();
      if (options.format) {
        e.preventDefault();
        if (typeof e.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          const format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e.clipboardData.clearData();
          e.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e.preventDefault();
        options.onCopy(e.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range.selectNodeContents(mark);
    selection.addRange(range);
    const successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copy_to_clipboard_default = copy;

// node_modules/ant-design-vue/es/typography/Base.js
var __rest32 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var isLineClampSupport = isStyleSupport("webkitLineClamp");
var isTextOverflowSupport = isStyleSupport("textOverflow");
var ELLIPSIS_STR = "...";
var baseProps2 = () => ({
  editable: {
    type: [Boolean, Object],
    default: void 0
  },
  copyable: {
    type: [Boolean, Object],
    default: void 0
  },
  prefixCls: String,
  component: String,
  type: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  },
  code: {
    type: Boolean,
    default: void 0
  },
  mark: {
    type: Boolean,
    default: void 0
  },
  underline: {
    type: Boolean,
    default: void 0
  },
  delete: {
    type: Boolean,
    default: void 0
  },
  strong: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  content: String,
  "onUpdate:content": Function
});
var Base = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TypographyBase",
  inheritAttrs: false,
  props: baseProps2(),
  // emits: ['update:content'],
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject_default("typography", props2);
    const state = reactive({
      copied: false,
      ellipsisText: "",
      ellipsisContent: null,
      isEllipsis: false,
      expanded: false,
      clientRendered: false,
      //locale
      expandStr: "",
      copyStr: "",
      copiedStr: "",
      editStr: "",
      copyId: void 0,
      rafId: void 0,
      prevProps: void 0,
      originContent: ""
    });
    const contentRef = ref();
    const editIcon = ref();
    const ellipsis = computed(() => {
      const ellipsis2 = props2.ellipsis;
      if (!ellipsis2)
        return {};
      return _extends({
        rows: 1,
        expandable: false
      }, typeof ellipsis2 === "object" ? ellipsis2 : null);
    });
    onMounted(() => {
      state.clientRendered = true;
      syncEllipsis();
    });
    onBeforeUnmount(() => {
      clearTimeout(state.copyId);
      wrapperRaf.cancel(state.rafId);
    });
    watch([() => ellipsis.value.rows, () => props2.content], () => {
      nextTick(() => {
        resizeOnNextFrame();
      });
    }, {
      flush: "post",
      deep: true
    });
    watchEffect(() => {
      if (props2.content === void 0) {
        warning_default2(!props2.editable, "Typography", "When `editable` is enabled, please use `content` instead of children");
        warning_default2(!props2.ellipsis, "Typography", "When `ellipsis` is enabled, please use `content` instead of children");
      }
    });
    function getChildrenText() {
      var _a2;
      return props2.ellipsis || props2.editable ? props2.content : (_a2 = findDOMNode(contentRef.value)) === null || _a2 === void 0 ? void 0 : _a2.innerText;
    }
    function onExpandClick(e) {
      const {
        onExpand
      } = ellipsis.value;
      state.expanded = true;
      onExpand === null || onExpand === void 0 ? void 0 : onExpand(e);
    }
    function onEditClick(e) {
      e.preventDefault();
      state.originContent = props2.content;
      triggerEdit(true);
    }
    function onEditChange(value) {
      onContentChange(value);
      triggerEdit(false);
    }
    function onContentChange(value) {
      const {
        onChange
      } = editable.value;
      if (value !== props2.content) {
        emit("update:content", value);
        onChange === null || onChange === void 0 ? void 0 : onChange(value);
      }
    }
    function onEditCancel() {
      var _a2, _b;
      (_b = (_a2 = editable.value).onCancel) === null || _b === void 0 ? void 0 : _b.call(_a2);
      triggerEdit(false);
    }
    function onCopyClick(e) {
      e.preventDefault();
      e.stopPropagation();
      const {
        copyable
      } = props2;
      const copyConfig = _extends({}, typeof copyable === "object" ? copyable : null);
      if (copyConfig.text === void 0) {
        copyConfig.text = getChildrenText();
      }
      copy_to_clipboard_default(copyConfig.text || "");
      state.copied = true;
      nextTick(() => {
        if (copyConfig.onCopy) {
          copyConfig.onCopy(e);
        }
        state.copyId = setTimeout(() => {
          state.copied = false;
        }, 3e3);
      });
    }
    const editable = computed(() => {
      const editable2 = props2.editable;
      if (!editable2)
        return {
          editing: false
        };
      return _extends({}, typeof editable2 === "object" ? editable2 : null);
    });
    const [editing, setEditing] = useMergedState(false, {
      value: computed(() => {
        return editable.value.editing;
      })
    });
    function triggerEdit(edit) {
      const {
        onStart
      } = editable.value;
      if (edit && onStart) {
        onStart();
      }
      setEditing(edit);
    }
    watch(editing, (val) => {
      var _a2;
      if (!val) {
        (_a2 = editIcon.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      }
    }, {
      flush: "post"
    });
    function resizeOnNextFrame(sizeInfo) {
      if (sizeInfo) {
        const {
          width,
          height
        } = sizeInfo;
        if (!width || !height)
          return;
      }
      wrapperRaf.cancel(state.rafId);
      state.rafId = wrapperRaf(() => {
        syncEllipsis();
      });
    }
    const canUseCSSEllipsis = computed(() => {
      const {
        rows,
        expandable,
        suffix,
        onEllipsis,
        tooltip
      } = ellipsis.value;
      if (suffix || tooltip)
        return false;
      if (props2.editable || props2.copyable || expandable || onEllipsis) {
        return false;
      }
      if (rows === 1) {
        return isTextOverflowSupport;
      }
      return isLineClampSupport;
    });
    const syncEllipsis = () => {
      const {
        ellipsisText,
        isEllipsis
      } = state;
      const {
        rows,
        suffix,
        onEllipsis
      } = ellipsis.value;
      if (!rows || rows < 0 || !findDOMNode(contentRef.value) || state.expanded || props2.content === void 0)
        return;
      if (canUseCSSEllipsis.value)
        return;
      const {
        content,
        text,
        ellipsis: ell
      } = util_default2(findDOMNode(contentRef.value), {
        rows,
        suffix
      }, props2.content, renderOperations(true), ELLIPSIS_STR);
      if (ellipsisText !== text || state.isEllipsis !== ell) {
        state.ellipsisText = text;
        state.ellipsisContent = content;
        state.isEllipsis = ell;
        if (isEllipsis !== ell && onEllipsis) {
          onEllipsis(ell);
        }
      }
    };
    function wrapperDecorations(_ref2, content) {
      let {
        mark,
        code,
        underline,
        delete: del,
        strong,
        keyboard
      } = _ref2;
      let currentContent = content;
      function wrap(needed, Tag) {
        if (!needed)
          return;
        const _currentContent = function() {
          return currentContent;
        }();
        currentContent = createVNode(Tag, null, {
          default: () => [_currentContent]
        });
      }
      wrap(strong, "strong");
      wrap(underline, "u");
      wrap(del, "del");
      wrap(code, "code");
      wrap(mark, "mark");
      wrap(keyboard, "kbd");
      return currentContent;
    }
    function renderExpand(forceRender) {
      const {
        expandable,
        symbol
      } = ellipsis.value;
      if (!expandable)
        return null;
      if (!forceRender && (state.expanded || !state.isEllipsis))
        return null;
      const expandContent = (slots.ellipsisSymbol ? slots.ellipsisSymbol() : symbol) || state.expandStr;
      return createVNode("a", {
        "key": "expand",
        "class": `${prefixCls.value}-expand`,
        "onClick": onExpandClick,
        "aria-label": state.expandStr
      }, [expandContent]);
    }
    function renderEdit() {
      if (!props2.editable)
        return;
      const {
        tooltip,
        triggerType = ["icon"]
      } = props2.editable;
      const icon = slots.editableIcon ? slots.editableIcon() : createVNode(EditOutlined_default, {
        "role": "button"
      }, null);
      const title = slots.editableTooltip ? slots.editableTooltip() : state.editStr;
      const ariaLabel = typeof title === "string" ? title : "";
      return triggerType.indexOf("icon") !== -1 ? createVNode(tooltip_default, {
        "key": "edit",
        "title": tooltip === false ? "" : title
      }, {
        default: () => [createVNode(transButton_default, {
          "ref": editIcon,
          "class": `${prefixCls.value}-edit`,
          "onClick": onEditClick,
          "aria-label": ariaLabel
        }, {
          default: () => [icon]
        })]
      }) : null;
    }
    function renderCopy() {
      if (!props2.copyable)
        return;
      const {
        tooltip
      } = props2.copyable;
      const defaultTitle = state.copied ? state.copiedStr : state.copyStr;
      const title = slots.copyableTooltip ? slots.copyableTooltip({
        copied: state.copied
      }) : defaultTitle;
      const ariaLabel = typeof title === "string" ? title : "";
      const defaultIcon = state.copied ? createVNode(CheckOutlined_default, null, null) : createVNode(CopyOutlined_default, null, null);
      const icon = slots.copyableIcon ? slots.copyableIcon({
        copied: !!state.copied
      }) : defaultIcon;
      return createVNode(tooltip_default, {
        "key": "copy",
        "title": tooltip === false ? "" : title
      }, {
        default: () => [createVNode(transButton_default, {
          "class": [`${prefixCls.value}-copy`, {
            [`${prefixCls.value}-copy-success`]: state.copied
          }],
          "onClick": onCopyClick,
          "aria-label": ariaLabel
        }, {
          default: () => [icon]
        })]
      });
    }
    function renderEditInput() {
      const {
        class: className,
        style
      } = attrs;
      const {
        maxlength,
        autoSize,
        onEnd
      } = editable.value;
      return createVNode(Editable_default, {
        "class": className,
        "style": style,
        "prefixCls": prefixCls.value,
        "value": props2.content,
        "originContent": state.originContent,
        "maxlength": maxlength,
        "autoSize": autoSize,
        "onSave": onEditChange,
        "onChange": onContentChange,
        "onCancel": onEditCancel,
        "onEnd": onEnd,
        "direction": direction.value,
        "component": props2.component
      }, {
        enterIcon: slots.editableEnterIcon
      });
    }
    function renderOperations(forceRenderExpanded) {
      return [renderExpand(forceRenderExpanded), renderEdit(), renderCopy()].filter((node) => node);
    }
    return () => {
      var _a2;
      const {
        triggerType = ["icon"]
      } = editable.value;
      const children = props2.ellipsis || props2.editable ? props2.content !== void 0 ? props2.content : (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots) : slots.default ? slots.default() : props2.content;
      if (editing.value) {
        return renderEditInput();
      }
      return createVNode(LocaleReceiver_default2, {
        "componentName": "Text",
        "children": (locale) => {
          const _a3 = _extends(_extends({}, props2), attrs), {
            type,
            disabled,
            content,
            class: className,
            style
          } = _a3, restProps = __rest32(_a3, ["type", "disabled", "content", "class", "style"]);
          const {
            rows,
            suffix,
            tooltip
          } = ellipsis.value;
          const {
            edit,
            copy: copyStr,
            copied,
            expand
          } = locale;
          state.editStr = edit;
          state.copyStr = copyStr;
          state.copiedStr = copied;
          state.expandStr = expand;
          const textProps2 = omit_default(restProps, ["prefixCls", "editable", "copyable", "ellipsis", "mark", "code", "delete", "underline", "strong", "keyboard", "onUpdate:content"]);
          const cssEllipsis = canUseCSSEllipsis.value;
          const cssTextOverflow = rows === 1 && cssEllipsis;
          const cssLineClamp = rows && rows > 1 && cssEllipsis;
          let textNode = children;
          let ariaLabel;
          if (rows && state.isEllipsis && !state.expanded && !cssEllipsis) {
            const {
              title: title2
            } = restProps;
            let restContent = title2 || "";
            if (!title2 && (typeof children === "string" || typeof children === "number")) {
              restContent = String(children);
            }
            restContent = restContent === null || restContent === void 0 ? void 0 : restContent.slice(String(state.ellipsisContent || "").length);
            textNode = createVNode(Fragment, null, [toRaw(state.ellipsisContent), createVNode("span", {
              "title": restContent,
              "aria-hidden": "true"
            }, [ELLIPSIS_STR]), suffix]);
          } else {
            textNode = createVNode(Fragment, null, [children, suffix]);
          }
          textNode = wrapperDecorations(props2, textNode);
          const showTooltip = tooltip && rows && state.isEllipsis && !state.expanded && !cssEllipsis;
          const title = slots.ellipsisTooltip ? slots.ellipsisTooltip() : tooltip;
          return createVNode(vc_resize_observer_default, {
            "onResize": resizeOnNextFrame,
            "disabled": !rows
          }, {
            default: () => [createVNode(Typography_default, _objectSpread2({
              "ref": contentRef,
              "class": [{
                [`${prefixCls.value}-${type}`]: type,
                [`${prefixCls.value}-disabled`]: disabled,
                [`${prefixCls.value}-ellipsis`]: rows,
                [`${prefixCls.value}-single-line`]: rows === 1 && !state.isEllipsis,
                [`${prefixCls.value}-ellipsis-single-line`]: cssTextOverflow,
                [`${prefixCls.value}-ellipsis-multiple-line`]: cssLineClamp
              }, className],
              "style": _extends(_extends({}, style), {
                WebkitLineClamp: cssLineClamp ? rows : void 0
              }),
              "aria-label": ariaLabel,
              "direction": direction.value,
              "onClick": triggerType.indexOf("text") !== -1 ? onEditClick : () => {
              }
            }, textProps2), {
              default: () => [showTooltip ? createVNode(tooltip_default, {
                "title": tooltip === true ? children : title
              }, {
                default: () => [createVNode("span", null, [textNode])]
              }) : textNode, renderOperations()]
            })]
          });
        }
      }, null);
    };
  }
});
var Base_default = Base;

// node_modules/ant-design-vue/es/typography/Link.js
var __rest33 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var linkProps = () => omit_default(_extends(_extends({}, baseProps2()), {
  ellipsis: {
    type: Boolean,
    default: void 0
  }
}), ["component"]);
var Link = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const _a2 = _extends(_extends({}, props2), attrs), {
    ellipsis,
    rel
  } = _a2, restProps = __rest33(_a2, ["ellipsis", "rel"]);
  warning_default2(typeof ellipsis !== "object", "Typography.Link", "`ellipsis` only supports boolean value.");
  const mergedProps = _extends(_extends({}, restProps), {
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel,
    ellipsis: !!ellipsis,
    component: "a"
  });
  delete mergedProps.navigate;
  return createVNode(Base_default, mergedProps, slots);
};
Link.displayName = "ATypographyLink";
Link.inheritAttrs = false;
Link.props = linkProps();
var Link_default = Link;

// node_modules/ant-design-vue/es/typography/Paragraph.js
var paragraphProps = () => omit_default(baseProps2(), ["component"]);
var Paragraph = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const paragraphProps2 = _extends(_extends(_extends({}, props2), {
    component: "div"
  }), attrs);
  return createVNode(Base_default, paragraphProps2, slots);
};
Paragraph.displayName = "ATypographyParagraph";
Paragraph.inheritAttrs = false;
Paragraph.props = paragraphProps();
var Paragraph_default2 = Paragraph;

// node_modules/ant-design-vue/es/typography/Text.js
var textProps = () => _extends(_extends({}, omit_default(baseProps2(), ["component"])), {
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  }
});
var Text = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const {
    ellipsis
  } = props2;
  warning_default2(typeof ellipsis !== "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis), "Typography.Text", "`ellipsis` do not support `expandable` or `rows` props.");
  const textProps2 = _extends(_extends(_extends({}, props2), {
    ellipsis: ellipsis && typeof ellipsis === "object" ? omit_default(ellipsis, ["expandable", "rows"]) : ellipsis,
    component: "span"
  }), attrs);
  return createVNode(Base_default, textProps2, slots);
};
Text.displayName = "ATypographyText";
Text.inheritAttrs = false;
Text.props = textProps();
var Text_default = Text;

// node_modules/ant-design-vue/es/typography/Title.js
var __rest34 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var TITLE_ELE_LIST = tupleNum(1, 2, 3, 4, 5);
var titleProps = () => _extends(_extends({}, omit_default(baseProps2(), ["component", "strong"])), {
  level: Number
});
var Title = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const {
    level = 1
  } = props2, restProps = __rest34(props2, ["level"]);
  let component;
  if (TITLE_ELE_LIST.includes(level)) {
    component = `h${level}`;
  } else {
    warning_default2(false, "Typography", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value.");
    component = "h1";
  }
  const titleProps2 = _extends(_extends(_extends({}, restProps), {
    component
  }), attrs);
  return createVNode(Base_default, titleProps2, slots);
};
Title.displayName = "ATypographyTitle";
Title.inheritAttrs = false;
Title.props = titleProps();
var Title_default2 = Title;

// node_modules/ant-design-vue/es/typography/index.js
Typography_default.Text = Text_default;
Typography_default.Title = Title_default2;
Typography_default.Paragraph = Paragraph_default2;
Typography_default.Link = Link_default;
Typography_default.Base = Base_default;
Typography_default.install = function(app) {
  app.component(Typography_default.name, Typography_default);
  app.component(Typography_default.Text.displayName, Text_default);
  app.component(Typography_default.Title.displayName, Title_default2);
  app.component(Typography_default.Paragraph.displayName, Paragraph_default2);
  app.component(Typography_default.Link.displayName, Link_default);
  return app;
};
var typography_default = Typography_default;

// node_modules/ant-design-vue/es/vc-upload/request.js
function getError(option, xhr) {
  const msg = `cannot ${option.method} ${option.action} ${xhr.status}'`;
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}
function upload(option) {
  const xhr = new XMLHttpRequest();
  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      option.onProgress(e);
    };
  }
  const formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach((key) => {
      const value = option.data[key];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formData.append(`${key}[]`, item);
        });
        return;
      }
      formData.append(key, value);
    });
  }
  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }
  xhr.onerror = function error(e) {
    option.onError(e);
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }
    return option.onSuccess(getBody(xhr), xhr);
  };
  xhr.open(option.method, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.headers || {};
  if (headers["X-Requested-With"] !== null) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach((h) => {
    if (headers[h] !== null) {
      xhr.setRequestHeader(h, headers[h]);
    }
  });
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
}

// node_modules/ant-design-vue/es/vc-upload/uid.js
var now = +/* @__PURE__ */ new Date();
var index = 0;
function uid() {
  return `vc-upload-${now}-${++index}`;
}

// node_modules/ant-design-vue/es/vc-upload/attr-accept.js
var attr_accept_default = (file, acceptedFiles) => {
  if (file && acceptedFiles) {
    const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    const fileName = file.name || "";
    const mimeType = file.type || "";
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some((type) => {
      const validType = type.trim();
      if (/^\*(\/\*)?$/.test(type)) {
        return true;
      }
      if (validType.charAt(0) === ".") {
        const lowerFileName = fileName.toLowerCase();
        const lowerType = validType.toLowerCase();
        let affixList = [lowerType];
        if (lowerType === ".jpg" || lowerType === ".jpeg") {
          affixList = [".jpg", ".jpeg"];
        }
        return affixList.some((affix) => lowerFileName.endsWith(affix));
      }
      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      if (mimeType === validType) {
        return true;
      }
      if (/^\w+$/.test(validType)) {
        warning(false, `Upload takes an invalidate 'accept' type '${validType}'.Skip for check.`);
        return true;
      }
      return false;
    });
  }
  return true;
};

// node_modules/ant-design-vue/es/vc-upload/traverseFileTree.js
function loopFiles(item, callback) {
  const dirReader = item.createReader();
  let fileList = [];
  function sequence() {
    dirReader.readEntries((entries) => {
      const entryList = Array.prototype.slice.apply(entries);
      fileList = fileList.concat(entryList);
      const isFinished = !entryList.length;
      if (isFinished) {
        callback(fileList);
      } else {
        sequence();
      }
    });
  }
  sequence();
}
var traverseFileTree = (files, callback, isAccepted) => {
  const _traverseFileTree = (item, path2) => {
    item.path = path2 || "";
    if (item.isFile) {
      item.file((file) => {
        if (isAccepted(file)) {
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, "");
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }
          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      loopFiles(item, (entries) => {
        entries.forEach((entryItem) => {
          _traverseFileTree(entryItem, `${path2}${item.name}/`);
        });
      });
    }
  };
  files.forEach((file) => {
    _traverseFileTree(file.webkitGetAsEntry());
  });
};
var traverseFileTree_default = traverseFileTree;

// node_modules/ant-design-vue/es/vc-upload/interface.js
var uploadProps = () => {
  return {
    capture: [Boolean, String],
    multipart: {
      type: Boolean,
      default: void 0
    },
    name: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    componentTag: String,
    action: [String, Function],
    method: String,
    directory: {
      type: Boolean,
      default: void 0
    },
    data: [Object, Function],
    headers: Object,
    accept: String,
    multiple: {
      type: Boolean,
      default: void 0
    },
    onBatchStart: Function,
    onReject: Function,
    onStart: Function,
    onError: Function,
    onSuccess: Function,
    onProgress: Function,
    beforeUpload: Function,
    customRequest: Function,
    withCredentials: {
      type: Boolean,
      default: void 0
    },
    openFileDialogOnClick: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    id: String,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
};

// node_modules/ant-design-vue/es/vc-upload/AjaxUploader.js
var __awaiter = function(thisArg, _arguments, P, generator2) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var __rest35 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var AjaxUploader_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AjaxUploader",
  inheritAttrs: false,
  props: uploadProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const uid2 = ref(uid());
    const reqs = {};
    const fileInput = ref();
    let isMounted = false;
    const processFile = (file, fileList) => __awaiter(this, void 0, void 0, function* () {
      const {
        beforeUpload
      } = props2;
      let transformedFile = file;
      if (beforeUpload) {
        try {
          transformedFile = yield beforeUpload(file, fileList);
        } catch (e) {
          transformedFile = false;
        }
        if (transformedFile === false) {
          return {
            origin: file,
            parsedFile: null,
            action: null,
            data: null
          };
        }
      }
      const {
        action
      } = props2;
      let mergedAction;
      if (typeof action === "function") {
        mergedAction = yield action(file);
      } else {
        mergedAction = action;
      }
      const {
        data
      } = props2;
      let mergedData;
      if (typeof data === "function") {
        mergedData = yield data(file);
      } else {
        mergedData = data;
      }
      const parsedData = (
        // string type is from legacy `transformFile`.
        // Not sure if this will work since no related test case works with it
        (typeof transformedFile === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file
      );
      let parsedFile;
      if (parsedData instanceof File) {
        parsedFile = parsedData;
      } else {
        parsedFile = new File([parsedData], file.name, {
          type: file.type
        });
      }
      const mergedParsedFile = parsedFile;
      mergedParsedFile.uid = file.uid;
      return {
        origin: file,
        data: mergedData,
        parsedFile: mergedParsedFile,
        action: mergedAction
      };
    });
    const post = (_ref2) => {
      let {
        data,
        origin,
        action,
        parsedFile
      } = _ref2;
      if (!isMounted) {
        return;
      }
      const {
        onStart,
        customRequest,
        name,
        headers,
        withCredentials,
        method
      } = props2;
      const {
        uid: uid3
      } = origin;
      const request = customRequest || upload;
      const requestOption = {
        action,
        filename: name,
        data,
        file: parsedFile,
        headers,
        withCredentials,
        method: method || "post",
        onProgress: (e) => {
          const {
            onProgress
          } = props2;
          onProgress === null || onProgress === void 0 ? void 0 : onProgress(e, parsedFile);
        },
        onSuccess: (ret, xhr) => {
          const {
            onSuccess
          } = props2;
          onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(ret, parsedFile, xhr);
          delete reqs[uid3];
        },
        onError: (err, ret) => {
          const {
            onError
          } = props2;
          onError === null || onError === void 0 ? void 0 : onError(err, ret, parsedFile);
          delete reqs[uid3];
        }
      };
      onStart(origin);
      reqs[uid3] = request(requestOption);
    };
    const reset = () => {
      uid2.value = uid();
    };
    const abort = (file) => {
      if (file) {
        const uid3 = file.uid ? file.uid : file;
        if (reqs[uid3] && reqs[uid3].abort) {
          reqs[uid3].abort();
        }
        delete reqs[uid3];
      } else {
        Object.keys(reqs).forEach((uid3) => {
          if (reqs[uid3] && reqs[uid3].abort) {
            reqs[uid3].abort();
          }
          delete reqs[uid3];
        });
      }
    };
    onMounted(() => {
      isMounted = true;
    });
    onBeforeUnmount(() => {
      isMounted = false;
      abort();
    });
    const uploadFiles = (files) => {
      const originFiles = [...files];
      const postFiles = originFiles.map((file) => {
        file.uid = uid();
        return processFile(file, originFiles);
      });
      Promise.all(postFiles).then((fileList) => {
        const {
          onBatchStart
        } = props2;
        onBatchStart === null || onBatchStart === void 0 ? void 0 : onBatchStart(fileList.map((_ref3) => {
          let {
            origin,
            parsedFile
          } = _ref3;
          return {
            file: origin,
            parsedFile
          };
        }));
        fileList.filter((file) => file.parsedFile !== null).forEach((file) => {
          post(file);
        });
      });
    };
    const onChange = (e) => {
      const {
        accept,
        directory
      } = props2;
      const {
        files
      } = e.target;
      const acceptedFiles = [...files].filter((file) => !directory || attr_accept_default(file, accept));
      uploadFiles(acceptedFiles);
      reset();
    };
    const onClick = (e) => {
      const el = fileInput.value;
      if (!el) {
        return;
      }
      const {
        onClick: onClick2
      } = props2;
      el.click();
      if (onClick2) {
        onClick2(e);
      }
    };
    const onKeyDown = (e) => {
      if (e.key === "Enter") {
        onClick(e);
      }
    };
    const onFileDrop = (e) => {
      const {
        multiple
      } = props2;
      e.preventDefault();
      if (e.type === "dragover") {
        return;
      }
      if (props2.directory) {
        traverseFileTree_default(Array.prototype.slice.call(e.dataTransfer.items), uploadFiles, (_file) => attr_accept_default(_file, props2.accept));
      } else {
        const files = partition_default(Array.prototype.slice.call(e.dataTransfer.files), (file) => attr_accept_default(file, props2.accept));
        let successFiles = files[0];
        const errorFiles = files[1];
        if (multiple === false) {
          successFiles = successFiles.slice(0, 1);
        }
        uploadFiles(successFiles);
        if (errorFiles.length && props2.onReject)
          props2.onReject(errorFiles);
      }
    };
    expose({
      abort
    });
    return () => {
      var _a2;
      const {
        componentTag: Tag,
        prefixCls,
        disabled,
        id,
        multiple,
        accept,
        capture,
        directory,
        openFileDialogOnClick,
        onMouseenter,
        onMouseleave
      } = props2, otherProps = __rest35(props2, ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory", "openFileDialogOnClick", "onMouseenter", "onMouseleave"]);
      const cls = {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: disabled,
        [attrs.class]: !!attrs.class
      };
      const dirProps = directory ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      const events = disabled ? {} : {
        onClick: openFileDialogOnClick ? onClick : () => {
        },
        onKeydown: openFileDialogOnClick ? onKeyDown : () => {
        },
        onMouseenter,
        onMouseleave,
        onDrop: onFileDrop,
        onDragover: onFileDrop,
        tabindex: "0"
      };
      return createVNode(Tag, _objectSpread2(_objectSpread2({}, events), {}, {
        "class": cls,
        "role": "button",
        "style": attrs.style
      }), {
        default: () => [createVNode("input", _objectSpread2(_objectSpread2(_objectSpread2({}, pickAttrs(otherProps, {
          aria: true,
          data: true
        })), {}, {
          "id": id,
          "type": "file",
          "ref": fileInput,
          "onClick": (e) => e.stopPropagation(),
          "onCancel": (e) => e.stopPropagation(),
          "key": uid2.value,
          "style": {
            display: "none"
          },
          "accept": accept
        }, dirProps), {}, {
          "multiple": multiple,
          "onChange": onChange
        }, capture != null ? {
          capture
        } : {}), null), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
      });
    };
  }
});

// node_modules/ant-design-vue/es/vc-upload/Upload.js
function empty() {
}
var Upload_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Upload",
  inheritAttrs: false,
  props: initDefaultProps_default(uploadProps(), {
    componentTag: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: false,
    onStart: empty,
    onError: empty,
    onSuccess: empty,
    multiple: false,
    beforeUpload: null,
    customRequest: null,
    withCredentials: false,
    openFileDialogOnClick: true
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const uploader = ref();
    const abort = (file) => {
      var _a2;
      (_a2 = uploader.value) === null || _a2 === void 0 ? void 0 : _a2.abort(file);
    };
    expose({
      abort
    });
    return () => {
      return createVNode(AjaxUploader_default, _objectSpread2(_objectSpread2(_objectSpread2({}, props2), attrs), {}, {
        "ref": uploader
      }), slots);
    };
  }
});

// node_modules/ant-design-vue/es/vc-upload/index.js
var vc_upload_default = Upload_default;

// node_modules/ant-design-vue/es/upload/interface.js
function uploadProps2() {
  return {
    capture: someType([Boolean, String]),
    type: stringType(),
    name: String,
    defaultFileList: arrayType(),
    fileList: arrayType(),
    action: someType([String, Function]),
    directory: booleanType(),
    data: someType([Object, Function]),
    method: stringType(),
    headers: objectType(),
    showUploadList: someType([Boolean, Object]),
    multiple: booleanType(),
    accept: String,
    beforeUpload: functionType(),
    onChange: functionType(),
    "onUpdate:fileList": functionType(),
    onDrop: functionType(),
    listType: stringType(),
    onPreview: functionType(),
    onDownload: functionType(),
    onReject: functionType(),
    onRemove: functionType(),
    /** @deprecated Please use `onRemove` directly */
    remove: functionType(),
    supportServerRender: booleanType(),
    disabled: booleanType(),
    prefixCls: String,
    customRequest: functionType(),
    withCredentials: booleanType(),
    openFileDialogOnClick: booleanType(),
    locale: objectType(),
    id: String,
    previewFile: functionType(),
    /** @deprecated Please use `beforeUpload` directly */
    transformFile: functionType(),
    iconRender: functionType(),
    isImageUrl: functionType(),
    progress: objectType(),
    itemRender: functionType(),
    /** Config max count of `fileList`. Will replace current one when `maxCount` is 1 */
    maxCount: Number,
    height: someType([Number, String]),
    removeIcon: functionType(),
    downloadIcon: functionType(),
    previewIcon: functionType()
  };
}
function uploadListProps() {
  return {
    listType: stringType(),
    onPreview: functionType(),
    onDownload: functionType(),
    onRemove: functionType(),
    items: arrayType(),
    progress: objectType(),
    prefixCls: stringType(),
    showRemoveIcon: booleanType(),
    showDownloadIcon: booleanType(),
    showPreviewIcon: booleanType(),
    removeIcon: functionType(),
    downloadIcon: functionType(),
    previewIcon: functionType(),
    locale: objectType(void 0),
    previewFile: functionType(),
    iconRender: functionType(),
    isImageUrl: functionType(),
    appendAction: functionType(),
    appendActionVisible: booleanType(),
    itemRender: functionType()
  };
}

// node_modules/ant-design-vue/es/upload/utils.js
function file2Obj(file) {
  return _extends(_extends({}, file), {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
function updateFileList(file, fileList) {
  const nextFileList = [...fileList];
  const fileIndex = nextFileList.findIndex((_ref) => {
    let {
      uid: uid2
    } = _ref;
    return uid2 === file.uid;
  });
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
function getFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
function removeFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
var extname = function() {
  let url = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const temp = url.split("/");
  const filename = temp[temp.length - 1];
  const filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
var isImageFileType = (type) => type.indexOf("image/") === 0;
var isImageUrl = (file) => {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  const url = file.thumbUrl || file.url || "";
  const extension = extname(url);
  if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url)) {
    return false;
  }
  if (extension) {
    return false;
  }
  return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise((resolve) => {
    if (!file.type || !isImageFileType(file.type)) {
      resolve("");
      return;
    }
    const canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.onload = () => {
      const {
        width,
        height
      } = img;
      let drawWidth = MEASURE_SIZE;
      let drawHeight = MEASURE_SIZE;
      let offsetX = 0;
      let offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      const dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      resolve(dataURL);
    };
    img.crossOrigin = "anonymous";
    if (file.type.startsWith("image/svg+xml")) {
      const reader = new FileReader();
      reader.addEventListener("load", () => {
        if (reader.result)
          img.src = reader.result;
      });
      reader.readAsDataURL(file);
    } else {
      img.src = window.URL.createObjectURL(file);
    }
  });
}

// node_modules/ant-design-vue/es/upload/UploadList/ListItem.js
var listItemProps2 = () => {
  return {
    prefixCls: String,
    locale: objectType(void 0),
    file: objectType(),
    items: arrayType(),
    listType: stringType(),
    isImgUrl: functionType(),
    showRemoveIcon: booleanType(),
    showDownloadIcon: booleanType(),
    showPreviewIcon: booleanType(),
    removeIcon: functionType(),
    downloadIcon: functionType(),
    previewIcon: functionType(),
    iconRender: functionType(),
    actionIconRender: functionType(),
    itemRender: functionType(),
    onPreview: functionType(),
    onClose: functionType(),
    onDownload: functionType(),
    progress: objectType()
  };
};
var ListItem_default2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: false,
  props: listItemProps2(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    var _a2;
    const showProgress = shallowRef(false);
    const progressRafRef = shallowRef();
    onMounted(() => {
      progressRafRef.value = setTimeout(() => {
        showProgress.value = true;
      }, 300);
    });
    onBeforeUnmount(() => {
      clearTimeout(progressRafRef.value);
    });
    const mergedStatus = shallowRef((_a2 = props2.file) === null || _a2 === void 0 ? void 0 : _a2.status);
    watch(() => {
      var _a3;
      return (_a3 = props2.file) === null || _a3 === void 0 ? void 0 : _a3.status;
    }, (status) => {
      if (status !== "removed") {
        mergedStatus.value = status;
      }
    });
    const {
      rootPrefixCls
    } = useConfigInject_default("upload", props2);
    const transitionProps = computed(() => getTransitionProps(`${rootPrefixCls.value}-fade`));
    return () => {
      var _a3, _b;
      const {
        prefixCls,
        locale,
        listType,
        file,
        items,
        progress: progressProps2,
        iconRender = slots.iconRender,
        actionIconRender = slots.actionIconRender,
        itemRender = slots.itemRender,
        isImgUrl,
        showPreviewIcon,
        showRemoveIcon,
        showDownloadIcon,
        previewIcon: customPreviewIcon = slots.previewIcon,
        removeIcon: customRemoveIcon = slots.removeIcon,
        downloadIcon: customDownloadIcon = slots.downloadIcon,
        onPreview,
        onDownload,
        onClose
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const iconNode = iconRender({
        file
      });
      let icon = createVNode("div", {
        "class": `${prefixCls}-text-icon`
      }, [iconNode]);
      if (listType === "picture" || listType === "picture-card") {
        if (mergedStatus.value === "uploading" || !file.thumbUrl && !file.url) {
          const uploadingClassName = {
            [`${prefixCls}-list-item-thumbnail`]: true,
            [`${prefixCls}-list-item-file`]: mergedStatus.value !== "uploading"
          };
          icon = createVNode("div", {
            "class": uploadingClassName
          }, [iconNode]);
        } else {
          const thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? createVNode("img", {
            "src": file.thumbUrl || file.url,
            "alt": file.name,
            "class": `${prefixCls}-list-item-image`,
            "crossorigin": file.crossOrigin
          }, null) : iconNode;
          const aClassName = {
            [`${prefixCls}-list-item-thumbnail`]: true,
            [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
          };
          icon = createVNode("a", {
            "class": aClassName,
            "onClick": (e) => onPreview(file, e),
            "href": file.url || file.thumbUrl,
            "target": "_blank",
            "rel": "noopener noreferrer"
          }, [thumbnail]);
        }
      }
      const infoUploadingClass = {
        [`${prefixCls}-list-item`]: true,
        [`${prefixCls}-list-item-${mergedStatus.value}`]: true
      };
      const linkProps2 = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
      const removeIcon = showRemoveIcon ? actionIconRender({
        customIcon: customRemoveIcon ? customRemoveIcon({
          file
        }) : createVNode(DeleteOutlined_default, null, null),
        callback: () => onClose(file),
        prefixCls,
        title: locale.removeFile
      }) : null;
      const downloadIcon = showDownloadIcon && mergedStatus.value === "done" ? actionIconRender({
        customIcon: customDownloadIcon ? customDownloadIcon({
          file
        }) : createVNode(DownloadOutlined_default, null, null),
        callback: () => onDownload(file),
        prefixCls,
        title: locale.downloadFile
      }) : null;
      const downloadOrDelete = listType !== "picture-card" && createVNode("span", {
        "key": "download-delete",
        "class": [`${prefixCls}-list-item-actions`, {
          picture: listType === "picture"
        }]
      }, [downloadIcon, removeIcon]);
      const listItemNameClass = `${prefixCls}-list-item-name`;
      const fileName = file.url ? [createVNode("a", _objectSpread2(_objectSpread2({
        "key": "view",
        "target": "_blank",
        "rel": "noopener noreferrer",
        "class": listItemNameClass,
        "title": file.name
      }, linkProps2), {}, {
        "href": file.url,
        "onClick": (e) => onPreview(file, e)
      }), [file.name]), downloadOrDelete] : [createVNode("span", {
        "key": "view",
        "class": listItemNameClass,
        "onClick": (e) => onPreview(file, e),
        "title": file.name
      }, [file.name]), downloadOrDelete];
      const previewStyle = {
        pointerEvents: "none",
        opacity: 0.5
      };
      const previewIcon = showPreviewIcon ? createVNode("a", {
        "href": file.url || file.thumbUrl,
        "target": "_blank",
        "rel": "noopener noreferrer",
        "style": file.url || file.thumbUrl ? void 0 : previewStyle,
        "onClick": (e) => onPreview(file, e),
        "title": locale.previewFile
      }, [customPreviewIcon ? customPreviewIcon({
        file
      }) : createVNode(EyeOutlined_default, null, null)]) : null;
      const pictureCardActions = listType === "picture-card" && mergedStatus.value !== "uploading" && createVNode("span", {
        "class": `${prefixCls}-list-item-actions`
      }, [previewIcon, mergedStatus.value === "done" && downloadIcon, removeIcon]);
      const dom = createVNode("div", {
        "class": infoUploadingClass
      }, [icon, fileName, pictureCardActions, showProgress.value && createVNode(Transition, transitionProps.value, {
        default: () => [withDirectives(createVNode("div", {
          "class": `${prefixCls}-list-item-progress`
        }, ["percent" in file ? createVNode(progress_default2, _objectSpread2(_objectSpread2({}, progressProps2), {}, {
          "type": "line",
          "percent": file.percent
        }), null) : null]), [[vShow, mergedStatus.value === "uploading"]])]
      })]);
      const listContainerNameClass = {
        [`${prefixCls}-list-item-container`]: true,
        [`${className}`]: !!className
      };
      const message = file.response && typeof file.response === "string" ? file.response : ((_a3 = file.error) === null || _a3 === void 0 ? void 0 : _a3.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale.uploadError;
      const item = mergedStatus.value === "error" ? createVNode(tooltip_default, {
        "title": message,
        "getPopupContainer": (node) => node.parentNode
      }, {
        default: () => [dom]
      }) : dom;
      return createVNode("div", {
        "class": listContainerNameClass,
        "style": style
      }, [itemRender ? itemRender({
        originNode: item,
        file,
        fileList: items,
        actions: {
          download: onDownload.bind(null, file),
          preview: onPreview.bind(null, file),
          remove: onClose.bind(null, file)
        }
      }) : item]);
    };
  }
});

// node_modules/ant-design-vue/es/upload/UploadList/index.js
var HackSlot = (_, _ref) => {
  let {
    slots
  } = _ref;
  var _a2;
  return filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))[0];
};
var UploadList_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadList",
  props: initDefaultProps_default(uploadListProps(), {
    listType: "text",
    progress: {
      strokeWidth: 2,
      showInfo: false
    },
    showRemoveIcon: true,
    showDownloadIcon: false,
    showPreviewIcon: true,
    previewFile: previewImage,
    isImageUrl,
    items: [],
    appendActionVisible: true
  }),
  setup(props2, _ref2) {
    let {
      slots,
      expose
    } = _ref2;
    const motionAppear = shallowRef(false);
    onMounted(() => {
      motionAppear.value == true;
    });
    const mergedItems = shallowRef([]);
    watch(() => props2.items, function() {
      let val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      mergedItems.value = val.slice();
    }, {
      immediate: true,
      deep: true
    });
    watchEffect(() => {
      if (props2.listType !== "picture" && props2.listType !== "picture-card") {
        return;
      }
      let hasUpdate = false;
      (props2.items || []).forEach((file, index2) => {
        if (typeof document === "undefined" || typeof window === "undefined" || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
          return;
        }
        file.thumbUrl = "";
        if (props2.previewFile) {
          props2.previewFile(file.originFileObj).then((previewDataUrl) => {
            const thumbUrl = previewDataUrl || "";
            if (thumbUrl !== file.thumbUrl) {
              mergedItems.value[index2].thumbUrl = thumbUrl;
              hasUpdate = true;
            }
          });
        }
      });
      if (hasUpdate) {
        triggerRef(mergedItems);
      }
    });
    const onInternalPreview = (file, e) => {
      if (!props2.onPreview) {
        return;
      }
      e === null || e === void 0 ? void 0 : e.preventDefault();
      return props2.onPreview(file);
    };
    const onInternalDownload = (file) => {
      if (typeof props2.onDownload === "function") {
        props2.onDownload(file);
      } else if (file.url) {
        window.open(file.url);
      }
    };
    const onInternalClose = (file) => {
      var _a2;
      (_a2 = props2.onRemove) === null || _a2 === void 0 ? void 0 : _a2.call(props2, file);
    };
    const internalIconRender = (_ref3) => {
      let {
        file
      } = _ref3;
      const iconRender = props2.iconRender || slots.iconRender;
      if (iconRender) {
        return iconRender({
          file,
          listType: props2.listType
        });
      }
      const isLoading = file.status === "uploading";
      const fileIcon = props2.isImageUrl && props2.isImageUrl(file) ? createVNode(PictureTwoTone_default, null, null) : createVNode(FileTwoTone_default, null, null);
      let icon = isLoading ? createVNode(LoadingOutlined_default, null, null) : createVNode(PaperClipOutlined_default, null, null);
      if (props2.listType === "picture") {
        icon = isLoading ? createVNode(LoadingOutlined_default, null, null) : fileIcon;
      } else if (props2.listType === "picture-card") {
        icon = isLoading ? props2.locale.uploading : fileIcon;
      }
      return icon;
    };
    const actionIconRender = (opt) => {
      const {
        customIcon,
        callback,
        prefixCls: prefixCls2,
        title
      } = opt;
      const btnProps = {
        type: "text",
        size: "small",
        title,
        onClick: () => {
          callback();
        },
        class: `${prefixCls2}-list-item-action`
      };
      if (isValidElement(customIcon)) {
        return createVNode(button_default, btnProps, {
          icon: () => customIcon
        });
      }
      return createVNode(button_default, btnProps, {
        default: () => [createVNode("span", null, [customIcon])]
      });
    };
    expose({
      handlePreview: onInternalPreview,
      handleDownload: onInternalDownload
    });
    const {
      prefixCls,
      rootPrefixCls
    } = useConfigInject_default("upload", props2);
    const listClassNames = computed(() => ({
      [`${prefixCls.value}-list`]: true,
      [`${prefixCls.value}-list-${props2.listType}`]: true
    }));
    const transitionGroupProps = computed(() => {
      const motion = _extends({}, collapseMotion_default(`${rootPrefixCls.value}-motion-collapse`));
      delete motion.onAfterAppear;
      delete motion.onAfterEnter;
      delete motion.onAfterLeave;
      const motionConfig = _extends(_extends({}, getTransitionGroupProps(`${prefixCls.value}-${props2.listType === "picture-card" ? "animate-inline" : "animate"}`)), {
        class: listClassNames.value,
        appear: motionAppear.value
      });
      return props2.listType !== "picture-card" ? _extends(_extends({}, motion), motionConfig) : motionConfig;
    });
    return () => {
      const {
        listType,
        locale,
        isImageUrl: isImgUrl,
        showPreviewIcon,
        showRemoveIcon,
        showDownloadIcon,
        removeIcon,
        previewIcon,
        downloadIcon,
        progress,
        appendAction,
        itemRender,
        appendActionVisible
      } = props2;
      const appendActionDom = appendAction === null || appendAction === void 0 ? void 0 : appendAction();
      const items = mergedItems.value;
      return createVNode(TransitionGroup, _objectSpread2(_objectSpread2({}, transitionGroupProps.value), {}, {
        "tag": "div"
      }), {
        default: () => [items.map((file) => {
          const {
            uid: key
          } = file;
          return createVNode(ListItem_default2, {
            "key": key,
            "locale": locale,
            "prefixCls": prefixCls.value,
            "file": file,
            "items": items,
            "progress": progress,
            "listType": listType,
            "isImgUrl": isImgUrl,
            "showPreviewIcon": showPreviewIcon,
            "showRemoveIcon": showRemoveIcon,
            "showDownloadIcon": showDownloadIcon,
            "onPreview": onInternalPreview,
            "onDownload": onInternalDownload,
            "onClose": onInternalClose,
            "removeIcon": removeIcon,
            "previewIcon": previewIcon,
            "downloadIcon": downloadIcon,
            "itemRender": itemRender
          }, _extends(_extends({}, slots), {
            iconRender: internalIconRender,
            actionIconRender
          }));
        }), appendAction ? withDirectives(createVNode(HackSlot, {
          "key": "__ant_upload_appendAction"
        }, {
          default: () => appendActionDom
        }), [[vShow, !!appendActionVisible]]) : null]
      });
    };
  }
});

// node_modules/ant-design-vue/es/upload/style/dragger.js
var genDraggerStyle = (token) => {
  const {
    componentCls,
    iconCls
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: token.colorFillAlter,
        border: `${token.lineWidth}px dashed ${token.colorBorder}`,
        borderRadius: token.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token.motionDurationSlow}`,
        [componentCls]: {
          padding: `${token.padding}px 0`
        },
        [`${componentCls}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none"
        },
        [`${componentCls}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token.colorPrimaryHover
        },
        [`p${componentCls}-drag-icon`]: {
          marginBottom: token.margin,
          [iconCls]: {
            color: token.colorPrimary,
            fontSize: token.uploadThumbnailSize
          }
        },
        [`p${componentCls}-text`]: {
          margin: `0 0 ${token.marginXXS}px`,
          color: token.colorTextHeading,
          fontSize: token.fontSizeLG
        },
        [`p${componentCls}-hint`]: {
          color: token.colorTextDescription,
          fontSize: token.fontSize
        },
        // ===================== Disabled =====================
        [`&${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
            color: token.colorTextDisabled
          }
        }
      }
    }
  };
};
var dragger_default = genDraggerStyle;

// node_modules/ant-design-vue/es/upload/style/list.js
var genListStyle = (token) => {
  const {
    componentCls,
    antCls,
    iconCls,
    fontSize,
    lineHeight
  } = token;
  const itemCls = `${componentCls}-list-item`;
  const actionsCls = `${itemCls}-actions`;
  const actionCls = `${itemCls}-action`;
  const listItemHeightSM = Math.round(fontSize * lineHeight);
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-list`]: _extends(_extends({}, clearFix()), {
        lineHeight: token.lineHeight,
        [itemCls]: {
          position: "relative",
          height: token.lineHeight * fontSize,
          marginTop: token.marginXS,
          fontSize,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${token.motionDurationSlow}`,
          "&:hover": {
            backgroundColor: token.controlItemBgHover
          },
          [`${itemCls}-name`]: _extends(_extends({}, textEllipsis), {
            padding: `0 ${token.paddingXS}px`,
            lineHeight,
            flex: "auto",
            transition: `all ${token.motionDurationSlow}`
          }),
          [actionsCls]: {
            [actionCls]: {
              opacity: 0
            },
            [`${actionCls}${antCls}-btn-sm`]: {
              height: listItemHeightSM,
              border: 0,
              lineHeight: 1,
              // FIXME: should not override small button
              "> span": {
                transform: "scale(1)"
              }
            },
            [`
              ${actionCls}:focus,
              &.picture ${actionCls}
            `]: {
              opacity: 1
            },
            [iconCls]: {
              color: token.colorTextDescription,
              transition: `all ${token.motionDurationSlow}`
            },
            [`&:hover ${iconCls}`]: {
              color: token.colorText
            }
          },
          [`${componentCls}-icon ${iconCls}`]: {
            color: token.colorTextDescription,
            fontSize
          },
          [`${itemCls}-progress`]: {
            position: "absolute",
            bottom: -token.uploadProgressOffset,
            width: "100%",
            paddingInlineStart: fontSize + token.paddingXS,
            fontSize,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${itemCls}:hover ${actionCls}`]: {
          opacity: 1,
          color: token.colorText
        },
        [`${itemCls}-error`]: {
          color: token.colorError,
          [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
            color: token.colorError
          },
          [actionsCls]: {
            [`${iconCls}, ${iconCls}:hover`]: {
              color: token.colorError
            },
            [actionCls]: {
              opacity: 1
            }
          }
        },
        [`${componentCls}-list-item-container`]: {
          transition: `opacity ${token.motionDurationSlow}, height ${token.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      })
    }
  };
};
var list_default3 = genListStyle;

// node_modules/ant-design-vue/es/upload/style/motion.js
var uploadAnimateInlineIn = new Keyframes_default("uploadAnimateInlineIn", {
  from: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
});
var uploadAnimateInlineOut = new Keyframes_default("uploadAnimateInlineOut", {
  to: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
});
var genMotionStyle3 = (token) => {
  const {
    componentCls
  } = token;
  const inlineCls = `${componentCls}-animate-inline`;
  return [{
    [`${componentCls}-wrapper`]: {
      [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
        animationDuration: token.motionDurationSlow,
        animationTimingFunction: token.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${inlineCls}-appear, ${inlineCls}-enter`]: {
        animationName: uploadAnimateInlineIn
      },
      [`${inlineCls}-leave`]: {
        animationName: uploadAnimateInlineOut
      }
    }
  }, uploadAnimateInlineIn, uploadAnimateInlineOut];
};
var motion_default3 = genMotionStyle3;

// node_modules/ant-design-vue/es/upload/style/picture.js
var genPictureStyle = (token) => {
  const {
    componentCls,
    iconCls,
    uploadThumbnailSize,
    uploadProgressOffset
  } = token;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  return {
    [`${componentCls}-wrapper`]: {
      // ${listCls} 增加优先级
      [`${listCls}${listCls}-picture, ${listCls}${listCls}-picture-card`]: {
        [itemCls]: {
          position: "relative",
          height: uploadThumbnailSize + token.lineWidth * 2 + token.paddingXS * 2,
          padding: token.paddingXS,
          border: `${token.lineWidth}px ${token.lineType} ${token.colorBorder}`,
          borderRadius: token.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${itemCls}-thumbnail`]: _extends(_extends({}, textEllipsis), {
            width: uploadThumbnailSize,
            height: uploadThumbnailSize,
            lineHeight: `${uploadThumbnailSize + token.paddingSM}px`,
            textAlign: "center",
            flex: "none",
            [iconCls]: {
              fontSize: token.fontSizeHeading2,
              color: token.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          }),
          [`${itemCls}-progress`]: {
            bottom: uploadProgressOffset,
            width: `calc(100% - ${token.paddingSM * 2}px)`,
            marginTop: 0,
            paddingInlineStart: uploadThumbnailSize + token.paddingXS
          }
        },
        [`${itemCls}-error`]: {
          borderColor: token.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${itemCls}-thumbnail ${iconCls}`]: {
            [`svg path[fill='#e6f7ff']`]: {
              fill: token.colorErrorBg
            },
            [`svg path[fill='#1890ff']`]: {
              fill: token.colorError
            }
          }
        },
        [`${itemCls}-uploading`]: {
          borderStyle: "dashed",
          [`${itemCls}-name`]: {
            marginBottom: uploadProgressOffset
          }
        }
      }
    }
  };
};
var genPictureCardStyle = (token) => {
  const {
    componentCls,
    iconCls,
    fontSizeLG,
    colorTextLightSolid
  } = token;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  const uploadPictureCardSize = token.uploadPicCardSize;
  return {
    [`${componentCls}-wrapper${componentCls}-picture-card-wrapper`]: _extends(_extends({}, clearFix()), {
      display: "inline-block",
      width: "100%",
      [`${componentCls}${componentCls}-select`]: {
        width: uploadPictureCardSize,
        height: uploadPictureCardSize,
        marginInlineEnd: token.marginXS,
        marginBottom: token.marginXS,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: token.colorFillAlter,
        border: `${token.lineWidth}px dashed ${token.colorBorder}`,
        borderRadius: token.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token.motionDurationSlow}`,
        [`> ${componentCls}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token.colorPrimary
        }
      },
      // list
      [`${listCls}${listCls}-picture-card`]: {
        [`${listCls}-item-container`]: {
          display: "inline-block",
          width: uploadPictureCardSize,
          height: uploadPictureCardSize,
          marginBlock: `0 ${token.marginXS}px`,
          marginInline: `0 ${token.marginXS}px`,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        [itemCls]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${token.paddingXS * 2}px)`,
            height: `calc(100% - ${token.paddingXS * 2}px)`,
            backgroundColor: token.colorBgMask,
            opacity: 0,
            transition: `all ${token.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${itemCls}:hover`]: {
          [`&::before, ${itemCls}-actions`]: {
            opacity: 1
          }
        },
        [`${itemCls}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${token.motionDurationSlow}`,
          [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            zIndex: 10,
            width: fontSizeLG,
            margin: `0 ${token.marginXXS}px`,
            fontSize: fontSizeLG,
            cursor: "pointer",
            transition: `all ${token.motionDurationSlow}`
          }
        },
        [`${itemCls}-actions, ${itemCls}-actions:hover`]: {
          [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            color: new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString(),
            "&:hover": {
              color: colorTextLightSolid
            }
          }
        },
        [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${itemCls}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${itemCls}-file + ${itemCls}-name`]: {
          position: "absolute",
          bottom: token.margin,
          display: "block",
          width: `calc(100% - ${token.paddingXS * 2}px)`
        },
        [`${itemCls}-uploading`]: {
          [`&${itemCls}`]: {
            backgroundColor: token.colorFillAlter
          },
          [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            display: "none"
          }
        },
        [`${itemCls}-progress`]: {
          bottom: token.marginXL,
          width: `calc(100% - ${token.paddingXS * 2}px)`,
          paddingInlineStart: 0
        }
      }
    })
  };
};

// node_modules/ant-design-vue/es/upload/style/rtl.js
var genRtlStyle2 = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var rtl_default2 = genRtlStyle2;

// node_modules/ant-design-vue/es/upload/style/index.js
var genBaseStyle12 = (token) => {
  const {
    componentCls,
    colorTextDisabled
  } = token;
  return {
    [`${componentCls}-wrapper`]: _extends(_extends({}, resetComponent(token)), {
      [componentCls]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${componentCls}-select`]: {
        display: "inline-block"
      },
      [`${componentCls}-disabled`]: {
        color: colorTextDisabled,
        cursor: "not-allowed"
      }
    })
  };
};
var style_default36 = genComponentStyleHook("Upload", (token) => {
  const {
    fontSizeHeading3,
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightLG
  } = token;
  const listItemHeightSM = Math.round(fontSize * lineHeight);
  const uploadToken = merge(token, {
    uploadThumbnailSize: fontSizeHeading3 * 2,
    uploadProgressOffset: listItemHeightSM / 2 + lineWidth,
    uploadPicCardSize: controlHeightLG * 2.55
  });
  return [genBaseStyle12(uploadToken), dragger_default(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), list_default3(uploadToken), motion_default3(uploadToken), rtl_default2(uploadToken), collapse_default(uploadToken)];
});

// node_modules/ant-design-vue/es/upload/Upload.js
var __awaiter2 = function(thisArg, _arguments, P, generator2) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var __rest36 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
var Upload_default2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUpload",
  inheritAttrs: false,
  props: initDefaultProps_default(uploadProps2(), {
    type: "select",
    multiple: false,
    action: "",
    data: {},
    accept: "",
    showUploadList: true,
    listType: "text",
    supportServerRender: true
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const {
      prefixCls,
      direction,
      disabled
    } = useConfigInject_default("upload", props2);
    const [wrapSSR, hashId] = style_default36(prefixCls);
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    const [mergedFileList, setMergedFileList] = useMergedState(props2.defaultFileList || [], {
      value: toRef(props2, "fileList"),
      postState: (list) => {
        const timestamp = Date.now();
        return (list !== null && list !== void 0 ? list : []).map((file, index2) => {
          if (!file.uid && !Object.isFrozen(file)) {
            file.uid = `__AUTO__${timestamp}_${index2}__`;
          }
          return file;
        });
      }
    });
    const dragState = ref("drop");
    const upload2 = ref(null);
    onMounted(() => {
      devWarning_default(props2.fileList !== void 0 || attrs.value === void 0, "Upload", "`value` is not a valid prop, do you mean `fileList`?");
      devWarning_default(props2.transformFile === void 0, "Upload", "`transformFile` is deprecated. Please use `beforeUpload` directly.");
      devWarning_default(props2.remove === void 0, "Upload", "`remove` props is deprecated. Please use `remove` event.");
    });
    const onInternalChange = (file, changedFileList, event) => {
      var _a2, _b;
      let cloneList = [...changedFileList];
      if (props2.maxCount === 1) {
        cloneList = cloneList.slice(-1);
      } else if (props2.maxCount) {
        cloneList = cloneList.slice(0, props2.maxCount);
      }
      setMergedFileList(cloneList);
      const changeInfo = {
        file,
        fileList: cloneList
      };
      if (event) {
        changeInfo.event = event;
      }
      (_a2 = props2["onUpdate:fileList"]) === null || _a2 === void 0 ? void 0 : _a2.call(props2, changeInfo.fileList);
      (_b = props2.onChange) === null || _b === void 0 ? void 0 : _b.call(props2, changeInfo);
      formItemContext.onFieldChange();
    };
    const mergedBeforeUpload = (file, fileListArgs) => __awaiter2(this, void 0, void 0, function* () {
      const {
        beforeUpload,
        transformFile
      } = props2;
      let parsedFile = file;
      if (beforeUpload) {
        const result = yield beforeUpload(file, fileListArgs);
        if (result === false) {
          return false;
        }
        delete file[LIST_IGNORE];
        if (result === LIST_IGNORE) {
          Object.defineProperty(file, LIST_IGNORE, {
            value: true,
            configurable: true
          });
          return false;
        }
        if (typeof result === "object" && result) {
          parsedFile = result;
        }
      }
      if (transformFile) {
        parsedFile = yield transformFile(parsedFile);
      }
      return parsedFile;
    });
    const onBatchStart = (batchFileInfoList) => {
      const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
      if (!filteredFileInfoList.length) {
        return;
      }
      const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
      let newFileList = [...mergedFileList.value];
      objectFileList.forEach((fileObj) => {
        newFileList = updateFileList(fileObj, newFileList);
      });
      objectFileList.forEach((fileObj, index2) => {
        let triggerFileObj = fileObj;
        if (!filteredFileInfoList[index2].parsedFile) {
          const {
            originFileObj
          } = fileObj;
          let clone;
          try {
            clone = new File([originFileObj], originFileObj.name, {
              type: originFileObj.type
            });
          } catch (e) {
            clone = new Blob([originFileObj], {
              type: originFileObj.type
            });
            clone.name = originFileObj.name;
            clone.lastModifiedDate = /* @__PURE__ */ new Date();
            clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
          }
          clone.uid = fileObj.uid;
          triggerFileObj = clone;
        } else {
          fileObj.status = "uploading";
        }
        onInternalChange(triggerFileObj, newFileList);
      });
    };
    const onSuccess = (response, file, xhr) => {
      try {
        if (typeof response === "string") {
          response = JSON.parse(response);
        }
      } catch (e) {
      }
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.status = "done";
      targetItem.percent = 100;
      targetItem.response = response;
      targetItem.xhr = xhr;
      const nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    const onProgress = (e, file) => {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.status = "uploading";
      targetItem.percent = e.percent;
      const nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList, e);
    };
    const onError = (error, response, file) => {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.error = error;
      targetItem.response = response;
      targetItem.status = "error";
      const nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    const handleRemove = (file) => {
      let currentFile;
      const mergedRemove = props2.onRemove || props2.remove;
      Promise.resolve(typeof mergedRemove === "function" ? mergedRemove(file) : mergedRemove).then((ret) => {
        var _a2, _b;
        if (ret === false) {
          return;
        }
        const removedFileList = removeFileItem(file, mergedFileList.value);
        if (removedFileList) {
          currentFile = _extends(_extends({}, file), {
            status: "removed"
          });
          (_a2 = mergedFileList.value) === null || _a2 === void 0 ? void 0 : _a2.forEach((item) => {
            const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
            if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
              item.status = "removed";
            }
          });
          (_b = upload2.value) === null || _b === void 0 ? void 0 : _b.abort(currentFile);
          onInternalChange(currentFile, removedFileList);
        }
      });
    };
    const onFileDrop = (e) => {
      var _a2;
      dragState.value = e.type;
      if (e.type === "drop") {
        (_a2 = props2.onDrop) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
      }
    };
    expose({
      onBatchStart,
      onSuccess,
      onProgress,
      onError,
      fileList: mergedFileList,
      upload: upload2
    });
    const [locale] = useLocaleReceiver("Upload", en_US_default3.Upload, computed(() => props2.locale));
    const renderUploadList = (button, buttonVisible) => {
      const {
        removeIcon,
        previewIcon,
        downloadIcon,
        previewFile,
        onPreview,
        onDownload,
        isImageUrl: isImageUrl2,
        progress,
        itemRender,
        iconRender,
        showUploadList
      } = props2;
      const {
        showDownloadIcon,
        showPreviewIcon,
        showRemoveIcon
      } = typeof showUploadList === "boolean" ? {} : showUploadList;
      return showUploadList ? createVNode(UploadList_default, {
        "prefixCls": prefixCls.value,
        "listType": props2.listType,
        "items": mergedFileList.value,
        "previewFile": previewFile,
        "onPreview": onPreview,
        "onDownload": onDownload,
        "onRemove": handleRemove,
        "showRemoveIcon": !mergedDisabled.value && showRemoveIcon,
        "showPreviewIcon": showPreviewIcon,
        "showDownloadIcon": showDownloadIcon,
        "removeIcon": removeIcon,
        "previewIcon": previewIcon,
        "downloadIcon": downloadIcon,
        "iconRender": iconRender,
        "locale": locale.value,
        "isImageUrl": isImageUrl2,
        "progress": progress,
        "itemRender": itemRender,
        "appendActionVisible": buttonVisible,
        "appendAction": button
      }, _extends({}, slots)) : button === null || button === void 0 ? void 0 : button();
    };
    return () => {
      var _a2, _b, _c;
      const {
        listType,
        type
      } = props2;
      const {
        class: className,
        style: styleName
      } = attrs, transAttrs = __rest36(attrs, ["class", "style"]);
      const rcUploadProps = _extends(_extends(_extends({
        onBatchStart,
        onError,
        onProgress,
        onSuccess
      }, transAttrs), props2), {
        id: (_a2 = props2.id) !== null && _a2 !== void 0 ? _a2 : formItemContext.id.value,
        prefixCls: prefixCls.value,
        beforeUpload: mergedBeforeUpload,
        onChange: void 0,
        disabled: mergedDisabled.value
      });
      delete rcUploadProps.remove;
      if (!slots.default || mergedDisabled.value) {
        delete rcUploadProps.id;
      }
      const rtlCls = {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      };
      if (type === "drag") {
        const dragCls = classNames_default(prefixCls.value, {
          [`${prefixCls.value}-drag`]: true,
          [`${prefixCls.value}-drag-uploading`]: mergedFileList.value.some((file) => file.status === "uploading"),
          [`${prefixCls.value}-drag-hover`]: dragState.value === "dragover",
          [`${prefixCls.value}-disabled`]: mergedDisabled.value,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value);
        return wrapSSR(createVNode("span", _objectSpread2(_objectSpread2({}, attrs), {}, {
          "class": classNames_default(`${prefixCls.value}-wrapper`, rtlCls, className, hashId.value)
        }), [createVNode("div", {
          "class": dragCls,
          "onDrop": onFileDrop,
          "onDragover": onFileDrop,
          "onDragleave": onFileDrop,
          "style": attrs.style
        }, [createVNode(vc_upload_default, _objectSpread2(_objectSpread2({}, rcUploadProps), {}, {
          "ref": upload2,
          "class": `${prefixCls.value}-btn`
        }), _objectSpread2({
          default: () => [createVNode("div", {
            "class": `${prefixCls.value}-drag-container`
          }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)])]
        }, slots))]), renderUploadList()]));
      }
      const uploadButtonCls = classNames_default(prefixCls.value, {
        [`${prefixCls.value}-select`]: true,
        [`${prefixCls.value}-select-${listType}`]: true,
        [`${prefixCls.value}-disabled`]: mergedDisabled.value,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      });
      const children = flattenChildren((_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots));
      const renderUploadButton = (uploadButtonStyle) => createVNode("div", {
        "class": uploadButtonCls,
        "style": uploadButtonStyle
      }, [createVNode(vc_upload_default, _objectSpread2(_objectSpread2({}, rcUploadProps), {}, {
        "ref": upload2
      }), slots)]);
      if (listType === "picture-card") {
        return wrapSSR(createVNode("span", _objectSpread2(_objectSpread2({}, attrs), {}, {
          "class": classNames_default(`${prefixCls.value}-wrapper`, `${prefixCls.value}-picture-card-wrapper`, rtlCls, attrs.class, hashId.value)
        }), [renderUploadList(renderUploadButton, !!(children && children.length))]));
      }
      return wrapSSR(createVNode("span", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": classNames_default(`${prefixCls.value}-wrapper`, rtlCls, attrs.class, hashId.value)
      }), [renderUploadButton(children && children.length ? void 0 : {
        display: "none"
      }), renderUploadList()]));
    };
  }
});

// node_modules/ant-design-vue/es/upload/Dragger.js
var __rest37 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Dragger_default = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadDragger",
  inheritAttrs: false,
  props: uploadProps2(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    return () => {
      const {
        height
      } = props2, restProps = __rest37(props2, ["height"]);
      const {
        style
      } = attrs, restAttrs = __rest37(attrs, ["style"]);
      const draggerProps = _extends(_extends(_extends({}, restProps), restAttrs), {
        type: "drag",
        style: _extends(_extends({}, style), {
          height: typeof height === "number" ? `${height}px` : height
        })
      });
      return createVNode(Upload_default2, draggerProps, slots);
    };
  }
});

// node_modules/ant-design-vue/es/upload/index.js
var UploadDragger = Dragger_default;
var upload_default = _extends(Upload_default2, {
  Dragger: Dragger_default,
  LIST_IGNORE,
  install(app) {
    app.component(Upload_default2.name, Upload_default2);
    app.component(Dragger_default.name, Dragger_default);
    return app;
  }
});

// node_modules/ant-design-vue/es/watermark/utils.js
function toLowercaseSeparator(key) {
  return key.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function getStyleStr(style) {
  return Object.keys(style).map((key) => `${toLowercaseSeparator(key)}: ${style[key]};`).join(" ");
}
function getPixelRatio() {
  return window.devicePixelRatio || 1;
}
function rotateWatermark(ctx, rotateX, rotateY, rotate) {
  ctx.translate(rotateX, rotateY);
  ctx.rotate(Math.PI / 180 * Number(rotate));
  ctx.translate(-rotateX, -rotateY);
}
var reRendering = (mutation, watermarkElement) => {
  let flag = false;
  if (mutation.removedNodes.length) {
    flag = Array.from(mutation.removedNodes).some((node) => node === watermarkElement);
  }
  if (mutation.type === "attributes" && mutation.target === watermarkElement) {
    flag = true;
  }
  return flag;
};

// node_modules/ant-design-vue/es/_util/hooks/_vueuse/useMutationObserver.js
var __rest38 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function useMutationObserver(target, callback) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: window2 = defaultWindow
  } = options, mutationOptions = __rest38(options, ["window"]);
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported.value && window2 && el) {
      observer = new MutationObserver(callback);
      observer.observe(el, mutationOptions);
    }
  }, {
    immediate: true
  });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}

// node_modules/ant-design-vue/es/watermark/index.js
var BaseSize = 2;
var FontGap = 3;
var watermarkProps = () => ({
  zIndex: Number,
  rotate: Number,
  width: Number,
  height: Number,
  image: String,
  content: someType([String, Array]),
  font: objectType(),
  rootClassName: String,
  gap: arrayType(),
  offset: arrayType()
});
var Watermark = defineComponent({
  name: "AWatermark",
  inheritAttrs: false,
  props: initDefaultProps_default(watermarkProps(), {
    zIndex: 9,
    rotate: -22,
    font: {},
    gap: [100, 100]
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const [, token] = useToken();
    const containerRef = shallowRef();
    const watermarkRef = shallowRef();
    const stopObservation = shallowRef(false);
    const gapX = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.gap) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : 100;
    });
    const gapY = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.gap) === null || _a2 === void 0 ? void 0 : _a2[1]) !== null && _b !== void 0 ? _b : 100;
    });
    const gapXCenter = computed(() => gapX.value / 2);
    const gapYCenter = computed(() => gapY.value / 2);
    const offsetLeft = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.offset) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : gapXCenter.value;
    });
    const offsetTop = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.offset) === null || _a2 === void 0 ? void 0 : _a2[1]) !== null && _b !== void 0 ? _b : gapYCenter.value;
    });
    const fontSize = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.font) === null || _a2 === void 0 ? void 0 : _a2.fontSize) !== null && _b !== void 0 ? _b : token.value.fontSizeLG;
    });
    const fontWeight = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.font) === null || _a2 === void 0 ? void 0 : _a2.fontWeight) !== null && _b !== void 0 ? _b : "normal";
    });
    const fontStyle = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.font) === null || _a2 === void 0 ? void 0 : _a2.fontStyle) !== null && _b !== void 0 ? _b : "normal";
    });
    const fontFamily = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.font) === null || _a2 === void 0 ? void 0 : _a2.fontFamily) !== null && _b !== void 0 ? _b : "sans-serif";
    });
    const color = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props2.font) === null || _a2 === void 0 ? void 0 : _a2.color) !== null && _b !== void 0 ? _b : token.value.colorFill;
    });
    const markStyle = computed(() => {
      var _a2;
      const markStyle2 = {
        zIndex: (_a2 = props2.zIndex) !== null && _a2 !== void 0 ? _a2 : 9,
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        backgroundRepeat: "repeat"
      };
      let positionLeft = offsetLeft.value - gapXCenter.value;
      let positionTop = offsetTop.value - gapYCenter.value;
      if (positionLeft > 0) {
        markStyle2.left = `${positionLeft}px`;
        markStyle2.width = `calc(100% - ${positionLeft}px)`;
        positionLeft = 0;
      }
      if (positionTop > 0) {
        markStyle2.top = `${positionTop}px`;
        markStyle2.height = `calc(100% - ${positionTop}px)`;
        positionTop = 0;
      }
      markStyle2.backgroundPosition = `${positionLeft}px ${positionTop}px`;
      return markStyle2;
    });
    const destroyWatermark = () => {
      if (watermarkRef.value) {
        watermarkRef.value.remove();
        watermarkRef.value = void 0;
      }
    };
    const appendWatermark = (base64Url, markWidth) => {
      var _a2;
      if (containerRef.value && watermarkRef.value) {
        stopObservation.value = true;
        watermarkRef.value.setAttribute("style", getStyleStr(_extends(_extends({}, markStyle.value), {
          backgroundImage: `url('${base64Url}')`,
          backgroundSize: `${(gapX.value + markWidth) * BaseSize}px`
        })));
        (_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.append(watermarkRef.value);
        setTimeout(() => {
          stopObservation.value = false;
        });
      }
    };
    const getMarkSize = (ctx) => {
      let defaultWidth = 120;
      let defaultHeight = 64;
      const content = props2.content;
      const image = props2.image;
      const width = props2.width;
      const height = props2.height;
      if (!image && ctx.measureText) {
        ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;
        const contents = Array.isArray(content) ? content : [content];
        const widths = contents.map((item) => ctx.measureText(item).width);
        defaultWidth = Math.ceil(Math.max(...widths));
        defaultHeight = Number(fontSize.value) * contents.length + (contents.length - 1) * FontGap;
      }
      return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];
    };
    const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {
      const ratio = getPixelRatio();
      const content = props2.content;
      const mergedFontSize = Number(fontSize.value) * ratio;
      ctx.font = `${fontStyle.value} normal ${fontWeight.value} ${mergedFontSize}px/${drawHeight}px ${fontFamily.value}`;
      ctx.fillStyle = color.value;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.translate(drawWidth / 2, 0);
      const contents = Array.isArray(content) ? content : [content];
      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index2) => {
        ctx.fillText(item !== null && item !== void 0 ? item : "", drawX, drawY + index2 * (mergedFontSize + FontGap * ratio));
      });
    };
    const renderWatermark = () => {
      var _a2;
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const image = props2.image;
      const rotate = (_a2 = props2.rotate) !== null && _a2 !== void 0 ? _a2 : -22;
      if (ctx) {
        if (!watermarkRef.value) {
          watermarkRef.value = document.createElement("div");
        }
        const ratio = getPixelRatio();
        const [markWidth, markHeight] = getMarkSize(ctx);
        const canvasWidth = (gapX.value + markWidth) * ratio;
        const canvasHeight = (gapY.value + markHeight) * ratio;
        canvas.setAttribute("width", `${canvasWidth * BaseSize}px`);
        canvas.setAttribute("height", `${canvasHeight * BaseSize}px`);
        const drawX = gapX.value * ratio / 2;
        const drawY = gapY.value * ratio / 2;
        const drawWidth = markWidth * ratio;
        const drawHeight = markHeight * ratio;
        const rotateX = (drawWidth + gapX.value * ratio) / 2;
        const rotateY = (drawHeight + gapY.value * ratio) / 2;
        const alternateDrawX = drawX + canvasWidth;
        const alternateDrawY = drawY + canvasHeight;
        const alternateRotateX = rotateX + canvasWidth;
        const alternateRotateY = rotateY + canvasHeight;
        ctx.save();
        rotateWatermark(ctx, rotateX, rotateY, rotate);
        if (image) {
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            ctx.restore();
            rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);
            ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);
            appendWatermark(canvas.toDataURL(), markWidth);
          };
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";
          img.src = image;
        } else {
          fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);
          ctx.restore();
          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);
          fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);
          appendWatermark(canvas.toDataURL(), markWidth);
        }
      }
    };
    onMounted(() => {
      renderWatermark();
    });
    watch(() => [props2, token.value.colorFill, token.value.fontSizeLG], () => {
      renderWatermark();
    }, {
      deep: true,
      flush: "post"
    });
    onBeforeUnmount(() => {
      destroyWatermark();
    });
    const onMutate = (mutations) => {
      if (stopObservation.value) {
        return;
      }
      mutations.forEach((mutation) => {
        if (reRendering(mutation, watermarkRef.value)) {
          destroyWatermark();
          renderWatermark();
        }
      });
    };
    useMutationObserver(containerRef, onMutate, {
      attributes: true,
      subtree: true,
      childList: true,
      attributeFilter: ["style", "class"]
    });
    return () => {
      var _a2;
      return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "ref": containerRef,
        "class": [attrs.class, props2.rootClassName],
        "style": [{
          position: "relative"
        }, attrs.style]
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
var watermark_default = withInstall(Watermark);

// node_modules/ant-design-vue/es/segmented/style/index.js
function getItemDisabledStyle(cls, token) {
  return {
    [`${cls}, ${cls}:hover, ${cls}:focus`]: {
      color: token.colorTextDisabled,
      cursor: "not-allowed"
    }
  };
}
function getItemSelectedStyle(token) {
  return {
    backgroundColor: token.bgColorSelected,
    boxShadow: token.boxShadow
  };
}
var segmentedTextEllipsisCss = _extends({
  overflow: "hidden"
}, textEllipsis);
var genSegmentedStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: _extends(_extends(_extends(_extends(_extends({}, resetComponent(token)), {
      display: "inline-block",
      padding: token.segmentedContainerPadding,
      color: token.labelColor,
      backgroundColor: token.bgColor,
      borderRadius: token.borderRadius,
      transition: `all ${token.motionDurationMid} ${token.motionEaseInOut}`,
      [`${componentCls}-group`]: {
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        justifyItems: "flex-start",
        width: "100%"
      },
      // RTL styles
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      // block styles
      [`&${componentCls}-block`]: {
        display: "flex"
      },
      [`&${componentCls}-block ${componentCls}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${componentCls}-item`]: {
        position: "relative",
        textAlign: "center",
        cursor: "pointer",
        transition: `color ${token.motionDurationMid} ${token.motionEaseInOut}`,
        borderRadius: token.borderRadiusSM,
        "&-selected": _extends(_extends({}, getItemSelectedStyle(token)), {
          color: token.labelColorHover
        }),
        "&::after": {
          content: '""',
          position: "absolute",
          width: "100%",
          height: "100%",
          top: 0,
          insetInlineStart: 0,
          borderRadius: "inherit",
          transition: `background-color ${token.motionDurationMid}`,
          pointerEvents: "none"
        },
        [`&:hover:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          color: token.labelColorHover,
          "&::after": {
            backgroundColor: token.bgColorHover
          }
        },
        "&-label": _extends({
          minHeight: token.controlHeight - token.segmentedContainerPadding * 2,
          lineHeight: `${token.controlHeight - token.segmentedContainerPadding * 2}px`,
          padding: `0 ${token.segmentedPaddingHorizontal}px`
        }, segmentedTextEllipsisCss),
        // syntactic sugar to add `icon` for Segmented Item
        "&-icon + *": {
          marginInlineStart: token.marginSM / 2
        },
        "&-input": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        }
      },
      // thumb styles
      [`${componentCls}-thumb`]: _extends(_extends({}, getItemSelectedStyle(token)), {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: "100%",
        padding: `${token.paddingXXS}px 0`,
        borderRadius: token.borderRadiusSM,
        [`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: {
          backgroundColor: "transparent"
        }
      }),
      // size styles
      [`&${componentCls}-lg`]: {
        borderRadius: token.borderRadiusLG,
        [`${componentCls}-item-label`]: {
          minHeight: token.controlHeightLG - token.segmentedContainerPadding * 2,
          lineHeight: `${token.controlHeightLG - token.segmentedContainerPadding * 2}px`,
          padding: `0 ${token.segmentedPaddingHorizontal}px`,
          fontSize: token.fontSizeLG
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token.borderRadius
        }
      },
      [`&${componentCls}-sm`]: {
        borderRadius: token.borderRadiusSM,
        [`${componentCls}-item-label`]: {
          minHeight: token.controlHeightSM - token.segmentedContainerPadding * 2,
          lineHeight: `${token.controlHeightSM - token.segmentedContainerPadding * 2}px`,
          padding: `0 ${token.segmentedPaddingHorizontalSM}px`
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token.borderRadiusXS
        }
      }
    }), getItemDisabledStyle(`&-disabled ${componentCls}-item`, token)), getItemDisabledStyle(`${componentCls}-item-disabled`, token)), {
      // transition effect when `appear-active`
      [`${componentCls}-thumb-motion-appear-active`]: {
        transition: `transform ${token.motionDurationSlow} ${token.motionEaseInOut}, width ${token.motionDurationSlow} ${token.motionEaseInOut}`,
        willChange: "transform, width"
      }
    })
  };
};
var style_default37 = genComponentStyleHook("Segmented", (token) => {
  const {
    lineWidthBold,
    lineWidth,
    colorTextLabel,
    colorText,
    colorFillSecondary,
    colorBgLayout,
    colorBgElevated
  } = token;
  const segmentedToken = merge(token, {
    segmentedPaddingHorizontal: token.controlPaddingHorizontal - lineWidth,
    segmentedPaddingHorizontalSM: token.controlPaddingHorizontalSM - lineWidth,
    segmentedContainerPadding: lineWidthBold,
    labelColor: colorTextLabel,
    labelColorHover: colorText,
    bgColor: colorBgLayout,
    bgColorHover: colorFillSecondary,
    bgColorSelected: colorBgElevated
  });
  return [genSegmentedStyle(segmentedToken)];
});

// node_modules/ant-design-vue/es/segmented/src/MotionThumb.js
var calcThumbStyle = (targetElement) => targetElement ? {
  left: targetElement.offsetLeft,
  right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
  width: targetElement.clientWidth
} : null;
var toPX = (value) => value !== void 0 ? `${value}px` : void 0;
var MotionThumb = defineComponent({
  props: {
    value: anyType(),
    getValueIndex: anyType(),
    prefixCls: anyType(),
    motionName: anyType(),
    onMotionStart: anyType(),
    onMotionEnd: anyType(),
    direction: anyType(),
    containerRef: anyType()
  },
  emits: ["motionStart", "motionEnd"],
  setup(props2, _ref) {
    let {
      emit
    } = _ref;
    const thumbRef = ref();
    const findValueElement = (val) => {
      var _a2;
      const index2 = props2.getValueIndex(val);
      const ele = (_a2 = props2.containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll(`.${props2.prefixCls}-item`)[index2];
      return (ele === null || ele === void 0 ? void 0 : ele.offsetParent) && ele;
    };
    const prevStyle = ref(null);
    const nextStyle = ref(null);
    watch(() => props2.value, (value, prevValue) => {
      const prev = findValueElement(prevValue);
      const next = findValueElement(value);
      const calcPrevStyle = calcThumbStyle(prev);
      const calcNextStyle = calcThumbStyle(next);
      prevStyle.value = calcPrevStyle;
      nextStyle.value = calcNextStyle;
      if (prev && next) {
        emit("motionStart");
      } else {
        emit("motionEnd");
      }
    }, {
      flush: "post"
    });
    const thumbStart = computed(() => {
      var _a2, _b;
      return props2.direction === "rtl" ? toPX(-((_a2 = prevStyle.value) === null || _a2 === void 0 ? void 0 : _a2.right)) : toPX((_b = prevStyle.value) === null || _b === void 0 ? void 0 : _b.left);
    });
    const thumbActive = computed(() => {
      var _a2, _b;
      return props2.direction === "rtl" ? toPX(-((_a2 = nextStyle.value) === null || _a2 === void 0 ? void 0 : _a2.right)) : toPX((_b = nextStyle.value) === null || _b === void 0 ? void 0 : _b.left);
    });
    let timeid;
    const onAppearStart = (el) => {
      clearTimeout(timeid);
      nextTick(() => {
        if (el) {
          el.style.transform = `translateX(var(--thumb-start-left))`;
          el.style.width = `var(--thumb-start-width)`;
        }
      });
    };
    const onAppearActive = (el) => {
      timeid = setTimeout(() => {
        if (el) {
          addClass(el, `${props2.motionName}-appear-active`);
          el.style.transform = `translateX(var(--thumb-active-left))`;
          el.style.width = `var(--thumb-active-width)`;
        }
      });
    };
    const onAppearEnd = (el) => {
      prevStyle.value = null;
      nextStyle.value = null;
      if (el) {
        el.style.transform = null;
        el.style.width = null;
        removeClass(el, `${props2.motionName}-appear-active`);
      }
      emit("motionEnd");
    };
    const mergedStyle = computed(() => {
      var _a2, _b;
      return {
        "--thumb-start-left": thumbStart.value,
        "--thumb-start-width": toPX((_a2 = prevStyle.value) === null || _a2 === void 0 ? void 0 : _a2.width),
        "--thumb-active-left": thumbActive.value,
        "--thumb-active-width": toPX((_b = nextStyle.value) === null || _b === void 0 ? void 0 : _b.width)
      };
    });
    onBeforeUnmount(() => {
      clearTimeout(timeid);
    });
    return () => {
      const motionProps = {
        ref: thumbRef,
        style: mergedStyle.value,
        class: [`${props2.prefixCls}-thumb`]
      };
      if (false) {
        motionProps["data-test-style"] = JSON.stringify(mergedStyle.value);
      }
      return createVNode(Transition, {
        "appear": true,
        "onBeforeEnter": onAppearStart,
        "onEnter": onAppearActive,
        "onAfterEnter": onAppearEnd
      }, {
        default: () => [!prevStyle.value || !nextStyle.value ? null : createVNode("div", motionProps, null)]
      });
    };
  }
});
var MotionThumb_default = MotionThumb;

// node_modules/ant-design-vue/es/segmented/src/segmented.js
function normalizeOptions(options) {
  return options.map((option) => {
    if (typeof option === "object" && option !== null) {
      return option;
    }
    return {
      label: option === null || option === void 0 ? void 0 : option.toString(),
      title: option === null || option === void 0 ? void 0 : option.toString(),
      value: option
    };
  });
}
var segmentedProps = () => {
  return {
    prefixCls: String,
    options: arrayType(),
    block: booleanType(),
    disabled: booleanType(),
    size: stringType(),
    value: _extends(_extends({}, someType([String, Number])), {
      required: true
    }),
    motionName: String,
    onChange: functionType(),
    "onUpdate:value": functionType()
  };
};
var SegmentedOption = (props2, _ref) => {
  let {
    slots,
    emit
  } = _ref;
  const {
    value,
    disabled,
    payload,
    title,
    prefixCls,
    label = slots.label,
    checked,
    className
  } = props2;
  const handleChange = (event) => {
    if (disabled) {
      return;
    }
    emit("change", event, value);
  };
  return createVNode("label", {
    "class": classNames_default({
      [`${prefixCls}-item-disabled`]: disabled
    }, className)
  }, [createVNode("input", {
    "class": `${prefixCls}-item-input`,
    "type": "radio",
    "disabled": disabled,
    "checked": checked,
    "onChange": handleChange
  }, null), createVNode("div", {
    "class": `${prefixCls}-item-label`,
    "title": typeof title === "string" ? title : ""
  }, [typeof label === "function" ? label({
    value,
    disabled,
    payload,
    title
  }) : label !== null && label !== void 0 ? label : value])]);
};
SegmentedOption.inheritAttrs = false;
var segmented_default = defineComponent({
  name: "ASegmented",
  inheritAttrs: false,
  props: initDefaultProps_default(segmentedProps(), {
    options: [],
    motionName: "thumb-motion"
  }),
  slots: Object,
  setup(props2, _ref2) {
    let {
      emit,
      slots,
      attrs
    } = _ref2;
    const {
      prefixCls,
      direction,
      size
    } = useConfigInject_default("segmented", props2);
    const [wrapSSR, hashId] = style_default37(prefixCls);
    const rootRef = shallowRef();
    const thumbShow = shallowRef(false);
    const segmentedOptions = computed(() => normalizeOptions(props2.options));
    const handleChange = (_event, val) => {
      if (props2.disabled) {
        return;
      }
      emit("update:value", val);
      emit("change", val);
    };
    return () => {
      const pre = prefixCls.value;
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": classNames_default(pre, {
          [hashId.value]: true,
          [`${pre}-block`]: props2.block,
          [`${pre}-disabled`]: props2.disabled,
          [`${pre}-lg`]: size.value == "large",
          [`${pre}-sm`]: size.value == "small",
          [`${pre}-rtl`]: direction.value === "rtl"
        }, attrs.class),
        "ref": rootRef
      }), [createVNode("div", {
        "class": `${pre}-group`
      }, [createVNode(MotionThumb_default, {
        "containerRef": rootRef,
        "prefixCls": pre,
        "value": props2.value,
        "motionName": `${pre}-${props2.motionName}`,
        "direction": direction.value,
        "getValueIndex": (val) => segmentedOptions.value.findIndex((n) => n.value === val),
        "onMotionStart": () => {
          thumbShow.value = true;
        },
        "onMotionEnd": () => {
          thumbShow.value = false;
        }
      }, null), segmentedOptions.value.map((segmentedOption) => createVNode(SegmentedOption, _objectSpread2(_objectSpread2({
        "key": segmentedOption.value,
        "prefixCls": pre,
        "checked": segmentedOption.value === props2.value,
        "onChange": handleChange
      }, segmentedOption), {}, {
        "className": classNames_default(segmentedOption.className, `${pre}-item`, {
          [`${pre}-item-selected`]: segmentedOption.value === props2.value && !thumbShow.value
        }),
        "disabled": !!props2.disabled || !!segmentedOption.disabled
      }), slots))])]));
    };
  }
});

// node_modules/ant-design-vue/es/segmented/src/index.js
var src_default3 = segmented_default;

// node_modules/ant-design-vue/es/segmented/index.js
var segmented_default2 = withInstall(src_default3);

// node_modules/ant-design-vue/es/qrcode/style/index.js
var genQRCodeStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: _extends(_extends({}, resetComponent(token)), {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: token.paddingSM,
      backgroundColor: token.colorWhite,
      borderRadius: token.borderRadiusLG,
      border: `${token.lineWidth}px ${token.lineType} ${token.colorSplit}`,
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      [`& > ${componentCls}-mask`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: 10,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        color: token.colorText,
        lineHeight: token.lineHeight,
        background: token.QRCodeMaskBackgroundColor,
        textAlign: "center",
        [`& > ${componentCls}-expired , & > ${componentCls}-scanned`]: {
          color: token.QRCodeTextColor
        }
      },
      "&-icon": {
        marginBlockEnd: token.marginXS,
        fontSize: token.controlHeight
      }
    }),
    [`${componentCls}-borderless`]: {
      borderColor: "transparent"
    }
  };
};
var style_default38 = genComponentStyleHook("QRCode", (token) => genQRCodeStyle(merge(token, {
  QRCodeTextColor: "rgba(0, 0, 0, 0.88)",
  QRCodeMaskBackgroundColor: "rgba(255, 255, 255, 0.96)"
})));

// node_modules/ant-design-vue/es/qrcode/interface.js
var qrProps = () => {
  return {
    size: {
      type: Number,
      default: 160
    },
    value: {
      type: String,
      required: true
    },
    type: stringType("canvas"),
    color: String,
    bgColor: String,
    includeMargin: Boolean,
    imageSettings: objectType()
  };
};
var qrcodeProps = () => {
  return _extends(_extends({}, qrProps()), {
    errorLevel: stringType("M"),
    icon: String,
    iconSize: {
      type: Number,
      default: 40
    },
    status: stringType("active"),
    bordered: {
      type: Boolean,
      default: true
    }
  });
};

// node_modules/ant-design-vue/es/qrcode/qrcodegen.js
var qrcodegen;
(function(qrcodegen2) {
  class QrCode {
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(text, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text);
      return QrCode.encodeSegments(segs, ecl);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return QrCode.encodeSegments([seg], ecl);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(segs, ecl) {
      let minVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      let maxVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
      let mask = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
      let boostEcl = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION) || mask < -1 || mask > 7)
        throw new RangeError("Invalid value");
      let version;
      let dataUsedBits;
      for (version = minVersion; ; version++) {
        const dataCapacityBits2 = QrCode.getNumDataCodewords(version, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [QrCode.Ecc.MEDIUM, QrCode.Ecc.QUARTILE, QrCode.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8)
          ecl = newEcl;
      }
      const bb = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
        for (const b of seg.getData())
          bb.push(b);
      }
      assert(bb.length == dataUsedBits);
      const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
        appendBits(padByte, 8, bb);
      const dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length)
        dataCodewords.push(0);
      bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
      return new QrCode(version, ecl, dataCodewords, mask);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(version, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7)
        throw new RangeError("Mask value out of range");
      this.size = version * 4 + 17;
      const row = [];
      for (let i = 0; i < this.size; i++)
        row.push(false);
      for (let i = 0; i < this.size; i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i = 0; i < 8; i++) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
    }
    // Modified to expose modules for easy access
    getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; i++) {
        for (let j = 0; j < numAlign; j++) {
          if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(mask) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask;
      let rem = data;
      for (let i = 0; i < 10; i++)
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (let i = 0; i <= 5; i++)
        this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; i++)
        this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; i++)
        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; i++)
        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7)
        return;
      let rem = this.version;
      for (let i = 0; i < 12; i++)
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (let i = 0; i < 18; i++) {
        const color = getBit(bits, i);
        const a = this.size - 11 + i % 3;
        const b = Math.floor(i / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(x, y) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x + dx;
          const yy = y + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
        }
      }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(x, y) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark;
      this.isFunction[y][x] = true;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != QrCode.getNumDataCodewords(ver, ecl))
        throw new RangeError("Invalid argument");
      const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      const blocks = [];
      const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);
      for (let i = 0, k = 0; i < numBlocks; i++) {
        const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k += dat.length;
        const ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks)
          dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      const result = [];
      for (let i = 0; i < blocks[0].length; i++) {
        blocks.forEach((block, j) => {
          if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
            result.push(block[i]);
        });
      }
      assert(result.length == rawCodewords);
      return result;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(data) {
      if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let i = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6)
          right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j = 0; j < 2; j++) {
            const x = right - j;
            const upward = (right + 1 & 2) == 0;
            const y = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y][x] && i < data.length * 8) {
              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert(i == data.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(mask) {
      if (mask < 0 || mask > 7)
        throw new RangeError("Mask value out of range");
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          let invert;
          switch (mask) {
            case 0:
              invert = (x + y) % 2 == 0;
              break;
            case 1:
              invert = y % 2 == 0;
              break;
            case 2:
              invert = x % 3 == 0;
              break;
            case 3:
              invert = (x + y) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
              break;
            case 5:
              invert = x * y % 2 + x * y % 3 == 0;
              break;
            case 6:
              invert = (x * y % 2 + x * y % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y][x] && invert)
            this.modules[y][x] = !this.modules[y][x];
        }
      }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let result = 0;
      for (let y = 0; y < this.size; y++) {
        let runColor = false;
        let runX = 0;
        const runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x = 0; x < this.size; x++) {
          if (this.modules[y][x] == runColor) {
            runX++;
            if (runX == 5)
              result += QrCode.PENALTY_N1;
            else if (runX > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3;
      }
      for (let x = 0; x < this.size; x++) {
        let runColor = false;
        let runY = 0;
        const runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y = 0; y < this.size; y++) {
          if (this.modules[y][x] == runColor) {
            runY++;
            if (runY == 5)
              result += QrCode.PENALTY_N1;
            else if (runY > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode.PENALTY_N3;
      }
      for (let y = 0; y < this.size - 1; y++) {
        for (let x = 0; x < this.size - 1; x++) {
          const color = this.modules[y][x];
          if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])
            result += QrCode.PENALTY_N2;
        }
      }
      let dark = 0;
      for (const row of this.modules)
        dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
      const total = this.size * this.size;
      const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * QrCode.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        const result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step)
          result.splice(1, 0, pos);
        return result;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(ver) {
      if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7)
          result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(QrCode.getNumRawDataModules(ver) / 8) - QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255)
        throw new RangeError("Degree out of range");
      const result = [];
      for (let i = 0; i < degree - 1; i++)
        result.push(0);
      result.push(1);
      let root = 1;
      for (let i = 0; i < degree; i++) {
        for (let j = 0; j < result.length; j++) {
          result[j] = QrCode.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length)
            result[j] ^= result[j + 1];
        }
        root = QrCode.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(data, divisor) {
      const result = divisor.map((_) => 0);
      for (const b of data) {
        const factor = b ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i) => result[i] ^= QrCode.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(x, y) {
      if (x >>> 8 != 0 || y >>> 8 != 0)
        throw new RangeError("Byte out of range");
      let z = 0;
      for (let i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y >>> i & 1) * x;
      }
      assert(z >>> 8 == 0);
      return z;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(runHistory) {
      const n = runHistory[1];
      assert(n <= this.size * 3);
      const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0)
        currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  }
  QrCode.MIN_VERSION = 1;
  QrCode.MAX_VERSION = 40;
  QrCode.PENALTY_N1 = 3;
  QrCode.PENALTY_N2 = 3;
  QrCode.PENALTY_N3 = 40;
  QrCode.PENALTY_N4 = 10;
  QrCode.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
    // High
  ];
  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
    // High
  ];
  qrcodegen2.QrCode = QrCode;
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0)
      throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--)
      bb.push(val >>> i & 1);
  }
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  function assert(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  class QrSegment {
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(data) {
      const bb = [];
      for (const b of data)
        appendBits(b, 8, bb);
      return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(digits) {
      if (!QrSegment.isNumeric(digits))
        throw new RangeError("String contains non-numeric characters");
      const bb = [];
      for (let i = 0; i < digits.length; ) {
        const n = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
        i += n;
      }
      return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(text) {
      if (!QrSegment.isAlphanumeric(text))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      const bb = [];
      let i;
      for (i = 0; i + 2 <= text.length; i += 2) {
        let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
        temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
        appendBits(temp, 11, bb);
      }
      if (i < text.length)
        appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
      return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(text) {
      if (text == "")
        return [];
      else if (QrSegment.isNumeric(text))
        return [QrSegment.makeNumeric(text)];
      else if (QrSegment.isAlphanumeric(text))
        return [QrSegment.makeAlphanumeric(text)];
      else
        return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(assignVal) {
      const bb = [];
      if (assignVal < 0)
        throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7)
        appendBits(assignVal, 8, bb);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else
        throw new RangeError("ECI assignment value out of range");
      return new QrSegment(QrSegment.Mode.ECI, 0, bb);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(text) {
      return QrSegment.NUMERIC_REGEX.test(text);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(text) {
      return QrSegment.ALPHANUMERIC_REGEX.test(text);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0)
        throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(segs, version) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version);
        if (seg.numChars >= 1 << ccbits)
          return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      const result = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%")
          result.push(str.charCodeAt(i));
        else {
          result.push(parseInt(str.substring(i + 1, i + 3), 16));
          i += 2;
        }
      }
      return result;
    }
  }
  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  qrcodegen2.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
(function(qrcodegen2) {
  var QrCode;
  (function(QrCode2) {
    class Ecc {
      /*-- Constructor and fields --*/
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    }
    Ecc.LOW = new Ecc(0, 1);
    Ecc.MEDIUM = new Ecc(1, 0);
    Ecc.QUARTILE = new Ecc(2, 3);
    Ecc.HIGH = new Ecc(3, 2);
    QrCode2.Ecc = Ecc;
  })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
(function(qrcodegen2) {
  var QrSegment;
  (function(QrSegment2) {
    class Mode {
      /*-- Constructor and fields --*/
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    }
    Mode.NUMERIC = new Mode(1, [10, 12, 14]);
    Mode.ALPHANUMERIC = new Mode(2, [9, 11, 13]);
    Mode.BYTE = new Mode(4, [8, 16, 16]);
    Mode.KANJI = new Mode(8, [8, 10, 12]);
    Mode.ECI = new Mode(7, [0, 0, 0]);
    QrSegment2.Mode = Mode;
  })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;

// node_modules/ant-design-vue/es/qrcode/QRCode.js
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE3 = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules) {
  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const ops = [];
  modules.forEach(function(row, y) {
    let start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
        } else {
          ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y) => {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x) => {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size, margin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  const scale = numCells / size;
  const w = (imageSettings.width || defaultSize) * scale;
  const h = (imageSettings.height || defaultSize) * scale;
  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  let excavation = null;
  if (imageSettings.excavate) {
    const floorX = Math.floor(x);
    const floorY = Math.floor(y);
    const ceilW = Math.ceil(w + x - floorX);
    const ceilH = Math.ceil(h + y - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }
  return {
    x,
    y,
    h,
    w,
    excavation
  };
}
function getMarginSize(includeMargin, marginSize) {
  if (marginSize != null) {
    return Math.floor(marginSize);
  }
  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
}
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }
  return true;
}();
var QRCodeCanvas = defineComponent({
  name: "QRCodeCanvas",
  inheritAttrs: false,
  props: _extends(_extends({}, qrProps()), {
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number
  }),
  setup(props2, _ref) {
    let {
      attrs,
      expose
    } = _ref;
    const imgSrc = computed(() => {
      var _a2;
      return (_a2 = props2.imageSettings) === null || _a2 === void 0 ? void 0 : _a2.src;
    });
    const _canvas = shallowRef(null);
    const _image = shallowRef(null);
    const isImgLoaded = shallowRef(false);
    expose({
      toDataURL: (type, quality) => {
        var _a2;
        return (_a2 = _canvas.value) === null || _a2 === void 0 ? void 0 : _a2.toDataURL(type, quality);
      }
    });
    watchEffect(() => {
      const {
        value,
        size = DEFAULT_SIZE3,
        level = DEFAULT_LEVEL,
        bgColor = DEFAULT_BGCOLOR,
        fgColor = DEFAULT_FGCOLOR,
        includeMargin = DEFAULT_INCLUDEMARGIN,
        marginSize,
        imageSettings
      } = props2;
      if (_canvas.value != null) {
        const canvas = _canvas.value;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return;
        }
        let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
        const margin = getMarginSize(includeMargin, marginSize);
        const numCells = cells.length + margin * 2;
        const calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);
        const image = _image.value;
        const haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
        if (haveImageToRender) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }
        }
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        const scale = size / numCells * pixelRatio;
        ctx.scale(scale, scale);
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;
        if (SUPPORTS_PATH2D) {
          ctx.fill(new Path2D(generatePath(cells, margin)));
        } else {
          cells.forEach(function(row, rdx) {
            row.forEach(function(cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }
        if (haveImageToRender) {
          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
        }
      }
    }, {
      flush: "post"
    });
    watch(imgSrc, () => {
      isImgLoaded.value = false;
    });
    return () => {
      var _a2;
      const size = (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : DEFAULT_SIZE3;
      const canvasStyle = {
        height: `${size}px`,
        width: `${size}px`
      };
      let img = null;
      if (imgSrc.value != null) {
        img = createVNode("img", {
          "src": imgSrc.value,
          "key": imgSrc.value,
          "style": {
            display: "none"
          },
          "onLoad": () => {
            isImgLoaded.value = true;
          },
          "ref": _image
        }, null);
      }
      return createVNode(Fragment, null, [createVNode("canvas", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "style": [canvasStyle, attrs.style],
        "ref": _canvas
      }), null), img]);
    };
  }
});
var QRCodeSVG = defineComponent({
  name: "QRCodeSVG",
  inheritAttrs: false,
  props: _extends(_extends({}, qrProps()), {
    color: String,
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number,
    title: String
  }),
  setup(props2) {
    let cells = null;
    let margin = null;
    let numCells = null;
    let calculatedImageSettings = null;
    let fgPath = null;
    let image = null;
    watchEffect(() => {
      const {
        value,
        size = DEFAULT_SIZE3,
        level = DEFAULT_LEVEL,
        includeMargin = DEFAULT_INCLUDEMARGIN,
        marginSize,
        imageSettings
      } = props2;
      cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
      margin = getMarginSize(includeMargin, marginSize);
      numCells = cells.length + margin * 2;
      calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);
      if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }
        image = createVNode("image", {
          "xlink:href": imageSettings.src,
          "height": calculatedImageSettings.h,
          "width": calculatedImageSettings.w,
          "x": calculatedImageSettings.x + margin,
          "y": calculatedImageSettings.y + margin,
          "preserveAspectRatio": "none"
        }, null);
      }
      fgPath = generatePath(cells, margin);
    });
    return () => {
      const bgColor = props2.bgColor && DEFAULT_BGCOLOR;
      const fgColor = props2.fgColor && DEFAULT_FGCOLOR;
      return createVNode("svg", {
        "height": props2.size,
        "width": props2.size,
        "viewBox": `0 0 ${numCells} ${numCells}`
      }, [!!props2.title && createVNode("title", null, [props2.title]), createVNode("path", {
        "fill": bgColor,
        "d": `M0,0 h${numCells}v${numCells}H0z`,
        "shape-rendering": "crispEdges"
      }, null), createVNode("path", {
        "fill": fgColor,
        "d": fgPath,
        "shape-rendering": "crispEdges"
      }, null), image]);
    };
  }
});

// node_modules/ant-design-vue/es/qrcode/index.js
var QRCode = defineComponent({
  name: "AQrcode",
  inheritAttrs: false,
  props: qrcodeProps(),
  emits: ["refresh"],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      expose
    } = _ref;
    if (true) {
      warning_default2(!(props2.icon && props2.errorLevel === "L"), "QRCode", "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level.");
    }
    const [locale] = useLocaleReceiver("QRCode");
    const {
      prefixCls
    } = useConfigInject_default("qrcode", props2);
    const [wrapSSR, hashId] = style_default38(prefixCls);
    const [, token] = useToken();
    const qrCodeCanvas = ref();
    expose({
      toDataURL: (type, quality) => {
        var _a2;
        return (_a2 = qrCodeCanvas.value) === null || _a2 === void 0 ? void 0 : _a2.toDataURL(type, quality);
      }
    });
    const qrCodeProps = computed(() => {
      const {
        value,
        icon = "",
        size = 160,
        iconSize = 40,
        color = token.value.colorText,
        bgColor = "transparent",
        errorLevel = "M"
      } = props2;
      const imageSettings = {
        src: icon,
        x: void 0,
        y: void 0,
        height: iconSize,
        width: iconSize,
        excavate: true
      };
      return {
        value,
        size: size - (token.value.paddingSM + token.value.lineWidth) * 2,
        level: errorLevel,
        bgColor,
        fgColor: color,
        imageSettings: icon ? imageSettings : void 0
      };
    });
    return () => {
      const pre = prefixCls.value;
      return wrapSSR(createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "style": [attrs.style, {
          width: `${props2.size}px`,
          height: `${props2.size}px`,
          backgroundColor: qrCodeProps.value.bgColor
        }],
        "class": [hashId.value, pre, {
          [`${pre}-borderless`]: !props2.bordered
        }]
      }), [props2.status !== "active" && createVNode("div", {
        "class": `${pre}-mask`
      }, [props2.status === "loading" && createVNode(spin_default, null, null), props2.status === "expired" && createVNode(Fragment, null, [createVNode("p", {
        "class": `${pre}-expired`
      }, [locale.value.expired]), createVNode(button_default, {
        "type": "link",
        "onClick": (e) => emit("refresh", e)
      }, {
        default: () => [locale.value.refresh],
        icon: () => createVNode(ReloadOutlined_default, null, null)
      })]), props2.status === "scanned" && createVNode("p", {
        "class": `${pre}-scanned`
      }, [locale.value.scanned])]), props2.type === "canvas" ? createVNode(QRCodeCanvas, _objectSpread2({
        "ref": qrCodeCanvas
      }, qrCodeProps.value), null) : createVNode(QRCodeSVG, qrCodeProps.value, null)]));
    };
  }
});
var qrcode_default = withInstall(QRCode);

// node_modules/ant-design-vue/es/vc-tour/util.js
function isInViewPort(element) {
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const {
    top,
    right,
    bottom,
    left
  } = element.getBoundingClientRect();
  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}

// node_modules/ant-design-vue/es/vc-tour/hooks/useTarget.js
function useTarget(target, open2, gap, scrollIntoViewOptions) {
  const [targetElement, setTargetElement] = useState(void 0);
  watchEffect(() => {
    const nextElement = typeof target.value === "function" ? target.value() : target.value;
    setTargetElement(nextElement || null);
  }, {
    flush: "post"
  });
  const [posInfo, setPosInfo] = useState(null);
  const updatePos = () => {
    if (!open2.value) {
      setPosInfo(null);
      return;
    }
    if (targetElement.value) {
      if (!isInViewPort(targetElement.value) && open2.value) {
        targetElement.value.scrollIntoView(scrollIntoViewOptions.value);
      }
      const {
        left,
        top,
        width,
        height
      } = targetElement.value.getBoundingClientRect();
      const nextPosInfo = {
        left,
        top,
        width,
        height,
        radius: 0
      };
      if (JSON.stringify(posInfo.value) !== JSON.stringify(nextPosInfo)) {
        setPosInfo(nextPosInfo);
      }
    } else {
      setPosInfo(null);
    }
  };
  onMounted(() => {
    watch([open2, targetElement], () => {
      updatePos();
    }, {
      flush: "post",
      immediate: true
    });
    window.addEventListener("resize", updatePos);
  });
  onBeforeUnmount(() => {
    window.removeEventListener("resize", updatePos);
  });
  const mergedPosInfo = computed(() => {
    var _a2, _b;
    if (!posInfo.value) {
      return posInfo.value;
    }
    const gapOffset = ((_a2 = gap.value) === null || _a2 === void 0 ? void 0 : _a2.offset) || 6;
    const gapRadius = ((_b = gap.value) === null || _b === void 0 ? void 0 : _b.radius) || 2;
    return {
      left: posInfo.value.left - gapOffset,
      top: posInfo.value.top - gapOffset,
      width: posInfo.value.width + gapOffset * 2,
      height: posInfo.value.height + gapOffset * 2,
      radius: gapRadius
    };
  });
  return [mergedPosInfo, targetElement];
}

// node_modules/ant-design-vue/es/vc-tour/interface.js
var tourStepInfo = () => ({
  arrow: someType([Boolean, Object]),
  target: someType([String, Function, Object]),
  title: someType([String, Object]),
  description: someType([String, Object]),
  placement: stringType(),
  mask: someType([Object, Boolean], true),
  className: {
    type: String
  },
  style: objectType(),
  scrollIntoViewOptions: someType([Boolean, Object])
});
var tourStepProps = () => _extends(_extends({}, tourStepInfo()), {
  prefixCls: {
    type: String
  },
  total: {
    type: Number
  },
  current: {
    type: Number
  },
  onClose: functionType(),
  onFinish: functionType(),
  renderPanel: functionType(),
  onPrev: functionType(),
  onNext: functionType()
});

// node_modules/ant-design-vue/es/vc-tour/TourStep/DefaultPanel.js
var DefaultPanel = defineComponent({
  name: "DefaultPanel",
  inheritAttrs: false,
  props: tourStepProps(),
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    return () => {
      const {
        prefixCls,
        current,
        total,
        title,
        description,
        onClose,
        onPrev,
        onNext,
        onFinish
      } = props2;
      return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
        "class": classNames_default(`${prefixCls}-content`, attrs.class)
      }), [createVNode("div", {
        "class": `${prefixCls}-inner`
      }, [createVNode("button", {
        "type": "button",
        "onClick": onClose,
        "aria-label": "Close",
        "class": `${prefixCls}-close`
      }, [createVNode("span", {
        "class": `${prefixCls}-close-x`
      }, [createTextVNode("×")])]), createVNode("div", {
        "class": `${prefixCls}-header`
      }, [createVNode("div", {
        "class": `${prefixCls}-title`
      }, [title])]), createVNode("div", {
        "class": `${prefixCls}-description`
      }, [description]), createVNode("div", {
        "class": `${prefixCls}-footer`
      }, [createVNode("div", {
        "class": `${prefixCls}-sliders`
      }, [total > 1 ? [...Array.from({
        length: total
      }).keys()].map((item, index2) => {
        return createVNode("span", {
          "key": item,
          "class": index2 === current ? "active" : ""
        }, null);
      }) : null]), createVNode("div", {
        "class": `${prefixCls}-buttons`
      }, [current !== 0 ? createVNode("button", {
        "class": `${prefixCls}-prev-btn`,
        "onClick": onPrev
      }, [createTextVNode("Prev")]) : null, current === total - 1 ? createVNode("button", {
        "class": `${prefixCls}-finish-btn`,
        "onClick": onFinish
      }, [createTextVNode("Finish")]) : createVNode("button", {
        "class": `${prefixCls}-next-btn`,
        "onClick": onNext
      }, [createTextVNode("Next")])])])])]);
    };
  }
});
var DefaultPanel_default = DefaultPanel;

// node_modules/ant-design-vue/es/vc-tour/TourStep/index.js
var TourStep = defineComponent({
  name: "TourStep",
  inheritAttrs: false,
  props: tourStepProps(),
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    return () => {
      const {
        current,
        renderPanel
      } = props2;
      return createVNode(Fragment, null, [typeof renderPanel === "function" ? renderPanel(_extends(_extends({}, attrs), props2), current) : createVNode(DefaultPanel_default, _objectSpread2(_objectSpread2({}, attrs), props2), null)]);
    };
  }
});
var TourStep_default = TourStep;

// node_modules/ant-design-vue/es/_util/hooks/useId.js
var uuid3 = 0;
var isBrowserClient = canUseDom_default();
function getUUID() {
  let retId;
  if (isBrowserClient) {
    retId = uuid3;
    uuid3 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
function useId2() {
  let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ref("");
  const innerId = `vc_unique_${getUUID()}`;
  return id.value || innerId;
}

// node_modules/ant-design-vue/es/vc-tour/Mask.js
var COVER_PROPS = {
  fill: "transparent",
  "pointer-events": "auto"
};
var Mask = defineComponent({
  name: "TourMask",
  props: {
    prefixCls: {
      type: String
    },
    pos: objectType(),
    rootClassName: {
      type: String
    },
    showMask: booleanType(),
    fill: {
      type: String,
      default: "rgba(0,0,0,0.5)"
    },
    open: booleanType(),
    animated: someType([Boolean, Object]),
    zIndex: {
      type: Number
    }
  },
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    const id = useId2();
    return () => {
      const {
        prefixCls,
        open: open2,
        rootClassName,
        pos,
        showMask,
        fill,
        animated,
        zIndex
      } = props2;
      const maskId = `${prefixCls}-mask-${id}`;
      const mergedAnimated = typeof animated === "object" ? animated === null || animated === void 0 ? void 0 : animated.placeholder : animated;
      return createVNode(PortalWrapper_default, {
        "visible": open2,
        "autoLock": true
      }, {
        default: () => open2 && createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
          "class": classNames_default(`${prefixCls}-mask`, rootClassName, attrs.class),
          "style": [{
            position: "fixed",
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            zIndex,
            pointerEvents: "none"
          }, attrs.style]
        }), [showMask ? createVNode("svg", {
          "style": {
            width: "100%",
            height: "100%"
          }
        }, [createVNode("defs", null, [createVNode("mask", {
          "id": maskId
        }, [createVNode("rect", {
          "x": "0",
          "y": "0",
          "width": "100vw",
          "height": "100vh",
          "fill": "white"
        }, null), pos && createVNode("rect", {
          "x": pos.left,
          "y": pos.top,
          "rx": pos.radius,
          "width": pos.width,
          "height": pos.height,
          "fill": "black",
          "class": mergedAnimated ? `${prefixCls}-placeholder-animated` : ""
        }, null)])]), createVNode("rect", {
          "x": "0",
          "y": "0",
          "width": "100%",
          "height": "100%",
          "fill": fill,
          "mask": `url(#${maskId})`
        }, null), pos && createVNode(Fragment, null, [createVNode("rect", _objectSpread2(_objectSpread2({}, COVER_PROPS), {}, {
          "x": "0",
          "y": "0",
          "width": "100%",
          "height": pos.top
        }), null), createVNode("rect", _objectSpread2(_objectSpread2({}, COVER_PROPS), {}, {
          "x": "0",
          "y": "0",
          "width": pos.left,
          "height": "100%"
        }), null), createVNode("rect", _objectSpread2(_objectSpread2({}, COVER_PROPS), {}, {
          "x": "0",
          "y": pos.top + pos.height,
          "width": "100%",
          "height": `calc(100vh - ${pos.top + pos.height}px)`
        }), null), createVNode("rect", _objectSpread2(_objectSpread2({}, COVER_PROPS), {}, {
          "x": pos.left + pos.width,
          "y": "0",
          "width": `calc(100vw - ${pos.left + pos.width}px)`,
          "height": "100%"
        }), null)])]) : null])
      });
    };
  }
});
var Mask_default = Mask;

// node_modules/ant-design-vue/es/vc-tour/placements.js
var targetOffset = [0, 0];
var basePlacements = {
  left: {
    points: ["cr", "cl"],
    offset: [-8, 0]
  },
  right: {
    points: ["cl", "cr"],
    offset: [8, 0]
  },
  top: {
    points: ["bc", "tc"],
    offset: [0, -8]
  },
  bottom: {
    points: ["tc", "bc"],
    offset: [0, 8]
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -8]
  },
  leftTop: {
    points: ["tr", "tl"],
    offset: [-8, 0]
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -8]
  },
  rightTop: {
    points: ["tl", "tr"],
    offset: [8, 0]
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 8]
  },
  rightBottom: {
    points: ["bl", "br"],
    offset: [8, 0]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 8]
  },
  leftBottom: {
    points: ["br", "bl"],
    offset: [-8, 0]
  }
};
function getPlacements2() {
  let arrowPointAtCenter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  const placements2 = {};
  Object.keys(basePlacements).forEach((key) => {
    placements2[key] = _extends(_extends({}, basePlacements[key]), {
      autoArrow: arrowPointAtCenter,
      targetOffset
    });
  });
  return placements2;
}
var placements = getPlacements2();

// node_modules/ant-design-vue/es/vc-tour/Tour.js
var __rest39 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var CENTER_PLACEHOLDER = {
  left: "50%",
  top: "50%",
  width: "1px",
  height: "1px"
};
var tourProps = () => {
  const {
    builtinPlacements,
    popupAlign
  } = triggerProps();
  return {
    builtinPlacements,
    popupAlign,
    steps: arrayType(),
    open: booleanType(),
    defaultCurrent: {
      type: Number
    },
    current: {
      type: Number
    },
    onChange: functionType(),
    onClose: functionType(),
    onFinish: functionType(),
    mask: someType([Boolean, Object], true),
    arrow: someType([Boolean, Object], true),
    rootClassName: {
      type: String
    },
    placement: stringType("bottom"),
    prefixCls: {
      type: String,
      default: "rc-tour"
    },
    renderPanel: functionType(),
    gap: objectType(),
    animated: someType([Boolean, Object]),
    scrollIntoViewOptions: someType([Boolean, Object], true),
    zIndex: {
      type: Number,
      default: 1001
    }
  };
};
var Tour = defineComponent({
  name: "Tour",
  inheritAttrs: false,
  props: initDefaultProps_default(tourProps(), {}),
  setup(props2) {
    const {
      defaultCurrent,
      placement,
      mask,
      scrollIntoViewOptions,
      open: open2,
      gap,
      arrow
    } = toRefs(props2);
    const triggerRef2 = ref();
    const [mergedCurrent, setMergedCurrent] = useMergedState(0, {
      value: computed(() => props2.current),
      defaultValue: defaultCurrent.value
    });
    const [mergedOpen, setMergedOpen] = useMergedState(void 0, {
      value: computed(() => props2.open),
      postState: (origin) => mergedCurrent.value < 0 || mergedCurrent.value >= props2.steps.length ? false : origin !== null && origin !== void 0 ? origin : true
    });
    const openRef = shallowRef(mergedOpen.value);
    watchEffect(() => {
      if (mergedOpen.value && !openRef.value) {
        setMergedCurrent(0);
      }
      openRef.value = mergedOpen.value;
    });
    const curStep = computed(() => props2.steps[mergedCurrent.value] || {});
    const mergedPlacement = computed(() => {
      var _a2;
      return (_a2 = curStep.value.placement) !== null && _a2 !== void 0 ? _a2 : placement.value;
    });
    const mergedMask = computed(() => {
      var _a2;
      return mergedOpen.value && ((_a2 = curStep.value.mask) !== null && _a2 !== void 0 ? _a2 : mask.value);
    });
    const mergedScrollIntoViewOptions = computed(() => {
      var _a2;
      return (_a2 = curStep.value.scrollIntoViewOptions) !== null && _a2 !== void 0 ? _a2 : scrollIntoViewOptions.value;
    });
    const [posInfo, targetElement] = useTarget(computed(() => curStep.value.target), open2, gap, mergedScrollIntoViewOptions);
    const mergedArrow = computed(() => targetElement.value ? typeof curStep.value.arrow === "undefined" ? arrow.value : curStep.value.arrow : false);
    const arrowPointAtCenter = computed(() => typeof mergedArrow.value === "object" ? mergedArrow.value.pointAtCenter : false);
    watch(arrowPointAtCenter, () => {
      var _a2;
      (_a2 = triggerRef2.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
    });
    watch(mergedCurrent, () => {
      var _a2;
      (_a2 = triggerRef2.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
    });
    const onInternalChange = (nextCurrent) => {
      var _a2;
      setMergedCurrent(nextCurrent);
      (_a2 = props2.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, nextCurrent);
    };
    return () => {
      var _a2;
      const {
        prefixCls,
        steps,
        onClose,
        onFinish,
        rootClassName,
        renderPanel,
        animated,
        zIndex
      } = props2, restProps = __rest39(props2, ["prefixCls", "steps", "onClose", "onFinish", "rootClassName", "renderPanel", "animated", "zIndex"]);
      if (targetElement.value === void 0) {
        return null;
      }
      const handleClose = () => {
        setMergedOpen(false);
        onClose === null || onClose === void 0 ? void 0 : onClose(mergedCurrent.value);
      };
      const mergedShowMask = typeof mergedMask.value === "boolean" ? mergedMask.value : !!mergedMask.value;
      const mergedMaskStyle = typeof mergedMask.value === "boolean" ? void 0 : mergedMask.value;
      const getTriggerDOMNode = () => {
        return targetElement.value || document.body;
      };
      const getPopupElement = () => createVNode(TourStep_default, _objectSpread2({
        "arrow": mergedArrow.value,
        "key": "content",
        "prefixCls": prefixCls,
        "total": steps.length,
        "renderPanel": renderPanel,
        "onPrev": () => {
          onInternalChange(mergedCurrent.value - 1);
        },
        "onNext": () => {
          onInternalChange(mergedCurrent.value + 1);
        },
        "onClose": handleClose,
        "current": mergedCurrent.value,
        "onFinish": () => {
          handleClose();
          onFinish === null || onFinish === void 0 ? void 0 : onFinish();
        }
      }, curStep.value), null);
      const posInfoStyle = computed(() => {
        const info = posInfo.value || CENTER_PLACEHOLDER;
        const style = {};
        Object.keys(info).forEach((key) => {
          if (typeof info[key] === "number") {
            style[key] = `${info[key]}px`;
          } else {
            style[key] = info[key];
          }
        });
        return style;
      });
      return mergedOpen.value ? createVNode(Fragment, null, [createVNode(Mask_default, {
        "zIndex": zIndex,
        "prefixCls": prefixCls,
        "pos": posInfo.value,
        "showMask": mergedShowMask,
        "style": mergedMaskStyle === null || mergedMaskStyle === void 0 ? void 0 : mergedMaskStyle.style,
        "fill": mergedMaskStyle === null || mergedMaskStyle === void 0 ? void 0 : mergedMaskStyle.color,
        "open": mergedOpen.value,
        "animated": animated,
        "rootClassName": rootClassName
      }, null), createVNode(vc_trigger_default, _objectSpread2(_objectSpread2({}, restProps), {}, {
        "arrow": !!restProps.arrow,
        "builtinPlacements": !curStep.value.target ? void 0 : (_a2 = restProps.builtinPlacements) !== null && _a2 !== void 0 ? _a2 : getPlacements2(arrowPointAtCenter.value),
        "ref": triggerRef2,
        "popupStyle": !curStep.value.target ? _extends(_extends({}, curStep.value.style), {
          position: "fixed",
          left: CENTER_PLACEHOLDER.left,
          top: CENTER_PLACEHOLDER.top,
          transform: "translate(-50%, -50%)"
        }) : curStep.value.style,
        "popupPlacement": mergedPlacement.value,
        "popupVisible": mergedOpen.value,
        "popupClassName": classNames_default(rootClassName, curStep.value.className),
        "prefixCls": prefixCls,
        "popup": getPopupElement,
        "forceRender": false,
        "destroyPopupOnHide": true,
        "zIndex": zIndex,
        "mask": false,
        "getTriggerDOMNode": getTriggerDOMNode
      }), {
        default: () => [createVNode(PortalWrapper_default, {
          "visible": mergedOpen.value,
          "autoLock": true
        }, {
          default: () => [createVNode("div", {
            "class": classNames_default(rootClassName, `${prefixCls}-target-placeholder`),
            "style": _extends(_extends({}, posInfoStyle.value), {
              position: "fixed",
              pointerEvents: "none"
            })
          }, null)]
        })]
      })]) : null;
    };
  }
});
var Tour_default = Tour;

// node_modules/ant-design-vue/es/vc-tour/index.js
var vc_tour_default = Tour_default;

// node_modules/ant-design-vue/es/tour/interface.js
var tourProps2 = () => _extends(_extends({}, tourProps()), {
  steps: {
    type: Array
  },
  prefixCls: {
    type: String
  },
  current: {
    type: Number
  },
  type: {
    type: String
  },
  "onUpdate:current": Function
});
var tourStepProps2 = () => _extends(_extends({}, tourStepProps()), {
  cover: {
    type: Object
  },
  nextButtonProps: {
    type: Object
  },
  prevButtonProps: {
    type: Object
  },
  current: {
    type: Number
  },
  type: {
    type: String
  }
});

// node_modules/ant-design-vue/es/tour/panelRender.js
var panelRender = defineComponent({
  name: "ATourPanel",
  inheritAttrs: false,
  props: tourStepProps2(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      current,
      total
    } = toRefs(props2);
    const isLastStep = computed(() => current.value === total.value - 1);
    const prevBtnClick = (e) => {
      var _a2;
      const prevButtonProps = props2.prevButtonProps;
      (_a2 = props2.onPrev) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
      if (typeof (prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.onClick) === "function") {
        prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.onClick();
      }
    };
    const nextBtnClick = (e) => {
      var _a2, _b;
      const nextButtonProps = props2.nextButtonProps;
      if (isLastStep.value) {
        (_a2 = props2.onFinish) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e);
      } else {
        (_b = props2.onNext) === null || _b === void 0 ? void 0 : _b.call(props2, e);
      }
      if (typeof (nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.onClick) === "function") {
        nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.onClick();
      }
    };
    return () => {
      const {
        prefixCls,
        title,
        onClose,
        cover,
        description,
        type: stepType,
        arrow
      } = props2;
      const prevButtonProps = props2.prevButtonProps;
      const nextButtonProps = props2.nextButtonProps;
      let headerNode;
      if (title) {
        headerNode = createVNode("div", {
          "class": `${prefixCls}-header`
        }, [createVNode("div", {
          "class": `${prefixCls}-title`
        }, [title])]);
      }
      let descriptionNode;
      if (description) {
        descriptionNode = createVNode("div", {
          "class": `${prefixCls}-description`
        }, [description]);
      }
      let coverNode;
      if (cover) {
        coverNode = createVNode("div", {
          "class": `${prefixCls}-cover`
        }, [cover]);
      }
      let mergeIndicatorNode;
      if (slots.indicatorsRender) {
        mergeIndicatorNode = slots.indicatorsRender({
          current: current.value,
          total
        });
      } else {
        mergeIndicatorNode = [...Array.from({
          length: total.value
        }).keys()].map((stepItem, index2) => createVNode("span", {
          "key": stepItem,
          "class": classNames_default(index2 === current.value && `${prefixCls}-indicator-active`, `${prefixCls}-indicator`)
        }, null));
      }
      const mainBtnType = stepType === "primary" ? "default" : "primary";
      const secondaryBtnProps = {
        type: "default",
        ghost: stepType === "primary"
      };
      return createVNode(LocaleReceiver_default, {
        "componentName": "Tour",
        "defaultLocale": en_US_default3.Tour
      }, {
        default: (contextLocale) => {
          var _a2;
          return createVNode("div", _objectSpread2(_objectSpread2({}, attrs), {}, {
            "class": classNames_default(stepType === "primary" ? `${prefixCls}-primary` : "", attrs.class, `${prefixCls}-content`)
          }), [arrow && createVNode("div", {
            "class": `${prefixCls}-arrow`,
            "key": "arrow"
          }, null), createVNode("div", {
            "class": `${prefixCls}-inner`
          }, [createVNode(CloseOutlined_default, {
            "class": `${prefixCls}-close`,
            "onClick": onClose
          }, null), coverNode, headerNode, descriptionNode, createVNode("div", {
            "class": `${prefixCls}-footer`
          }, [total.value > 1 && createVNode("div", {
            "class": `${prefixCls}-indicators`
          }, [mergeIndicatorNode]), createVNode("div", {
            "class": `${prefixCls}-buttons`
          }, [current.value !== 0 ? createVNode(button_default, _objectSpread2(_objectSpread2(_objectSpread2({}, secondaryBtnProps), prevButtonProps), {}, {
            "onClick": prevBtnClick,
            "size": "small",
            "class": classNames_default(`${prefixCls}-prev-btn`, prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.className)
          }), {
            default: () => [isFunction(prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.children) ? prevButtonProps.children() : (_a2 = prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.children) !== null && _a2 !== void 0 ? _a2 : contextLocale.Previous]
          }) : null, createVNode(button_default, _objectSpread2(_objectSpread2({
            "type": mainBtnType
          }, nextButtonProps), {}, {
            "onClick": nextBtnClick,
            "size": "small",
            "class": classNames_default(`${prefixCls}-next-btn`, nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.className)
          }), {
            default: () => [isFunction(nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.children) ? nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.children() : isLastStep.value ? contextLocale.Finish : contextLocale.Next]
          })])])])]);
        }
      });
    };
  }
});
var panelRender_default = panelRender;

// node_modules/ant-design-vue/es/tour/useMergedType.js
var useMergedType = (_ref) => {
  let {
    defaultType,
    steps,
    current,
    defaultCurrent
  } = _ref;
  const innerCurrent = ref(defaultCurrent === null || defaultCurrent === void 0 ? void 0 : defaultCurrent.value);
  const mergedCurrent = computed(() => current === null || current === void 0 ? void 0 : current.value);
  watch(mergedCurrent, (val) => {
    innerCurrent.value = val !== null && val !== void 0 ? val : defaultCurrent === null || defaultCurrent === void 0 ? void 0 : defaultCurrent.value;
  }, {
    immediate: true
  });
  const updateInnerCurrent = (val) => {
    innerCurrent.value = val;
  };
  const innerType = computed(() => {
    var _a2, _b;
    return typeof innerCurrent.value === "number" ? steps && ((_b = (_a2 = steps.value) === null || _a2 === void 0 ? void 0 : _a2[innerCurrent.value]) === null || _b === void 0 ? void 0 : _b.type) : defaultType === null || defaultType === void 0 ? void 0 : defaultType.value;
  });
  const currentMergedType = computed(() => {
    var _a2;
    return (_a2 = innerType.value) !== null && _a2 !== void 0 ? _a2 : defaultType === null || defaultType === void 0 ? void 0 : defaultType.value;
  });
  return {
    currentMergedType,
    updateInnerCurrent
  };
};
var useMergedType_default = useMergedType;

// node_modules/ant-design-vue/es/tour/style/index.js
var genBaseStyle13 = (token) => {
  const {
    componentCls,
    lineHeight,
    padding,
    paddingXS,
    borderRadius,
    borderRadiusXS,
    colorPrimary,
    colorText,
    colorFill,
    indicatorHeight,
    indicatorWidth,
    boxShadowTertiary,
    tourZIndexPopup,
    fontSize,
    colorBgContainer,
    fontWeightStrong,
    marginXS,
    colorTextLightSolid,
    tourBorderRadius,
    colorWhite,
    colorBgTextHover,
    tourCloseSize,
    motionDurationSlow,
    antCls
  } = token;
  return [
    {
      [componentCls]: _extends(_extends({}, resetComponent(token)), {
        color: colorText,
        position: "absolute",
        zIndex: tourZIndexPopup,
        display: "block",
        visibility: "visible",
        fontSize,
        lineHeight,
        width: 520,
        "--antd-arrow-background-color": colorBgContainer,
        "&-pure": {
          maxWidth: "100%",
          position: "relative"
        },
        [`&${componentCls}-hidden`]: {
          display: "none"
        },
        // ============================= panel content ============================
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-inner`]: {
          textAlign: "start",
          textDecoration: "none",
          borderRadius: tourBorderRadius,
          boxShadow: boxShadowTertiary,
          position: "relative",
          backgroundColor: colorBgContainer,
          border: "none",
          backgroundClip: "padding-box",
          [`${componentCls}-close`]: {
            position: "absolute",
            top: padding,
            insetInlineEnd: padding,
            color: token.colorIcon,
            outline: "none",
            width: tourCloseSize,
            height: tourCloseSize,
            borderRadius: token.borderRadiusSM,
            transition: `background-color ${token.motionDurationMid}, color ${token.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            "&:hover": {
              color: token.colorIconHover,
              backgroundColor: token.wireframe ? "transparent" : token.colorFillContent
            }
          },
          [`${componentCls}-cover`]: {
            textAlign: "center",
            padding: `${padding + tourCloseSize + paddingXS}px ${padding}px 0`,
            img: {
              width: "100%"
            }
          },
          [`${componentCls}-header`]: {
            padding: `${padding}px ${padding}px ${paddingXS}px`,
            [`${componentCls}-title`]: {
              lineHeight,
              fontSize,
              fontWeight: fontWeightStrong
            }
          },
          [`${componentCls}-description`]: {
            padding: `0 ${padding}px`,
            lineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-footer`]: {
            padding: `${paddingXS}px ${padding}px ${padding}px`,
            textAlign: "end",
            borderRadius: `0 0 ${borderRadiusXS}px ${borderRadiusXS}px`,
            display: "flex",
            [`${componentCls}-indicators`]: {
              display: "inline-block",
              [`${componentCls}-indicator`]: {
                width: indicatorWidth,
                height: indicatorHeight,
                display: "inline-block",
                borderRadius: "50%",
                background: colorFill,
                "&:not(:last-child)": {
                  marginInlineEnd: indicatorHeight
                },
                "&-active": {
                  background: colorPrimary
                }
              }
            },
            [`${componentCls}-buttons`]: {
              marginInlineStart: "auto",
              [`${antCls}-btn`]: {
                marginInlineStart: marginXS
              }
            }
          }
        },
        // =============================  primary type  ===========================
        // `$` for panel, `&$` for pure panel
        [`${componentCls}-primary, &${componentCls}-primary`]: {
          "--antd-arrow-background-color": colorPrimary,
          [`${componentCls}-inner`]: {
            color: colorTextLightSolid,
            textAlign: "start",
            textDecoration: "none",
            backgroundColor: colorPrimary,
            borderRadius,
            boxShadow: boxShadowTertiary,
            [`${componentCls}-close`]: {
              color: colorTextLightSolid
            },
            [`${componentCls}-indicators`]: {
              [`${componentCls}-indicator`]: {
                background: new TinyColor(colorTextLightSolid).setAlpha(0.15).toRgbString(),
                "&-active": {
                  background: colorTextLightSolid
                }
              }
            },
            [`${componentCls}-prev-btn`]: {
              color: colorTextLightSolid,
              borderColor: new TinyColor(colorTextLightSolid).setAlpha(0.15).toRgbString(),
              backgroundColor: colorPrimary,
              "&:hover": {
                backgroundColor: new TinyColor(colorTextLightSolid).setAlpha(0.15).toRgbString(),
                borderColor: "transparent"
              }
            },
            [`${componentCls}-next-btn`]: {
              color: colorPrimary,
              borderColor: "transparent",
              background: colorWhite,
              "&:hover": {
                background: new TinyColor(colorBgTextHover).onBackground(colorWhite).toRgbString()
              }
            }
          }
        }
      }),
      // ============================= mask ===========================
      [`${componentCls}-mask`]: {
        [`${componentCls}-placeholder-animated`]: {
          transition: `all ${motionDurationSlow}`
        }
      },
      // =========== Limit left and right placement radius ==============
      [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
        [`${componentCls}-inner`]: {
          borderRadius: Math.min(tourBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
        }
      }
    },
    // ============================= Arrow ===========================
    getArrowStyle(token, {
      colorBg: "var(--antd-arrow-background-color)",
      contentRadius: tourBorderRadius,
      limitVerticalRadius: true
    })
  ];
};
var style_default39 = genComponentStyleHook("Tour", (token) => {
  const {
    borderRadiusLG,
    fontSize,
    lineHeight
  } = token;
  const TourToken = merge(token, {
    tourZIndexPopup: token.zIndexPopupBase + 70,
    indicatorWidth: 6,
    indicatorHeight: 6,
    tourBorderRadius: borderRadiusLG,
    tourCloseSize: fontSize * lineHeight
  });
  return [genBaseStyle13(TourToken)];
});

// node_modules/ant-design-vue/es/tour/index.js
var __rest40 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Tour2 = defineComponent({
  name: "ATour",
  inheritAttrs: false,
  props: tourProps2(),
  setup(props2, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      current,
      type,
      steps,
      defaultCurrent
    } = toRefs(props2);
    const {
      prefixCls,
      direction
    } = useConfigInject_default("tour", props2);
    const [wrapSSR, hashId] = style_default39(prefixCls);
    const {
      currentMergedType,
      updateInnerCurrent
    } = useMergedType_default({
      defaultType: type,
      steps,
      current,
      defaultCurrent
    });
    return () => {
      const {
        steps: steps2,
        current: current2,
        type: type2,
        rootClassName
      } = props2, restProps = __rest40(props2, ["steps", "current", "type", "rootClassName"]);
      const customClassName = classNames_default({
        [`${prefixCls.value}-primary`]: currentMergedType.value === "primary",
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, hashId.value, rootClassName);
      const mergedRenderPanel = (stepProps, stepCurrent) => {
        return createVNode(panelRender_default, _objectSpread2(_objectSpread2({}, stepProps), {}, {
          "type": type2,
          "current": stepCurrent
        }), {
          indicatorsRender: slots.indicatorsRender
        });
      };
      const onStepChange = (stepCurrent) => {
        updateInnerCurrent(stepCurrent);
        emit("update:current", stepCurrent);
        emit("change", stepCurrent);
      };
      const builtinPlacements = computed(() => getPlacements({
        arrowPointAtCenter: true,
        autoAdjustOverflow: true
      }));
      return wrapSSR(createVNode(vc_tour_default, _objectSpread2(_objectSpread2(_objectSpread2({}, attrs), restProps), {}, {
        "rootClassName": customClassName,
        "prefixCls": prefixCls.value,
        "current": current2,
        "defaultCurrent": props2.defaultCurrent,
        "animated": true,
        "renderPanel": mergedRenderPanel,
        "onChange": onStepChange,
        "steps": steps2,
        "builtinPlacements": builtinPlacements.value
      }), null));
    };
  }
});
var tour_default = withInstall(Tour2);

// node_modules/ant-design-vue/es/app/context.js
var AppConfigContextKey = Symbol("appConfigContext");
var useProvideAppConfigContext = (appConfigContext) => {
  return provide(AppConfigContextKey, appConfigContext);
};
var useInjectAppConfigContext = () => {
  return inject(AppConfigContextKey, {});
};
var AppContextKey = Symbol("appContext");
var useProvideAppContext = (appContext) => {
  return provide(AppContextKey, appContext);
};
var defaultAppContext = reactive({
  message: {},
  notification: {},
  modal: {}
});
var useInjectAppContext = () => {
  return inject(AppContextKey, defaultAppContext);
};

// node_modules/ant-design-vue/es/app/style/index.js
var genBaseStyle14 = (token) => {
  const {
    componentCls,
    colorText,
    fontSize,
    lineHeight,
    fontFamily
  } = token;
  return {
    [componentCls]: {
      color: colorText,
      fontSize,
      lineHeight,
      fontFamily
    }
  };
};
var style_default40 = genComponentStyleHook("App", (token) => [genBaseStyle14(token)]);

// node_modules/ant-design-vue/es/app/index.js
var AppProps = () => {
  return {
    rootClassName: String,
    message: objectType(),
    notification: objectType()
  };
};
var useApp = () => {
  return useInjectAppContext();
};
var App = defineComponent({
  name: "AApp",
  props: initDefaultProps_default(AppProps(), {}),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject_default("app", props2);
    const [wrapSSR, hashId] = style_default40(prefixCls);
    const customClassName = computed(() => {
      return classNames_default(hashId.value, prefixCls.value, props2.rootClassName);
    });
    const appConfig = useInjectAppConfigContext();
    const mergedAppConfig = computed(() => ({
      message: _extends(_extends({}, appConfig.message), props2.message),
      notification: _extends(_extends({}, appConfig.notification), props2.notification)
    }));
    useProvideAppConfigContext(mergedAppConfig.value);
    const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.value.message);
    const [notificationApi, notificationContextHolder] = useNotification(mergedAppConfig.value.notification);
    const [ModalApi, ModalContextHolder] = useModal_default();
    const memoizedContextValue = computed(() => ({
      message: messageApi,
      notification: notificationApi,
      modal: ModalApi
    }));
    useProvideAppContext(memoizedContextValue.value);
    return () => {
      var _a2;
      return wrapSSR(createVNode("div", {
        "class": customClassName.value
      }, [ModalContextHolder(), messageContextHolder(), notificationContextHolder(), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
App.useApp = useApp;
App.install = function(app) {
  app.component(App.name, App);
};
var app_default = App;

// node_modules/ant-design-vue/es/flex/utils.js
var flexWrapValues = ["wrap", "nowrap", "wrap-reverse"];
var justifyContentValues = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"];
var alignItemsValues = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"];
var genClsWrap = (prefixCls, props2) => {
  const wrapCls = {};
  flexWrapValues.forEach((cssKey) => {
    wrapCls[`${prefixCls}-wrap-${cssKey}`] = props2.wrap === cssKey;
  });
  return wrapCls;
};
var genClsAlign = (prefixCls, props2) => {
  const alignCls = {};
  alignItemsValues.forEach((cssKey) => {
    alignCls[`${prefixCls}-align-${cssKey}`] = props2.align === cssKey;
  });
  alignCls[`${prefixCls}-align-stretch`] = !props2.align && !!props2.vertical;
  return alignCls;
};
var genClsJustify = (prefixCls, props2) => {
  const justifyCls = {};
  justifyContentValues.forEach((cssKey) => {
    justifyCls[`${prefixCls}-justify-${cssKey}`] = props2.justify === cssKey;
  });
  return justifyCls;
};
function createFlexClassNames(prefixCls, props2) {
  return classNames_default(_extends(_extends(_extends({}, genClsWrap(prefixCls, props2)), genClsAlign(prefixCls, props2)), genClsJustify(prefixCls, props2)));
}
var utils_default = createFlexClassNames;

// node_modules/ant-design-vue/es/flex/style/index.js
var genFlexStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      display: "flex",
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
};
var genFlexGapStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      "&-gap-small": {
        gap: token.flexGapSM
      },
      "&-gap-middle": {
        gap: token.flexGap
      },
      "&-gap-large": {
        gap: token.flexGapLG
      }
    }
  };
};
var genFlexWrapStyle = (token) => {
  const {
    componentCls
  } = token;
  const wrapStyle = {};
  flexWrapValues.forEach((value) => {
    wrapStyle[`${componentCls}-wrap-${value}`] = {
      flexWrap: value
    };
  });
  return wrapStyle;
};
var genAlignItemsStyle = (token) => {
  const {
    componentCls
  } = token;
  const alignStyle = {};
  alignItemsValues.forEach((value) => {
    alignStyle[`${componentCls}-align-${value}`] = {
      alignItems: value
    };
  });
  return alignStyle;
};
var genJustifyContentStyle = (token) => {
  const {
    componentCls
  } = token;
  const justifyStyle = {};
  justifyContentValues.forEach((value) => {
    justifyStyle[`${componentCls}-justify-${value}`] = {
      justifyContent: value
    };
  });
  return justifyStyle;
};
var style_default41 = genComponentStyleHook("Flex", (token) => {
  const flexToken = merge(token, {
    flexGapSM: token.paddingXS,
    flexGap: token.padding,
    flexGapLG: token.paddingLG
  });
  return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
});

// node_modules/ant-design-vue/es/_util/gapSize.js
function isPresetSize(size) {
  return ["small", "middle", "large"].includes(size);
}

// node_modules/ant-design-vue/es/flex/interface.js
var flexProps = () => ({
  prefixCls: stringType(),
  vertical: booleanType(),
  wrap: stringType(),
  justify: stringType(),
  align: stringType(),
  flex: someType([Number, String]),
  gap: someType([Number, String]),
  component: anyType()
});

// node_modules/ant-design-vue/es/flex/index.js
var __rest41 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var AFlex = defineComponent({
  name: "AFlex",
  inheritAttrs: false,
  props: flexProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      flex: ctxFlex,
      direction: ctxDirection
    } = useConfigContextInject();
    const {
      prefixCls
    } = useConfigInject_default("flex", props2);
    const [wrapSSR, hashId] = style_default41(prefixCls);
    const mergedCls = computed(() => {
      var _a2;
      return [prefixCls.value, hashId.value, utils_default(prefixCls.value, props2), {
        [`${prefixCls.value}-rtl`]: ctxDirection.value === "rtl",
        [`${prefixCls.value}-gap-${props2.gap}`]: isPresetSize(props2.gap),
        [`${prefixCls.value}-vertical`]: (_a2 = props2.vertical) !== null && _a2 !== void 0 ? _a2 : ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.value.vertical
      }];
    });
    return () => {
      var _a2;
      const {
        flex,
        gap,
        component: Component = "div"
      } = props2, othersProps = __rest41(props2, ["flex", "gap", "component"]);
      const mergedStyle = {};
      if (flex) {
        mergedStyle.flex = flex;
      }
      if (gap && !isPresetSize(gap)) {
        mergedStyle.gap = `${gap}px`;
      }
      return wrapSSR(createVNode(Component, _objectSpread2({
        "class": [attrs.class, mergedCls.value],
        "style": [attrs.style, mergedStyle]
      }, omit_default(othersProps, ["justify", "wrap", "align", "vertical"])), {
        default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
      }));
    };
  }
});
var flex_default = withInstall(AFlex);

// node_modules/ant-design-vue/es/theme/themes/dark/colorAlgorithm.js
var getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
var getSolidColor = (baseColor, brightness) => {
  const instance = new TinyColor(baseColor);
  return instance.lighten(brightness).toHexString();
};

// node_modules/ant-design-vue/es/theme/themes/dark/colors.js
var generateColorPalettes = (baseColor) => {
  const colors = generate(baseColor, {
    theme: "dark"
  });
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[6],
    6: colors[5],
    7: colors[4],
    8: colors[6],
    9: colors[5],
    10: colors[4]
    // 8: colors[9],
    // 9: colors[8],
    // 10: colors[7],
  };
};
var generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000";
  const colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
    colorBgElevated: getSolidColor(colorBgBase, 12),
    colorBgContainer: getSolidColor(colorBgBase, 8),
    colorBgLayout: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getSolidColor(colorBgBase, 26),
    colorBorder: getSolidColor(colorBgBase, 26),
    colorBorderSecondary: getSolidColor(colorBgBase, 19)
  };
};

// node_modules/ant-design-vue/es/theme/themes/dark/index.js
var derivative2 = (token, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate(token[colorKey], {
      theme: "dark"
    });
    return new Array(10).fill(1).reduce((prev, _, i) => {
      prev[`${colorKey}-${i + 1}`] = colors[i];
      return prev;
    }, {});
  }).reduce((prev, cur) => {
    prev = _extends(_extends({}, prev), cur);
    return prev;
  }, {});
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative(token);
  return _extends(_extends(_extends({}, mergedMapToken), colorPalettes), genColorMapToken(token, {
    generateColorPalettes,
    generateNeutralColorPalettes
  }));
};
var dark_default = derivative2;

// node_modules/ant-design-vue/es/theme/themes/compact/genCompactSizeMapToken.js
function genSizeMapToken(token) {
  const {
    sizeUnit,
    sizeStep
  } = token;
  const compactSizeStep = sizeStep - 2;
  return {
    sizeXXL: sizeUnit * (compactSizeStep + 10),
    sizeXL: sizeUnit * (compactSizeStep + 6),
    sizeLG: sizeUnit * (compactSizeStep + 2),
    sizeMD: sizeUnit * (compactSizeStep + 2),
    sizeMS: sizeUnit * (compactSizeStep + 1),
    size: sizeUnit * compactSizeStep,
    sizeSM: sizeUnit * compactSizeStep,
    sizeXS: sizeUnit * (compactSizeStep - 1),
    sizeXXS: sizeUnit * (compactSizeStep - 1)
  };
}

// node_modules/ant-design-vue/es/theme/themes/compact/index.js
var derivative3 = (token, mapToken) => {
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative(token);
  const fontSize = mergedMapToken.fontSizeSM;
  const controlHeight = mergedMapToken.controlHeight - 4;
  return _extends(_extends(_extends(_extends(_extends({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token)), genFontMapToken_default(fontSize)), {
    // controlHeight
    controlHeight
  }), genControlHeight_default(_extends(_extends({}, mergedMapToken), {
    controlHeight
  })));
};
var compact_default = derivative3;

// node_modules/ant-design-vue/es/theme/index.js
function useToken2() {
  const [theme, token, hashId] = useToken();
  return {
    theme,
    token,
    hashId
  };
}
var theme_default = {
  /** @private Test Usage. Do not use in production. */
  defaultConfig,
  /** Default seedToken */
  defaultSeed: defaultConfig.token,
  useToken: useToken2,
  defaultAlgorithm: derivative,
  darkAlgorithm: dark_default,
  compactAlgorithm: compact_default
};

// node_modules/ant-design-vue/es/index.js
var install = function(app) {
  Object.keys(components_exports).forEach((key) => {
    const component = components_exports[key];
    if (component.install) {
      app.use(component);
    }
  });
  app.use(cssinjs_default.StyleProvider);
  app.config.globalProperties.$message = message_default;
  app.config.globalProperties.$notification = notification_default;
  app.config.globalProperties.$info = modal_default.info;
  app.config.globalProperties.$success = modal_default.success;
  app.config.globalProperties.$error = modal_default.error;
  app.config.globalProperties.$warning = modal_default.warning;
  app.config.globalProperties.$confirm = modal_default.confirm;
  app.config.globalProperties.$destroyAll = modal_default.destroyAll;
  return app;
};
var es_default2 = {
  version: version_default,
  install
};

export {
  affix_default,
  AnchorLink_default,
  anchor_default,
  AutoCompleteOption,
  AutoCompleteOptGroup,
  auto_complete_default,
  alert_default,
  Group_default4 as Group_default,
  avatar_default,
  Ribbon_default,
  badge_default,
  BreadcrumbItem_default,
  BreadcrumbSeparator_default,
  breadcrumb_default,
  calendar_default,
  TabPane_default,
  tabs_default,
  Title_default,
  Button_default,
  Input_default,
  Image_default,
  Avatar_default2 as Avatar_default,
  skeleton_default,
  Meta_default,
  Grid_default,
  card_default,
  CollapsePanel_default,
  collapse_default2 as collapse_default,
  carousel_default,
  cascader_default,
  grid_default,
  col_default,
  comment_default,
  WeekPicker,
  MonthPicker,
  QuarterPicker,
  RangePicker,
  date_picker_default,
  DescriptionsItem,
  descriptions_default,
  drawer_default,
  FloatButtonGroup_default,
  BackTop_default,
  float_button_default,
  PreviewGroup_default2 as PreviewGroup_default,
  image_default,
  input_number_default,
  LayoutHeader,
  LayoutFooter,
  LayoutSider,
  LayoutContent,
  layout_default2 as layout_default,
  ItemMeta_default,
  Item_default,
  list_default,
  MentionsOption,
  mentions_default,
  StatisticCountdown,
  statistic_default,
  page_header_default,
  progress_default2 as progress_default,
  rate_default,
  result_default,
  row_default,
  slider_default2 as slider_default,
  Step,
  steps_default,
  switch_default,
  transfer_default,
  TreeSelectNode,
  tree_select_default,
  TimeRangePicker,
  time_picker_default2 as time_picker_default,
  TimelineItem_default,
  timeline_default,
  Link_default,
  Paragraph_default2 as Paragraph_default,
  Text_default,
  Title_default2,
  typography_default,
  UploadDragger,
  upload_default,
  watermark_default,
  segmented_default2 as segmented_default,
  qrcode_default,
  tour_default,
  app_default,
  flex_default,
  theme_default,
  install,
  es_default2 as es_default
};
/*! Bundled license information:

ant-design-vue/es/qrcode/qrcodegen.js:
  (**
   * @license QR Code generator library (TypeScript)
   * Copyright (c) Project Nayuki.
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=chunk-OT6KIYUF.js.map
