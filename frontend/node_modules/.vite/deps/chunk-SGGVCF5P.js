import {
  ActionButton_default
} from "./chunk-VYZGBDEL.js";
import {
  useMergedState
} from "./chunk-EVNRSAPC.js";
import {
  KeyCode_default
} from "./chunk-ZE6KZP2H.js";
import {
  abstractTooltipProps_default,
  getArrowStyle,
  tooltipDefaultProps,
  tooltip_default
} from "./chunk-L725M3AB.js";
import {
  initZoomMotion
} from "./chunk-OUOMPTR7.js";
import {
  ExclamationCircleFilled_default
} from "./chunk-75I6BD7E.js";
import {
  getTransitionName
} from "./chunk-JBCV4ID2.js";
import {
  button_default,
  convertLegacyProps
} from "./chunk-KQNREJBH.js";
import {
  omit_default
} from "./chunk-ZHGUUDJD.js";
import {
  cloneVNodes
} from "./chunk-J25OO7CD.js";
import {
  PresetColors,
  _extends,
  _objectSpread2,
  anyType,
  classNames_default,
  en_US_default4 as en_US_default,
  filterEmpty,
  genComponentStyleHook,
  initDefaultProps_default,
  merge,
  objectType,
  resetComponent,
  stringType,
  useConfigInject_default,
  useLocaleReceiver,
  warning_default2 as warning_default,
  withInstall
} from "./chunk-4CTYA777.js";
import {
  Fragment,
  computed,
  createVNode,
  defineComponent,
  ref,
  toRef
} from "./chunk-VT7FWPCL.js";

// node_modules/ant-design-vue/es/popover/style/index.js
var genBaseStyle = (token) => {
  const {
    componentCls,
    popoverBg,
    popoverColor,
    width,
    fontWeightStrong,
    popoverPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG: borderRadius,
    zIndexPopup,
    marginXS,
    colorBgElevated
  } = token;
  return [
    {
      [componentCls]: _extends(_extends({}, resetComponent(token)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: true,
          value: 0
        },
        zIndex: zIndexPopup,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        "--antd-arrow-background-color": colorBgElevated,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-inner`]: {
          backgroundColor: popoverBg,
          backgroundClip: "padding-box",
          borderRadius,
          boxShadow: boxShadowSecondary,
          padding: popoverPadding
        },
        [`${componentCls}-title`]: {
          minWidth: width,
          marginBottom: marginXS,
          color: colorTextHeading,
          fontWeight: fontWeightStrong
        },
        [`${componentCls}-inner-content`]: {
          color: popoverColor
        }
      })
    },
    // Arrow Style
    getArrowStyle(token, {
      colorBg: "var(--antd-arrow-background-color)"
    }),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        [`${componentCls}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
};
var genColorStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: PresetColors.map((colorKey) => {
      const lightColor = token[`${colorKey}-6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          "--antd-arrow-background-color": lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
};
var genWireframeStyle = (token) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    colorSplit,
    paddingSM,
    controlHeight,
    fontSize,
    lineHeight,
    padding
  } = token;
  const titlePaddingBlockDist = controlHeight - Math.round(fontSize * lineHeight);
  const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
  const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
  const popoverPaddingHorizontal = padding;
  return {
    [componentCls]: {
      [`${componentCls}-inner`]: {
        padding: 0
      },
      [`${componentCls}-title`]: {
        margin: 0,
        padding: `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px`,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      [`${componentCls}-inner-content`]: {
        padding: `${paddingSM}px ${popoverPaddingHorizontal}px`
      }
    }
  };
};
var style_default = genComponentStyleHook("Popover", (token) => {
  const {
    colorBgElevated,
    colorText,
    wireframe
  } = token;
  const popoverToken = merge(token, {
    popoverBg: colorBgElevated,
    popoverColor: colorText,
    popoverPadding: 12
    // Fixed Value
  });
  return [genBaseStyle(popoverToken), genColorStyle(popoverToken), wireframe && genWireframeStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
}, (_ref) => {
  let {
    zIndexPopupBase
  } = _ref;
  return {
    zIndexPopup: zIndexPopupBase + 30,
    width: 177
  };
});

// node_modules/ant-design-vue/es/popover/index.js
var popoverProps = () => _extends(_extends({}, abstractTooltipProps_default()), {
  content: anyType(),
  title: anyType()
});
var Popover = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APopover",
  inheritAttrs: false,
  props: initDefaultProps_default(popoverProps(), _extends(_extends({}, tooltipDefaultProps()), {
    trigger: "hover",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1
  })),
  setup(props, _ref) {
    let {
      expose,
      slots,
      attrs
    } = _ref;
    const tooltipRef = ref();
    warning_default(props.visible === void 0, "popover", `\`visible\` will be removed in next major version, please use \`open\` instead.`);
    expose({
      getPopupDomNode: () => {
        var _a, _b;
        return (_b = (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    });
    const {
      prefixCls,
      configProvider
    } = useConfigInject_default("popover", props);
    const [wrapSSR, hashId] = style_default(prefixCls);
    const rootPrefixCls = computed(() => configProvider.getPrefixCls());
    const getOverlay = () => {
      var _a, _b;
      const {
        title = filterEmpty((_a = slots.title) === null || _a === void 0 ? void 0 : _a.call(slots)),
        content = filterEmpty((_b = slots.content) === null || _b === void 0 ? void 0 : _b.call(slots))
      } = props;
      const hasTitle = !!(Array.isArray(title) ? title.length : title);
      const hasContent = !!(Array.isArray(content) ? content.length : title);
      if (!hasTitle && !hasContent)
        return null;
      return createVNode(Fragment, null, [hasTitle && createVNode("div", {
        "class": `${prefixCls.value}-title`
      }, [title]), createVNode("div", {
        "class": `${prefixCls.value}-inner-content`
      }, [content])]);
    };
    return () => {
      const overlayCls = classNames_default(props.overlayClassName, hashId.value);
      return wrapSSR(createVNode(tooltip_default, _objectSpread2(_objectSpread2(_objectSpread2({}, omit_default(props, ["title", "content"])), attrs), {}, {
        "prefixCls": prefixCls.value,
        "ref": tooltipRef,
        "overlayClassName": overlayCls,
        "transitionName": getTransitionName(rootPrefixCls.value, "zoom-big", props.transitionName),
        "data-popover-inject": true
      }), {
        title: getOverlay,
        default: slots.default
      }));
    };
  }
});
var popover_default = withInstall(Popover);

// node_modules/ant-design-vue/es/popconfirm/style/index.js
var genBaseStyle2 = (token) => {
  const {
    componentCls,
    iconCls,
    zIndexPopup,
    colorText,
    colorWarning,
    marginXS,
    fontSize,
    fontWeightStrong,
    lineHeight
  } = token;
  return {
    [componentCls]: {
      zIndex: zIndexPopup,
      [`${componentCls}-inner-content`]: {
        color: colorText
      },
      [`${componentCls}-message`]: {
        position: "relative",
        marginBottom: marginXS,
        color: colorText,
        fontSize,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${componentCls}-message-icon ${iconCls}`]: {
          color: colorWarning,
          fontSize,
          flex: "none",
          lineHeight: 1,
          paddingTop: (Math.round(fontSize * lineHeight) - fontSize) / 2
        },
        "&-title": {
          flex: "auto",
          marginInlineStart: marginXS
        },
        "&-title-only": {
          fontWeight: fontWeightStrong
        }
      },
      [`${componentCls}-description`]: {
        position: "relative",
        marginInlineStart: fontSize + marginXS,
        marginBottom: marginXS,
        color: colorText,
        fontSize
      },
      [`${componentCls}-buttons`]: {
        textAlign: "end",
        button: {
          marginInlineStart: marginXS
        }
      }
    }
  };
};
var style_default2 = genComponentStyleHook("Popconfirm", (token) => genBaseStyle2(token), (token) => {
  const {
    zIndexPopupBase
  } = token;
  return {
    zIndexPopup: zIndexPopupBase + 60
  };
});

// node_modules/ant-design-vue/es/popconfirm/index.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var popconfirmProps = () => _extends(_extends({}, abstractTooltipProps_default()), {
  prefixCls: String,
  content: anyType(),
  title: anyType(),
  description: anyType(),
  okType: stringType("primary"),
  disabled: {
    type: Boolean,
    default: false
  },
  okText: anyType(),
  cancelText: anyType(),
  icon: anyType(),
  okButtonProps: objectType(),
  cancelButtonProps: objectType(),
  showCancel: {
    type: Boolean,
    default: true
  },
  onConfirm: Function,
  onCancel: Function
});
var Popconfirm = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APopconfirm",
  inheritAttrs: false,
  props: initDefaultProps_default(popconfirmProps(), _extends(_extends({}, tooltipDefaultProps()), {
    trigger: "click",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true,
    okType: "primary",
    disabled: false
  })),
  slots: Object,
  // emits: ['update:open', 'visibleChange'],
  setup(props, _ref) {
    let {
      slots,
      emit,
      expose,
      attrs
    } = _ref;
    const rootRef = ref();
    warning_default(props.visible === void 0, "Popconfirm", `\`visible\` will be removed in next major version, please use \`open\` instead.`);
    expose({
      getPopupDomNode: () => {
        var _a, _b;
        return (_b = (_a = rootRef.value) === null || _a === void 0 ? void 0 : _a.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    });
    const [open, setOpen] = useMergedState(false, {
      value: toRef(props, "open")
    });
    const settingOpen = (value, e) => {
      if (props.open === void 0) {
        setOpen(value);
      }
      emit("update:open", value);
      emit("openChange", value, e);
    };
    const close = (e) => {
      settingOpen(false, e);
    };
    const onConfirm = (e) => {
      var _a;
      return (_a = props.onConfirm) === null || _a === void 0 ? void 0 : _a.call(props, e);
    };
    const onCancel = (e) => {
      var _a;
      settingOpen(false, e);
      (_a = props.onCancel) === null || _a === void 0 ? void 0 : _a.call(props, e);
    };
    const onKeyDown = (e) => {
      if (e.keyCode === KeyCode_default.ESC && open) {
        settingOpen(false, e);
      }
    };
    const onOpenChange = (value) => {
      const {
        disabled
      } = props;
      if (disabled) {
        return;
      }
      settingOpen(value);
    };
    const {
      prefixCls: prefixClsConfirm,
      getPrefixCls
    } = useConfigInject_default("popconfirm", props);
    const rootPrefixCls = computed(() => getPrefixCls());
    const btnPrefixCls = computed(() => getPrefixCls("btn"));
    const [wrapSSR] = style_default2(prefixClsConfirm);
    const [popconfirmLocale] = useLocaleReceiver("Popconfirm", en_US_default.Popconfirm);
    const renderOverlay = () => {
      var _a, _b, _c, _d, _e;
      const {
        okButtonProps,
        cancelButtonProps,
        title = (_a = slots.title) === null || _a === void 0 ? void 0 : _a.call(slots),
        description = (_b = slots.description) === null || _b === void 0 ? void 0 : _b.call(slots),
        cancelText = (_c = slots.cancel) === null || _c === void 0 ? void 0 : _c.call(slots),
        okText = (_d = slots.okText) === null || _d === void 0 ? void 0 : _d.call(slots),
        okType,
        icon = ((_e = slots.icon) === null || _e === void 0 ? void 0 : _e.call(slots)) || createVNode(ExclamationCircleFilled_default, null, null),
        showCancel = true
      } = props;
      const {
        cancelButton,
        okButton
      } = slots;
      const cancelProps = _extends({
        onClick: onCancel,
        size: "small"
      }, cancelButtonProps);
      const okProps = _extends(_extends(_extends({
        onClick: onConfirm
      }, convertLegacyProps(okType)), {
        size: "small"
      }), okButtonProps);
      return createVNode("div", {
        "class": `${prefixClsConfirm.value}-inner-content`
      }, [createVNode("div", {
        "class": `${prefixClsConfirm.value}-message`
      }, [icon && createVNode("span", {
        "class": `${prefixClsConfirm.value}-message-icon`
      }, [icon]), createVNode("div", {
        "class": [`${prefixClsConfirm.value}-message-title`, {
          [`${prefixClsConfirm.value}-message-title-only`]: !!description
        }]
      }, [title])]), description && createVNode("div", {
        "class": `${prefixClsConfirm.value}-description`
      }, [description]), createVNode("div", {
        "class": `${prefixClsConfirm.value}-buttons`
      }, [showCancel ? cancelButton ? cancelButton(cancelProps) : createVNode(button_default, cancelProps, {
        default: () => [cancelText || popconfirmLocale.value.cancelText]
      }) : null, okButton ? okButton(okProps) : createVNode(ActionButton_default, {
        "buttonProps": _extends(_extends({
          size: "small"
        }, convertLegacyProps(okType)), okButtonProps),
        "actionFn": onConfirm,
        "close": close,
        "prefixCls": btnPrefixCls.value,
        "quitOnNullishReturnValue": true,
        "emitEvent": true
      }, {
        default: () => [okText || popconfirmLocale.value.okText]
      })])]);
    };
    return () => {
      var _a;
      const {
        placement,
        overlayClassName,
        trigger = "click"
      } = props, restProps = __rest(props, ["placement", "overlayClassName", "trigger"]);
      const otherProps = omit_default(restProps, ["title", "content", "cancelText", "okText", "onUpdate:open", "onConfirm", "onCancel", "prefixCls"]);
      const overlayClassNames = classNames_default(prefixClsConfirm.value, overlayClassName);
      return wrapSSR(createVNode(popover_default, _objectSpread2(_objectSpread2(_objectSpread2({}, otherProps), attrs), {}, {
        "trigger": trigger,
        "placement": placement,
        "onOpenChange": onOpenChange,
        "open": open.value,
        "overlayClassName": overlayClassNames,
        "transitionName": getTransitionName(rootPrefixCls.value, "zoom-big", props.transitionName),
        "ref": rootRef,
        "data-popover-inject": true
      }), {
        default: () => [cloneVNodes(((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)) || [], {
          onKeydown: (e) => {
            onKeyDown(e);
          }
        }, false)],
        content: renderOverlay
      }));
    };
  }
});
var popconfirm_default = withInstall(Popconfirm);

export {
  popover_default,
  popconfirmProps,
  popconfirm_default
};
//# sourceMappingURL=chunk-SGGVCF5P.js.map
